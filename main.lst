   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_crc8_ccitt_update:
  12               	.LFB4:
  13               		.file 1 "/usr/lib/avr/include/util/crc16.h"
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/lib/avr/include/util/crc16.h **** 
   7:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/lib/avr/include/util/crc16.h **** 
  10:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/lib/avr/include/util/crc16.h **** 
  13:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/lib/avr/include/util/crc16.h ****      distribution.
  17:/usr/lib/avr/include/util/crc16.h **** 
  18:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/lib/avr/include/util/crc16.h **** 
  22:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** /* $Id$ */
  35:/usr/lib/avr/include/util/crc16.h **** 
  36:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/lib/avr/include/util/crc16.h **** 
  41:/usr/lib/avr/include/util/crc16.h **** /** \file */
  42:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/lib/avr/include/util/crc16.h **** 
  45:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par References:
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     \par
  51:/usr/lib/avr/include/util/crc16.h **** 
  52:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     \par
  57:/usr/lib/avr/include/util/crc16.h **** 
  58:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/lib/avr/include/util/crc16.h **** 
  65:/usr/lib/avr/include/util/crc16.h ****     \code
  66:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/lib/avr/include/util/crc16.h **** 
  69:/usr/lib/avr/include/util/crc16.h ****     int
  70:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/lib/avr/include/util/crc16.h ****     {
  72:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/lib/avr/include/util/crc16.h **** 
  74:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/lib/avr/include/util/crc16.h **** 
  77:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/lib/avr/include/util/crc16.h ****     }
  79:/usr/lib/avr/include/util/crc16.h ****     \endcode
  80:/usr/lib/avr/include/util/crc16.h **** */
  81:/usr/lib/avr/include/util/crc16.h **** 
  82:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/lib/avr/include/util/crc16.h **** 
  85:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/lib/avr/include/util/crc16.h **** 
  92:/usr/lib/avr/include/util/crc16.h ****     \code
  93:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  94:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/lib/avr/include/util/crc16.h ****     {
  96:/usr/lib/avr/include/util/crc16.h **** 	int i;
  97:/usr/lib/avr/include/util/crc16.h **** 
  98:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/lib/avr/include/util/crc16.h **** 	{
 101:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/lib/avr/include/util/crc16.h **** 	    else
 104:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/lib/avr/include/util/crc16.h **** 	}
 106:/usr/lib/avr/include/util/crc16.h **** 
 107:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 108:/usr/lib/avr/include/util/crc16.h ****     }
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 111:/usr/lib/avr/include/util/crc16.h **** 
 112:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/lib/avr/include/util/crc16.h **** {
 115:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/lib/avr/include/util/crc16.h **** 
 118:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/lib/avr/include/util/crc16.h **** 	);
 146:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/lib/avr/include/util/crc16.h **** }
 148:/usr/lib/avr/include/util/crc16.h **** 
 149:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/lib/avr/include/util/crc16.h **** 
 152:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/lib/avr/include/util/crc16.h **** 
 159:/usr/lib/avr/include/util/crc16.h ****     \code
 160:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 161:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/lib/avr/include/util/crc16.h ****     {
 163:/usr/lib/avr/include/util/crc16.h ****         int i;
 164:/usr/lib/avr/include/util/crc16.h **** 
 165:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/lib/avr/include/util/crc16.h ****         {
 168:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/lib/avr/include/util/crc16.h ****             else
 171:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/lib/avr/include/util/crc16.h ****         }
 173:/usr/lib/avr/include/util/crc16.h **** 
 174:/usr/lib/avr/include/util/crc16.h ****         return crc;
 175:/usr/lib/avr/include/util/crc16.h ****     }
 176:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 177:/usr/lib/avr/include/util/crc16.h **** 
 178:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/lib/avr/include/util/crc16.h **** {
 181:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/lib/avr/include/util/crc16.h **** 
 186:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 187:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 188:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 189:/usr/lib/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 190:/usr/lib/avr/include/util/crc16.h **** 
 191:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 192:/usr/lib/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 193:/usr/lib/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 194:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 195:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 196:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 197:/usr/lib/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 198:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 199:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 200:/usr/lib/avr/include/util/crc16.h **** 
 201:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 202:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 203:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 204:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 205:/usr/lib/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 206:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 207:/usr/lib/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 208:/usr/lib/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 209:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 211:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 212:/usr/lib/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 213:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 214:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 215:/usr/lib/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 216:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 217:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 218:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 219:/usr/lib/avr/include/util/crc16.h ****     );
 220:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 221:/usr/lib/avr/include/util/crc16.h **** }
 222:/usr/lib/avr/include/util/crc16.h **** 
 223:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 224:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-CCITT calculation.
 225:/usr/lib/avr/include/util/crc16.h **** 
 226:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x8408)<br>
 227:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
 228:/usr/lib/avr/include/util/crc16.h **** 
 229:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by PPP and IrDA.
 230:/usr/lib/avr/include/util/crc16.h **** 
 231:/usr/lib/avr/include/util/crc16.h ****     See RFC1171 (PPP protocol) and IrDA IrLAP 1.1
 232:/usr/lib/avr/include/util/crc16.h **** 
 233:/usr/lib/avr/include/util/crc16.h ****     \note Although the CCITT polynomial is the same as that used by the Xmodem
 234:/usr/lib/avr/include/util/crc16.h ****     protocol, they are quite different. The difference is in how the bits are
 235:/usr/lib/avr/include/util/crc16.h ****     shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
 236:/usr/lib/avr/include/util/crc16.h ****     input first, while CCITT shifts the LSB of the CRC and the input first.
 237:/usr/lib/avr/include/util/crc16.h **** 
 238:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 239:/usr/lib/avr/include/util/crc16.h **** 
 240:/usr/lib/avr/include/util/crc16.h ****     \code
 241:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 242:/usr/lib/avr/include/util/crc16.h ****     crc_ccitt_update (uint16_t crc, uint8_t data)
 243:/usr/lib/avr/include/util/crc16.h ****     {
 244:/usr/lib/avr/include/util/crc16.h ****         data ^= lo8 (crc);
 245:/usr/lib/avr/include/util/crc16.h ****         data ^= data << 4;
 246:/usr/lib/avr/include/util/crc16.h **** 
 247:/usr/lib/avr/include/util/crc16.h ****         return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
 248:/usr/lib/avr/include/util/crc16.h ****                 ^ ((uint16_t)data << 3));
 249:/usr/lib/avr/include/util/crc16.h ****     }
 250:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 251:/usr/lib/avr/include/util/crc16.h **** 
 252:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 253:/usr/lib/avr/include/util/crc16.h **** _crc_ccitt_update (uint16_t __crc, uint8_t __data)
 254:/usr/lib/avr/include/util/crc16.h **** {
 255:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;
 256:/usr/lib/avr/include/util/crc16.h **** 
 257:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 258:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%1"          "\n\t"
 259:/usr/lib/avr/include/util/crc16.h **** 
 260:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%A0" "\n\t"
 261:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 262:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0xf0"        "\n\t"
 263:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__" "\n\t"
 264:/usr/lib/avr/include/util/crc16.h **** 
 265:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 266:/usr/lib/avr/include/util/crc16.h **** 
 267:/usr/lib/avr/include/util/crc16.h ****         "mov    %B0,%A0"         "\n\t"
 268:/usr/lib/avr/include/util/crc16.h **** 
 269:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 270:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0x0f"        "\n\t"
 271:/usr/lib/avr/include/util/crc16.h ****         "eor    __tmp_reg__,%A0" "\n\t"
 272:/usr/lib/avr/include/util/crc16.h **** 
 273:/usr/lib/avr/include/util/crc16.h ****         "lsr    %A0"             "\n\t"
 274:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t"
 275:/usr/lib/avr/include/util/crc16.h **** 
 276:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%B0"         "\n\t"
 277:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 278:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 279:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 280:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__"
 281:/usr/lib/avr/include/util/crc16.h **** 
 282:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret)
 283:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 284:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 285:/usr/lib/avr/include/util/crc16.h ****     );
 286:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 287:/usr/lib/avr/include/util/crc16.h **** }
 288:/usr/lib/avr/include/util/crc16.h **** 
 289:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 290:/usr/lib/avr/include/util/crc16.h ****     Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
 291:/usr/lib/avr/include/util/crc16.h **** 
 292:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
 293:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 294:/usr/lib/avr/include/util/crc16.h **** 
 295:/usr/lib/avr/include/util/crc16.h ****     See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 296:/usr/lib/avr/include/util/crc16.h **** 
 297:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 298:/usr/lib/avr/include/util/crc16.h **** 
 299:/usr/lib/avr/include/util/crc16.h ****     \code
 300:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 301:/usr/lib/avr/include/util/crc16.h ****     _crc_ibutton_update(uint8_t crc, uint8_t data)
 302:/usr/lib/avr/include/util/crc16.h ****     {
 303:/usr/lib/avr/include/util/crc16.h **** 	uint8_t i;
 304:/usr/lib/avr/include/util/crc16.h **** 
 305:/usr/lib/avr/include/util/crc16.h **** 	crc = crc ^ data;
 306:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; i++)
 307:/usr/lib/avr/include/util/crc16.h **** 	{
 308:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 0x01)
 309:/usr/lib/avr/include/util/crc16.h **** 	        crc = (crc >> 1) ^ 0x8C;
 310:/usr/lib/avr/include/util/crc16.h **** 	    else
 311:/usr/lib/avr/include/util/crc16.h **** 	        crc >>= 1;
 312:/usr/lib/avr/include/util/crc16.h **** 	}
 313:/usr/lib/avr/include/util/crc16.h **** 
 314:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 315:/usr/lib/avr/include/util/crc16.h ****     }
 316:/usr/lib/avr/include/util/crc16.h ****     \endcode
 317:/usr/lib/avr/include/util/crc16.h **** */
 318:/usr/lib/avr/include/util/crc16.h **** 
 319:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 320:/usr/lib/avr/include/util/crc16.h **** _crc_ibutton_update(uint8_t __crc, uint8_t __data)
 321:/usr/lib/avr/include/util/crc16.h **** {
 322:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __i, __pattern;
 323:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 324:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %4" "\n\t"
 325:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%1, 8" "\n\t"
 326:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%2, 0x8C" "\n\t"
 327:/usr/lib/avr/include/util/crc16.h **** 		"1:	lsr	%0" "\n\t"
 328:/usr/lib/avr/include/util/crc16.h **** 		"	brcc	2f" "\n\t"
 329:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %2" "\n\t"
 330:/usr/lib/avr/include/util/crc16.h **** 		"2:	dec	%1" "\n\t"
 331:/usr/lib/avr/include/util/crc16.h **** 		"	brne	1b" "\n\t"
 332:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
 333:/usr/lib/avr/include/util/crc16.h **** 		: "0" (__crc), "r" (__data));
 334:/usr/lib/avr/include/util/crc16.h **** 	return __crc;
 335:/usr/lib/avr/include/util/crc16.h **** }
 336:/usr/lib/avr/include/util/crc16.h **** 
 337:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 338:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-8-CCITT calculation.
 339:/usr/lib/avr/include/util/crc16.h **** 
 340:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
 341:/usr/lib/avr/include/util/crc16.h ****     
 342:/usr/lib/avr/include/util/crc16.h ****     For use with simple CRC-8<br>
 343:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 344:/usr/lib/avr/include/util/crc16.h ****     
 345:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ROHC<br>
 346:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 347:/usr/lib/avr/include/util/crc16.h ****     Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
 348:/usr/lib/avr/include/util/crc16.h ****     
 349:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ATM/ITU<br>
 350:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 351:/usr/lib/avr/include/util/crc16.h ****     Final XOR value: 0x55<br>
 352:/usr/lib/avr/include/util/crc16.h ****     Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
 353:/usr/lib/avr/include/util/crc16.h ****     
 354:/usr/lib/avr/include/util/crc16.h ****     The C equivalent has been originally written by Dave Hylands.
 355:/usr/lib/avr/include/util/crc16.h ****     Assembly code is based on _crc_ibutton_update optimization.
 356:/usr/lib/avr/include/util/crc16.h **** 
 357:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 358:/usr/lib/avr/include/util/crc16.h **** 
 359:/usr/lib/avr/include/util/crc16.h ****     \code
 360:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 361:/usr/lib/avr/include/util/crc16.h ****     _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
 362:/usr/lib/avr/include/util/crc16.h ****     {
 363:/usr/lib/avr/include/util/crc16.h ****         uint8_t   i;
 364:/usr/lib/avr/include/util/crc16.h ****         uint8_t   data;
 365:/usr/lib/avr/include/util/crc16.h **** 
 366:/usr/lib/avr/include/util/crc16.h ****         data = inCrc ^ inData;
 367:/usr/lib/avr/include/util/crc16.h **** 
 368:/usr/lib/avr/include/util/crc16.h ****         for ( i = 0; i < 8; i++ )
 369:/usr/lib/avr/include/util/crc16.h ****         {
 370:/usr/lib/avr/include/util/crc16.h ****             if (( data & 0x80 ) != 0 )
 371:/usr/lib/avr/include/util/crc16.h ****             {
 372:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 373:/usr/lib/avr/include/util/crc16.h ****                 data ^= 0x07;
 374:/usr/lib/avr/include/util/crc16.h ****             }
 375:/usr/lib/avr/include/util/crc16.h ****             else
 376:/usr/lib/avr/include/util/crc16.h ****             {
 377:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 378:/usr/lib/avr/include/util/crc16.h ****             }
 379:/usr/lib/avr/include/util/crc16.h ****         }
 380:/usr/lib/avr/include/util/crc16.h ****         return data;
 381:/usr/lib/avr/include/util/crc16.h ****     }
 382:/usr/lib/avr/include/util/crc16.h ****     \endcode
 383:/usr/lib/avr/include/util/crc16.h **** */
 384:/usr/lib/avr/include/util/crc16.h **** 
 385:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 386:/usr/lib/avr/include/util/crc16.h **** _crc8_ccitt_update(uint8_t __crc, uint8_t __data)
 387:/usr/lib/avr/include/util/crc16.h **** {
  14               		.loc 1 387 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 388:/usr/lib/avr/include/util/crc16.h ****     uint8_t __i, __pattern;
 389:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
  21               		.loc 1 389 0
  22               	/* #APP */
  23               	 ;  389 "/usr/lib/avr/include/util/crc16.h" 1
  24 0000 8627      		    eor    r24, r22
  25 0002 98E0      		    ldi    r25, 8
  26 0004 67E0      		    ldi    r22, 0x07
  27 0006 880F      		1:  lsl    r24
  28 0008 00F4      		    brcc   2f
  29 000a 8627      		    eor    r24, r22
  30 000c 9A95      		2:  dec    r25
  31 000e 01F4      		    brne   1b
  32               		
  33               	 ;  0 "" 2
  34               	.LVL1:
 390:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %4" "\n\t"
 391:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %1, 8" "\n\t"
 392:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %2, 0x07" "\n\t"
 393:/usr/lib/avr/include/util/crc16.h ****         "1:  lsl    %0" "\n\t"
 394:/usr/lib/avr/include/util/crc16.h ****         "    brcc   2f" "\n\t"
 395:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %2" "\n\t"
 396:/usr/lib/avr/include/util/crc16.h ****         "2:  dec    %1" "\n\t"
 397:/usr/lib/avr/include/util/crc16.h ****         "    brne   1b" "\n\t"
 398:/usr/lib/avr/include/util/crc16.h ****         : "=r" (__crc), "=d" (__i), "=d" (__pattern)
 399:/usr/lib/avr/include/util/crc16.h ****         : "0" (__crc), "r" (__data));
 400:/usr/lib/avr/include/util/crc16.h ****     return __crc;
 401:/usr/lib/avr/include/util/crc16.h **** }
  35               		.loc 1 401 0
  36               	/* #NOAPP */
  37 0010 0895      		ret
  38               		.cfi_endproc
  39               	.LFE4:
  41               	.global	ws2812_sendarray_mask
  43               	ws2812_sendarray_mask:
  44               	.LFB23:
  45               		.file 2 "light_ws2812.c"
   1:light_ws2812.c **** /*
   2:light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:light_ws2812.c **** *
   4:light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:light_ws2812.c **** *
   7:light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:light_ws2812.c **** *
   9:light_ws2812.c **** *
  10:light_ws2812.c **** * Jun 2019, modified for SHPI by Lutz Harder
  11:light_ws2812.c **** * License: GNU GPL v2+ (see License.txt)
  12:light_ws2812.c **** */
  13:light_ws2812.c **** 
  14:light_ws2812.c **** #include "light_ws2812.h"
  15:light_ws2812.c **** #include <avr/interrupt.h>
  16:light_ws2812.c **** #include <avr/io.h>
  17:light_ws2812.c **** #include <util/delay.h>
  18:light_ws2812.c ****  
  19:light_ws2812.c **** // Setleds for standard RGB 
  20:light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  21:light_ws2812.c **** {
  22:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  23:light_ws2812.c **** }
  24:light_ws2812.c **** 
  25:light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  26:light_ws2812.c **** {
  27:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  28:light_ws2812.c ****   _delay_us(ws2812_resettime);
  29:light_ws2812.c **** }
  30:light_ws2812.c **** 
  31:light_ws2812.c **** 
  32:light_ws2812.c **** 
  33:light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  34:light_ws2812.c **** {
  35:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  36:light_ws2812.c **** }
  37:light_ws2812.c **** 
  38:light_ws2812.c **** /*
  39:light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  40:light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  41:light_ws2812.c **** */
  42:light_ws2812.c **** 
  43:light_ws2812.c **** // Timing in ns
  44:light_ws2812.c **** #define w_zeropulse   350
  45:light_ws2812.c **** #define w_onepulse    900
  46:light_ws2812.c **** #define w_totalperiod 120
  47:light_ws2812.c **** 
  48:light_ws2812.c **** // Fixed cycles used by the inner loop
  49:light_ws2812.c **** #define w_fixedlow    2
  50:light_ws2812.c **** #define w_fixedhigh   4
  51:light_ws2812.c **** #define w_fixedtotal  8   
  52:light_ws2812.c **** 
  53:light_ws2812.c **** // Insert NOPs to match the timing, if possible
  54:light_ws2812.c **** #define w_zerocycles    (((F_CPU/1000)*w_zeropulse          )/1000000)
  55:light_ws2812.c **** #define w_onecycles     (((F_CPU/1000)*w_onepulse    +500000)/1000000)
  56:light_ws2812.c **** #define w_totalcycles   (((F_CPU/1000)*w_totalperiod +500000)/1000000)
  57:light_ws2812.c **** 
  58:light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  59:light_ws2812.c **** #define w1 (w_zerocycles-w_fixedlow)
  60:light_ws2812.c **** // w2   nops between fe low and fe high
  61:light_ws2812.c **** #define w2 (w_onecycles-w_fixedhigh-w1)
  62:light_ws2812.c **** // w3   nops to complete loop
  63:light_ws2812.c **** #define w3 (w_totalcycles-w_fixedtotal-w1-w2)
  64:light_ws2812.c **** 
  65:light_ws2812.c **** #if w1>0
  66:light_ws2812.c ****   #define w1_nops w1
  67:light_ws2812.c **** #else
  68:light_ws2812.c ****   #define w1_nops  0
  69:light_ws2812.c **** #endif
  70:light_ws2812.c **** 
  71:light_ws2812.c **** // The only critical timing parameter is the minimum pulse length of the "0"
  72:light_ws2812.c **** // Warn or throw error if this timing can not be met with current F_CPU settings.
  73:light_ws2812.c **** #define w_lowtime ((w1_nops+w_fixedlow)*1000000)/(F_CPU/1000)
  74:light_ws2812.c **** #if w_lowtime>550
  75:light_ws2812.c ****    #error "Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?"
  76:light_ws2812.c **** #elif w_lowtime>450
  77:light_ws2812.c ****    #warning "Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S)."
  78:light_ws2812.c ****    #warning "Please consider a higher clockspeed, if possible"
  79:light_ws2812.c **** #endif   
  80:light_ws2812.c **** 
  81:light_ws2812.c **** #if w2>0
  82:light_ws2812.c **** #define w2_nops w2
  83:light_ws2812.c **** #else
  84:light_ws2812.c **** #define w2_nops  0
  85:light_ws2812.c **** #endif
  86:light_ws2812.c **** 
  87:light_ws2812.c **** #if w3>0
  88:light_ws2812.c **** #define w3_nops w3
  89:light_ws2812.c **** #else
  90:light_ws2812.c **** #define w3_nops  0
  91:light_ws2812.c **** #endif
  92:light_ws2812.c **** 
  93:light_ws2812.c **** #define w_nop1  "nop      \n\t"
  94:light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
  95:light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
  96:light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
  97:light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
  98:light_ws2812.c **** 
  99:light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 100:light_ws2812.c **** {
  46               		.loc 2 100 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 101:light_ws2812.c ****   uint8_t curbyte,ctr,masklo;
 102:light_ws2812.c ****   uint8_t sreg_prev;
 103:light_ws2812.c ****   
 104:light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  53               		.loc 2 104 0
  54 0012 2AB1      		in r18,0xa
  55 0014 242B      		or r18,r20
  56 0016 2AB9      		out 0xa,r18
 105:light_ws2812.c ****   
 106:light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  57               		.loc 2 106 0
  58 0018 2BB1      		in r18,0xb
  59 001a 342F      		mov r19,r20
  60 001c 3095      		com r19
  61 001e 2323      		and r18,r19
  62               	.LVL3:
 107:light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  63               		.loc 2 107 0
  64 0020 3BB1      		in r19,0xb
  65 0022 432B      		or r20,r19
  66               	.LVL4:
 108:light_ws2812.c ****   
 109:light_ws2812.c ****   sreg_prev=SREG;
  67               		.loc 2 109 0
  68 0024 3FB7      		in r19,__SREG__
  69               	.LVL5:
 110:light_ws2812.c ****   cli();  
  70               		.loc 2 110 0
  71               	/* #APP */
  72               	 ;  110 "light_ws2812.c" 1
  73 0026 F894      		cli
  74               	 ;  0 "" 2
  75               	/* #NOAPP */
  76 0028 FC01      		movw r30,r24
  77 002a 680F      		add r22,r24
  78 002c 791F      		adc r23,r25
  79               	.LVL6:
  80               	.L3:
 111:light_ws2812.c **** 
 112:light_ws2812.c ****   while (datlen--) {
  81               		.loc 2 112 0
  82 002e E617      		cp r30,r22
  83 0030 F707      		cpc r31,r23
  84 0032 01F0      		breq .L6
  85               	.LVL7:
 113:light_ws2812.c ****     curbyte=*data++;
  86               		.loc 2 113 0
  87 0034 8191      		ld r24,Z+
  88               	.LVL8:
 114:light_ws2812.c ****     
 115:light_ws2812.c ****     asm volatile(
  89               		.loc 2 115 0
  90               	/* #APP */
  91               	 ;  115 "light_ws2812.c" 1
  92 0036 98E0      		       ldi   r25,8  
  93               		loop59:            
  94 0038 4BB9      		       out   11,r20 
  95 003a 0000      		nop      
  96 003c 00C0      		rjmp .+0 
  97 003e 87FF      		       sbrs  r24,7  
  98 0040 2BB9      		       out   11,r18 
  99 0042 880F      		       lsl   r24    
 100 0044 0000      		nop      
 101 0046 00C0      		rjmp .+0 
 102 0048 00C0      		rjmp .+0 
 103 004a 00C0      		rjmp .+0 
 104 004c 2BB9      		       out   11,r18 
 105 004e 00C0      		rjmp .+0 
 106 0050 00C0      		rjmp .+0 
 107 0052 00C0      		rjmp .+0 
 108 0054 00C0      		rjmp .+0 
 109 0056 00C0      		rjmp .+0 
 110 0058 00C0      		rjmp .+0 
 111 005a 00C0      		rjmp .+0 
 112 005c 00C0      		rjmp .+0 
 113 005e 9A95      		       dec   r25    
 114 0060 01F4      		       brne  loop59
 115               		
 116               	 ;  0 "" 2
 117               	.LVL9:
 118               	/* #NOAPP */
 119 0062 00C0      		rjmp .L3
 120               	.LVL10:
 121               	.L6:
 116:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 117:light_ws2812.c ****     "loop%=:            \n\t"
 118:light_ws2812.c ****     "       out   %2,%3 \n\t"    
 119:light_ws2812.c **** #if (w1_nops&1)
 120:light_ws2812.c **** w_nop1
 121:light_ws2812.c **** #endif
 122:light_ws2812.c **** #if (w1_nops&2)
 123:light_ws2812.c **** w_nop2
 124:light_ws2812.c **** #endif
 125:light_ws2812.c **** #if (w1_nops&4)
 126:light_ws2812.c **** w_nop4
 127:light_ws2812.c **** #endif
 128:light_ws2812.c **** #if (w1_nops&8)
 129:light_ws2812.c **** w_nop8
 130:light_ws2812.c **** #endif
 131:light_ws2812.c **** #if (w1_nops&16)
 132:light_ws2812.c **** w_nop16
 133:light_ws2812.c **** #endif
 134:light_ws2812.c ****     "       sbrs  %1,7  \n\t"   
 135:light_ws2812.c ****     "       out   %2,%4 \n\t"  
 136:light_ws2812.c ****     "       lsl   %1    \n\t"   
 137:light_ws2812.c **** #if (w2_nops&1)
 138:light_ws2812.c ****   w_nop1
 139:light_ws2812.c **** #endif
 140:light_ws2812.c **** #if (w2_nops&2)
 141:light_ws2812.c ****   w_nop2
 142:light_ws2812.c **** #endif
 143:light_ws2812.c **** #if (w2_nops&4)
 144:light_ws2812.c ****   w_nop4
 145:light_ws2812.c **** #endif
 146:light_ws2812.c **** #if (w2_nops&8)
 147:light_ws2812.c ****   w_nop8
 148:light_ws2812.c **** #endif
 149:light_ws2812.c **** #if (w2_nops&16)
 150:light_ws2812.c ****   w_nop16 
 151:light_ws2812.c **** #endif
 152:light_ws2812.c ****     "       out   %2,%4 \n\t"   
 153:light_ws2812.c **** #if (w3_nops&1)
 154:light_ws2812.c **** w_nop1
 155:light_ws2812.c **** #endif
 156:light_ws2812.c **** #if (w3_nops&2)
 157:light_ws2812.c **** w_nop2
 158:light_ws2812.c **** #endif
 159:light_ws2812.c **** #if (w3_nops&4)
 160:light_ws2812.c **** w_nop4
 161:light_ws2812.c **** #endif
 162:light_ws2812.c **** #if (w3_nops&8)
 163:light_ws2812.c **** w_nop8
 164:light_ws2812.c **** #endif
 165:light_ws2812.c **** #if (w3_nops&16)
 166:light_ws2812.c **** w_nop16
 167:light_ws2812.c **** #endif
 168:light_ws2812.c **** 
 169:light_ws2812.c ****     "       dec   %0    \n\t"   
 170:light_ws2812.c ****     "       brne  loop%=\n\t"   
 171:light_ws2812.c ****     :	"=&d" (ctr)
 172:light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 173:light_ws2812.c ****     );
 174:light_ws2812.c ****   }
 175:light_ws2812.c ****   
 176:light_ws2812.c ****   SREG=sreg_prev;
 122               		.loc 2 176 0
 123 0064 3FBF      		out __SREG__,r19
 124 0066 0895      		ret
 125               		.cfi_endproc
 126               	.LFE23:
 128               	.global	ws2812_setleds_pin
 130               	ws2812_setleds_pin:
 131               	.LFB21:
  26:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 132               		.loc 2 26 0
 133               		.cfi_startproc
 134               	.LVL11:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 139               		.loc 2 27 0
 140 0068 9B01      		movw r18,r22
 141 006a 220F      		lsl r18
 142 006c 331F      		rol r19
 143 006e 620F      		add r22,r18
 144 0070 731F      		adc r23,r19
 145               	.LVL12:
 146 0072 0E94 0000 		call ws2812_sendarray_mask
 147               	.LVL13:
 148               	.LBB47:
 149               	.LBB48:
 150               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 151               		.loc 3 276 0
 152 0076 8FEA      		ldi r24,lo8(1199)
 153 0078 94E0      		ldi r25,hi8(1199)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL14:
 159 0082 0895      		ret
 160               	.LBE48:
 161               	.LBE47:
 162               		.cfi_endproc
 163               	.LFE21:
 165               	.global	ws2812_setleds
 167               	ws2812_setleds:
 168               	.LFB20:
  21:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 169               		.loc 2 21 0
 170               		.cfi_startproc
 171               	.LVL15:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  22:light_ws2812.c **** }
 176               		.loc 2 22 0
 177 0084 40E2      		ldi r20,lo8(32)
 178 0086 0C94 0000 		jmp ws2812_setleds_pin
 179               	.LVL16:
 180               		.cfi_endproc
 181               	.LFE20:
 183               	.global	ws2812_sendarray
 185               	ws2812_sendarray:
 186               	.LFB22:
  34:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 187               		.loc 2 34 0
 188               		.cfi_startproc
 189               	.LVL17:
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 0 */
 193               	.L__stack_usage = 0
  35:light_ws2812.c **** }
 194               		.loc 2 35 0
 195 008a 40E2      		ldi r20,lo8(32)
 196 008c 0C94 0000 		jmp ws2812_sendarray_mask
 197               	.LVL18:
 198               		.cfi_endproc
 199               	.LFE22:
 201               	.global	write_backlight
 203               	write_backlight:
 204               	.LFB24:
 205               		.file 4 "main.c"
   1:main.c        **** /*
   2:main.c        **** *  SHPI.one Basic Firmware v1.2 BETA 
   3:main.c        **** *  
   4:main.c        **** * 
   5:main.c        **** *
   6:main.c        **** * Basic Firmware for ATmega32u4 slave,  no radio module support included
   7:main.c        **** *
   8:main.c        **** * Jul    15th, 2019  v 1.1b initial Version
   9:main.c        **** * October 4th, 2019  v1.2  Beta
  10:main.c        **** *    NEW: implemented CRC Check via CRC8  CCITT
  11:main.c        **** 
  12:main.c        **** * Aug 28th, 2020 v2.0 
  13:main.c        **** *
  14:main.c        **** *
  15:main.c        **** *
  16:main.c        **** *
  17:main.c        **** * Author: Lutz Harder
  18:main.c        **** * License: GNU GPL
  19:main.c        **** */
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** #define FW_VERSION  0x01
  23:main.c        **** #define I2C_ADDR 0x2A
  24:main.c        **** #define LCD_WRITE_DELAY 0.5
  25:main.c        **** #define LCD_WAIT 100
  26:main.c        **** #define ws2812_resettime  300 
  27:main.c        **** #define ws2812_port D   
  28:main.c        **** #define ws2812_pin  5  
  29:main.c        **** 
  30:main.c        **** #define SDA_LINE  (PIND & (1<<PD1))
  31:main.c        **** #define SCL_LINE  (PIND & (1<<PD0))
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** 
  35:main.c        **** #include <util/crc16.h>
  36:main.c        **** #include <avr/wdt.h>
  37:main.c        **** #include <avr/power.h>
  38:main.c        **** #include <avr/io.h>
  39:main.c        **** #include <stdlib.h>
  40:main.c        **** #include <util/delay.h>
  41:main.c        **** #include <avr/interrupt.h>
  42:main.c        **** #include <stdint.h>
  43:main.c        **** #include <util/twi.h>
  44:main.c        **** #include "light_ws2812.c"
  45:main.c        **** #include "light_ws2812.h"
  46:main.c        **** 
  47:main.c        **** struct cRGB led[255];
  48:main.c        **** uint8_t displaychange = 0, jumptobootloader = 0, watchdog = 0x00, display = 0xFF, led_position = 0,
  49:main.c        **** uint16_t a0,a1,a2,a3,a4,a5,a7,a7avg,a7max,a7min,vcc,temp,rpm,fanspin,isrtimer,i2cbuffer = 0, watchi
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** uint16_t data_lcd_shpi397[] = {
  54:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x101, 0x008, 0x110,
  55:main.c        ****     0x021, 0x109, 0x030, 0x102, 0x031, 0x100, 0x040, 0x110,
  56:main.c        ****     0x041, 0x155, 0x042, 0x102, 0x043, 0x109, 0x044, 0x107,
  57:main.c        ****     0x050, 0x178, 0x051, 0x178, 0x052, 0x100, 0x053, 0x16d,
  58:main.c        ****     0x060, 0x107, 0x061, 0x100, 0x062, 0x108, 0x063, 0x100,
  59:main.c        ****     0x0a0, 0x100, 0x0a1, 0x107, 0x0a2, 0x10c, 0x0a3, 0x10b,
  60:main.c        ****     0x0a4, 0x103, 0x0a5, 0x107, 0x0a6, 0x106, 0x0a7, 0x104,
  61:main.c        ****     0x0a8, 0x108, 0x0a9, 0x10c, 0x0aa, 0x113, 0x0ab, 0x106,
  62:main.c        ****     0x0ac, 0x10d, 0x0ad, 0x119, 0x0ae, 0x110, 0x0af, 0x100,
  63:main.c        ****     0x0c0, 0x100, 0x0c1, 0x107, 0x0c2, 0x10c, 0x0c3, 0x10b,
  64:main.c        ****     0x0c4, 0x103, 0x0c5, 0x107, 0x0c6, 0x107, 0x0c7, 0x104,
  65:main.c        ****     0x0c8, 0x108, 0x0c9, 0x10c, 0x0ca, 0x113, 0x0cb, 0x106,
  66:main.c        ****     0x0cc, 0x10d, 0x0cd, 0x118, 0x0ce, 0x110, 0x0cf, 0x100,
  67:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x106, 0x000, 0x120,
  68:main.c        ****     0x001, 0x10a, 0x002, 0x100, 0x003, 0x100, 0x004, 0x101,
  69:main.c        ****     0x005, 0x101, 0x006, 0x198, 0x007, 0x106, 0x008, 0x101,
  70:main.c        ****     0x009, 0x180, 0x00a, 0x100, 0x00b, 0x100, 0x00c, 0x101,
  71:main.c        ****     0x00d, 0x101, 0x00e, 0x100, 0x00f, 0x100, 0x010, 0x1f0,
  72:main.c        ****     0x011, 0x1f4, 0x012, 0x101, 0x013, 0x100, 0x014, 0x100,
  73:main.c        ****     0x015, 0x1c0, 0x016, 0x108, 0x017, 0x100, 0x018, 0x100,
  74:main.c        ****     0x019, 0x100, 0x01a, 0x100, 0x01b, 0x100, 0x01c, 0x100,
  75:main.c        ****     0x01d, 0x100, 0x020, 0x101, 0x021, 0x123, 0x022, 0x145,
  76:main.c        ****     0x023, 0x167, 0x024, 0x101, 0x025, 0x123, 0x026, 0x145,
  77:main.c        ****     0x027, 0x167, 0x030, 0x111, 0x031, 0x111, 0x032, 0x100,
  78:main.c        ****     0x033, 0x1ee, 0x034, 0x1ff, 0x035, 0x1bb, 0x036, 0x1aa,
  79:main.c        ****     0x037, 0x1dd, 0x038, 0x1cc, 0x039, 0x166, 0x03a, 0x177,
  80:main.c        ****     0x03b, 0x122, 0x03c, 0x122, 0x03d, 0x122, 0x03e, 0x122,
  81:main.c        ****     0x03f, 0x122, 0x040, 0x122, 0x052, 0x110, 0x053, 0x110,
  82:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x107, 0x018, 0x11d,
  83:main.c        ****     0x017, 0x122, 0x002, 0x177, 0x026, 0x1b2, 0x0e1, 0x179,
  84:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x100, 0x03a, 0x160,
  85:main.c        ****     0x035, 0x100, 0x011, 0x100,    0xffff, 0x029, 0x013, 0x100,    0xffff};
  86:main.c        **** 
  87:main.c        **** 
  88:main.c        **** void write_backlight(uint8_t data) { // set single wire brightness  AL3050 
 206               		.loc 4 88 0
 207               		.cfi_startproc
 208               	.LVL19:
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213               		.loc 4 88 0
 214 0090 27E0      		ldi r18,lo8(7)
 215 0092 30E0      		ldi r19,0
  89:main.c        ****   uint8_t count = 8;
  90:main.c        ****   do {
  91:main.c        ****     PORTD &= ~_BV(PD4);
  92:main.c        ****     _delay_us(50);
  93:main.c        ****     if (!(data & (1 << (count - 1)))) {
 216               		.loc 4 93 0
 217 0094 90E0      		ldi r25,0
 218               	.LVL20:
 219               	.L13:
  91:main.c        ****     _delay_us(50);
 220               		.loc 4 91 0
 221 0096 5C98      		cbi 0xb,4
 222               	.LVL21:
 223               	.LBB49:
 224               	.LBB50:
 225               		.loc 3 276 0
 226 0098 E7EC      		ldi r30,lo8(199)
 227 009a F0E0      		ldi r31,hi8(199)
 228 009c 3197      	1:	sbiw r30,1
 229 009e 01F4      		brne 1b
 230 00a0 00C0      		rjmp .
 231 00a2 0000      		nop
 232               	.LVL22:
 233               	.LBE50:
 234               	.LBE49:
 235               		.loc 4 93 0
 236 00a4 AC01      		movw r20,r24
 237 00a6 022E      		mov r0,r18
 238 00a8 00C0      		rjmp 2f
 239               		1:
 240 00aa 5595      		asr r21
 241 00ac 4795      		ror r20
 242               		2:
 243 00ae 0A94      		dec r0
 244 00b0 02F4      		brpl 1b
 245 00b2 BA01      		movw r22,r20
 246 00b4 6170      		andi r22,1
 247 00b6 7727      		clr r23
 248 00b8 40FD      		sbrc r20,0
 249 00ba 00C0      		rjmp .L11
 250               	.LVL23:
 251               	.LBB51:
 252               	.LBB52:
 253               		.loc 3 276 0
 254 00bc E7EC      		ldi r30,lo8(199)
 255 00be F0E0      		ldi r31,hi8(199)
 256 00c0 3197      	1:	sbiw r30,1
 257 00c2 01F4      		brne 1b
 258 00c4 00C0      		rjmp .
 259 00c6 0000      		nop
 260               	.LVL24:
 261               	.L11:
 262               	.LBE52:
 263               	.LBE51:
  94:main.c        ****       _delay_us(50);
  95:main.c        ****     }
  96:main.c        ****     PORTD |= _BV(PD4);
 264               		.loc 4 96 0
 265 00c8 5C9A      		sbi 0xb,4
 266               	.LVL25:
 267               	.LBB53:
 268               	.LBB54:
 269               		.loc 3 276 0
 270 00ca E7EC      		ldi r30,lo8(199)
 271 00cc F0E0      		ldi r31,hi8(199)
 272 00ce 3197      	1:	sbiw r30,1
 273 00d0 01F4      		brne 1b
 274 00d2 00C0      		rjmp .
 275 00d4 0000      		nop
 276               	.LVL26:
 277               	.LBE54:
 278               	.LBE53:
  97:main.c        ****     _delay_us(50);
  98:main.c        ****     if ((data & (1 << (count - 1))) != 0) {
 279               		.loc 4 98 0
 280 00d6 672B      		or r22,r23
 281 00d8 01F0      		breq .L12
 282               	.LVL27:
 283               	.LBB55:
 284               	.LBB56:
 285               		.loc 3 276 0
 286 00da E7EC      		ldi r30,lo8(199)
 287 00dc F0E0      		ldi r31,hi8(199)
 288 00de 3197      	1:	sbiw r30,1
 289 00e0 01F4      		brne 1b
 290 00e2 00C0      		rjmp .
 291 00e4 0000      		nop
 292               	.LVL28:
 293               	.L12:
 294               	.LVL29:
 295               	.LBE56:
 296               	.LBE55:
 297 00e6 2150      		subi r18,1
 298 00e8 3109      		sbc r19,__zero_reg__
 299 00ea 00F4      		brcc .L13
  99:main.c        ****       _delay_us(50);
 100:main.c        ****     }
 101:main.c        ****     count--;
 102:main.c        ****   } while (count);
 103:main.c        **** 
 104:main.c        ****   PORTD &= ~_BV(PD4);
 300               		.loc 4 104 0
 301 00ec 5C98      		cbi 0xb,4
 302               	.LVL30:
 303               	.LBB57:
 304               	.LBB58:
 305               		.loc 3 276 0
 306 00ee 87EC      		ldi r24,lo8(199)
 307 00f0 90E0      		ldi r25,hi8(199)
 308 00f2 0197      	1:	sbiw r24,1
 309 00f4 01F4      		brne 1b
 310               	.LVL31:
 311 00f6 00C0      		rjmp .
 312 00f8 0000      		nop
 313               	.LVL32:
 314               	.LBE58:
 315               	.LBE57:
 105:main.c        ****   _delay_us(50);
 106:main.c        ****   PORTD |= _BV(PD4);
 316               		.loc 4 106 0
 317 00fa 5C9A      		sbi 0xb,4
 318               	.LVL33:
 319               	.LBB59:
 320               	.LBB60:
 321               		.loc 3 276 0
 322 00fc E7EC      		ldi r30,lo8(199)
 323 00fe F0E0      		ldi r31,hi8(199)
 324 0100 3197      	1:	sbiw r30,1
 325 0102 01F4      		brne 1b
 326 0104 00C0      		rjmp .
 327 0106 0000      		nop
 328               	.LVL34:
 329 0108 0895      		ret
 330               	.LBE60:
 331               	.LBE59:
 332               		.cfi_endproc
 333               	.LFE24:
 335               	.global	init_backlight
 337               	init_backlight:
 338               	.LFB25:
 107:main.c        ****   _delay_us(50);
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** void init_backlight(void) { // init AL3050 single wire dimming
 339               		.loc 4 110 0
 340               		.cfi_startproc
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
 111:main.c        ****   PORTD &= ~_BV(PD4);
 345               		.loc 4 111 0
 346 010a 5C98      		cbi 0xb,4
 347               	.LVL35:
 348               	.LBB61:
 349               	.LBB62:
 350               		.loc 3 276 0
 351 010c 8FED      		ldi r24,lo8(11999)
 352 010e 9EE2      		ldi r25,hi8(11999)
 353 0110 0197      	1:	sbiw r24,1
 354 0112 01F4      		brne 1b
 355 0114 00C0      		rjmp .
 356 0116 0000      		nop
 357               	.LVL36:
 358               	.LBE62:
 359               	.LBE61:
 112:main.c        ****   _delay_us(3000);
 113:main.c        ****   PORTD |= _BV(PD4);
 360               		.loc 4 113 0
 361 0118 5C9A      		sbi 0xb,4
 362               	.LVL37:
 363               	.LBB63:
 364               	.LBB64:
 365               		.loc 3 276 0
 366 011a 8FED      		ldi r24,lo8(479)
 367 011c 91E0      		ldi r25,hi8(479)
 368 011e 0197      	1:	sbiw r24,1
 369 0120 01F4      		brne 1b
 370 0122 00C0      		rjmp .
 371 0124 0000      		nop
 372               	.LVL38:
 373               	.LBE64:
 374               	.LBE63:
 114:main.c        ****   _delay_us(120);
 115:main.c        ****   PORTD &= ~_BV(PD4);
 375               		.loc 4 115 0
 376 0126 5C98      		cbi 0xb,4
 377               	.LVL39:
 378               	.LBB65:
 379               	.LBB66:
 380               		.loc 3 276 0
 381 0128 8FEC      		ldi r24,lo8(1999)
 382 012a 97E0      		ldi r25,hi8(1999)
 383 012c 0197      	1:	sbiw r24,1
 384 012e 01F4      		brne 1b
 385 0130 00C0      		rjmp .
 386 0132 0000      		nop
 387               	.LVL40:
 388               	.LBE66:
 389               	.LBE65:
 116:main.c        ****   _delay_us(500);
 117:main.c        ****   PORTD |= _BV(PD4);
 390               		.loc 4 117 0
 391 0134 5C9A      		sbi 0xb,4
 392               	.LVL41:
 393               	.LBB67:
 394               	.LBB68:
 395               		.loc 3 276 0
 396 0136 9AE1      		ldi r25,lo8(26)
 397 0138 9A95      	1:	dec r25
 398 013a 01F4      		brne 1b
 399 013c 00C0      		rjmp .
 400               	.LVL42:
 401               	.LBE68:
 402               	.LBE67:
 118:main.c        ****   _delay_us(5);
 119:main.c        ****   bllevel = 31;
 403               		.loc 4 119 0
 404 013e 8FE1      		ldi r24,lo8(31)
 405 0140 8093 0000 		sts bllevel,r24
 120:main.c        ****   newbllevel = 31;
 406               		.loc 4 120 0
 407 0144 8093 0000 		sts newbllevel,r24
 408 0148 0895      		ret
 409               		.cfi_endproc
 410               	.LFE25:
 412               	.global	write_lcd
 414               	write_lcd:
 415               	.LFB26:
 121:main.c        **** }
 122:main.c        **** 
 123:main.c        **** void write_lcd(uint16_t data, uint8_t count) { //  write routine for LCD setup
 416               		.loc 4 123 0
 417               		.cfi_startproc
 418               	.LVL43:
 419               	/* prologue: function */
 420               	/* frame size = 0 */
 421               	/* stack size = 0 */
 422               	.L__stack_usage = 0
 423 014a AC01      		movw r20,r24
 124:main.c        ****   PORTD &= ~_BV(PD4);
 424               		.loc 4 124 0
 425 014c 5C98      		cbi 0xb,4
 125:main.c        **** 
 126:main.c        ****   do {
 127:main.c        ****     PORTB &= ~_BV(PB2);
 128:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 426               		.loc 4 128 0
 427 014e E1E0      		ldi r30,lo8(1)
 428 0150 F0E0      		ldi r31,0
 429               	.LVL44:
 430               	.L21:
 127:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 431               		.loc 4 127 0
 432 0152 2A98      		cbi 0x5,2
 433               		.loc 4 128 0
 434 0154 95B1      		in r25,0x5
 435 0156 8FEF      		ldi r24,lo8(-1)
 436 0158 860F      		add r24,r22
 437 015a 9F01      		movw r18,r30
 438 015c 00C0      		rjmp 2f
 439               		1:
 440 015e 220F      		lsl r18
 441 0160 331F      		rol r19
 442               		2:
 443 0162 8A95      		dec r24
 444 0164 02F4      		brpl 1b
 445 0166 2423      		and r18,r20
 446 0168 3523      		and r19,r21
 447 016a 232B      		or r18,r19
 448 016c 01F4      		brne .L22
 449 016e 20E0      		ldi r18,0
 450 0170 00C0      		rjmp .L20
 451               	.L22:
 452 0172 24E0      		ldi r18,lo8(4)
 453               	.L20:
 454               		.loc 4 128 0 is_stmt 0 discriminator 4
 455 0174 922B      		or r25,r18
 456 0176 95B9      		out 0x5,r25
 129:main.c        ****     PORTB &= ~_BV(PB1);
 457               		.loc 4 129 0 is_stmt 1 discriminator 4
 458 0178 2998      		cbi 0x5,1
 459               	.LVL45:
 460               	.LBB69:
 461               	.LBB70:
 462               		.loc 3 276 0 discriminator 4
 463 017a 82E0      		ldi r24,lo8(2)
 464 017c 8A95      	1:	dec r24
 465 017e 01F4      		brne 1b
 466 0180 00C0      		rjmp .
 467               	.LVL46:
 468               	.LBE70:
 469               	.LBE69:
 130:main.c        ****     _delay_us(LCD_WRITE_DELAY);
 131:main.c        ****     PORTB |= _BV(PB1);
 470               		.loc 4 131 0 discriminator 4
 471 0182 299A      		sbi 0x5,1
 472               	.LVL47:
 473               	.LBB71:
 474               	.LBB72:
 475               		.loc 3 276 0 discriminator 4
 476 0184 82E0      		ldi r24,lo8(2)
 477 0186 8A95      	1:	dec r24
 478 0188 01F4      		brne 1b
 479 018a 00C0      		rjmp .
 480               	.LVL48:
 481               	.LBE72:
 482               	.LBE71:
 132:main.c        ****     _delay_us(LCD_WRITE_DELAY);
 133:main.c        ****     count--;
 483               		.loc 4 133 0 discriminator 4
 484 018c 6150      		subi r22,lo8(-(-1))
 485               	.LVL49:
 134:main.c        ****   } while (count);
 486               		.loc 4 134 0 discriminator 4
 487 018e 01F4      		brne .L21
 135:main.c        ****   PORTB &= ~_BV(PB2);
 488               		.loc 4 135 0
 489 0190 2A98      		cbi 0x5,2
 136:main.c        ****   PORTD |= _BV(PD4);
 490               		.loc 4 136 0
 491 0192 5C9A      		sbi 0xb,4
 492               	.LVL50:
 493               	.LBB73:
 494               	.LBB74:
 495               		.loc 3 276 0
 496 0194 82E0      		ldi r24,lo8(2)
 497 0196 8A95      	1:	dec r24
 498 0198 01F4      		brne 1b
 499 019a 00C0      		rjmp .
 500               	.LVL51:
 501 019c 0895      		ret
 502               	.LBE74:
 503               	.LBE73:
 504               		.cfi_endproc
 505               	.LFE26:
 507               	.global	setup_lcd
 509               	setup_lcd:
 510               	.LFB27:
 137:main.c        ****   _delay_us(LCD_WRITE_DELAY);
 138:main.c        ****   
 139:main.c        **** }
 140:main.c        **** 
 141:main.c        **** void setup_lcd(void){
 511               		.loc 4 141 0
 512               		.cfi_startproc
 513 019e CF93      		push r28
 514               	.LCFI0:
 515               		.cfi_def_cfa_offset 3
 516               		.cfi_offset 28, -2
 517 01a0 DF93      		push r29
 518               	.LCFI1:
 519               		.cfi_def_cfa_offset 4
 520               		.cfi_offset 29, -3
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 2 */
 524               	.L__stack_usage = 2
 142:main.c        **** 
 143:main.c        ****    PORTD |= _BV(PD4);
 525               		.loc 4 143 0
 526 01a2 5C9A      		sbi 0xb,4
 527               	.LVL52:
 528               	.LBB75:
 529               	.LBB76:
 530               		.loc 3 276 0
 531 01a4 2AE1      		ldi r18,lo8(26)
 532 01a6 2A95      	1:	dec r18
 533 01a8 01F4      		brne 1b
 534 01aa 00C0      		rjmp .
 535               	.LVL53:
 536 01ac C0E0      		ldi r28,lo8(data_lcd_shpi397)
 537 01ae D0E0      		ldi r29,hi8(data_lcd_shpi397)
 538               	.LVL54:
 539               	.L25:
 540               	.LBE76:
 541               	.LBE75:
 542               	.LBB77:
 144:main.c        ****     _delay_us(5);
 145:main.c        **** 
 146:main.c        **** 
 147:main.c        ****    for(int x=0; x < sizeof(data_lcd_shpi397)/sizeof(uint16_t); x++ )
 543               		.loc 4 147 0 discriminator 1
 544 01b0 80E0      		ldi r24,hi8(data_lcd_shpi397+514)
 545 01b2 C030      		cpi r28,lo8(data_lcd_shpi397+514)
 546 01b4 D807      		cpc r29,r24
 547 01b6 01F0      		breq .L29
 148:main.c        ****    {
 149:main.c        **** 
 150:main.c        ****    if (data_lcd_shpi397[x] == 0xffff) 
 548               		.loc 4 150 0
 549 01b8 8991      		ld r24,Y+
 550 01ba 9991      		ld r25,Y+
 551 01bc 8F3F      		cpi r24,-1
 552 01be 2FEF      		ldi r18,-1
 553 01c0 9207      		cpc r25,r18
 554 01c2 01F4      		brne .L26
 555               	.LVL55:
 556               	.LBB78:
 557               	.LBB79:
 187:/usr/lib/avr/include/util/delay.h **** 
 558               		.loc 3 187 0
 559 01c4 8FEF      		ldi r24,lo8(319999)
 560 01c6 91EE      		ldi r25,hi8(319999)
 561 01c8 24E0      		ldi r18,hlo8(319999)
 562 01ca 8150      	1:	subi r24,1
 563 01cc 9040      		sbci r25,0
 564 01ce 2040      		sbci r18,0
 565 01d0 01F4      		brne 1b
 566 01d2 00C0      		rjmp .
 567 01d4 0000      		nop
 568 01d6 00C0      		rjmp .L25
 569               	.LVL56:
 570               	.L26:
 571               	.LBE79:
 572               	.LBE78:
 151:main.c        ****                {_delay_ms(LCD_WAIT);}
 152:main.c        ****    else { write_lcd(data_lcd_shpi397[x],9);}
 573               		.loc 4 152 0
 574 01d8 69E0      		ldi r22,lo8(9)
 575 01da 0E94 0000 		call write_lcd
 576               	.LVL57:
 577 01de 00C0      		rjmp .L25
 578               	.L29:
 579               	/* epilogue start */
 580               	.LBE77:
 153:main.c        **** 
 154:main.c        ****    }
 155:main.c        ****    }
 581               		.loc 4 155 0
 582 01e0 DF91      		pop r29
 583 01e2 CF91      		pop r28
 584 01e4 0895      		ret
 585               		.cfi_endproc
 586               	.LFE27:
 588               	.global	read_analog
 590               	read_analog:
 591               	.LFB28:
 156:main.c        **** 
 157:main.c        **** uint16_t read_analog(uint8_t channel) {
 592               		.loc 4 157 0
 593               		.cfi_startproc
 594               	.LVL58:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 158:main.c        ****   uint8_t low, high;
 159:main.c        ****   ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 599               		.loc 4 159 0
 600 01e6 9091 7A00 		lds r25,122
 601 01ea 9760      		ori r25,lo8(7)
 602 01ec 9093 7A00 		sts 122,r25
 160:main.c        ****   ADCSRB = 0x40;
 603               		.loc 4 160 0
 604 01f0 90E4      		ldi r25,lo8(64)
 605 01f2 9093 7B00 		sts 123,r25
 161:main.c        ****   ADMUX = ((0 << REFS1) | (1 << REFS0) | (0 << ADLAR));
 606               		.loc 4 161 0
 607 01f6 9093 7C00 		sts 124,r25
 162:main.c        **** 
 163:main.c        ****   if (channel >= 8) //
 608               		.loc 4 163 0
 609 01fa 8830      		cpi r24,lo8(8)
 610 01fc 00F0      		brlo .L31
 164:main.c        ****   {
 165:main.c        ****     channel -= 0x08; //ch - 8           
 611               		.loc 4 165 0
 612 01fe 8850      		subi r24,lo8(-(-8))
 613               	.LVL59:
 166:main.c        ****     ADCSRB |= (1 << MUX5); // set MUX5 on ADCSRB to read upper bit ADC8-ADC13
 614               		.loc 4 166 0
 615 0200 9091 7B00 		lds r25,123
 616 0204 9062      		ori r25,lo8(32)
 617 0206 00C0      		rjmp .L35
 618               	.L31:
 167:main.c        ****   } else {
 168:main.c        ****     ADCSRB &= ~(1 << MUX5); // clear MUX 5 
 619               		.loc 4 168 0
 620 0208 9091 7B00 		lds r25,123
 621 020c 9F7D      		andi r25,lo8(-33)
 622               	.L35:
 623 020e 9093 7B00 		sts 123,r25
 624               	.LVL60:
 169:main.c        ****   }
 170:main.c        ****   channel &= 0x07;
 171:main.c        ****   ADMUX |= channel; // selecting channel
 625               		.loc 4 171 0
 626 0212 9091 7C00 		lds r25,124
 627 0216 8770      		andi r24,lo8(7)
 628               	.LVL61:
 629 0218 892B      		or r24,r25
 630               	.LVL62:
 631 021a 8093 7C00 		sts 124,r24
 172:main.c        **** 
 173:main.c        ****   ADCSRA |= _BV(ADEN);
 632               		.loc 4 173 0
 633 021e 8091 7A00 		lds r24,122
 634 0222 8068      		ori r24,lo8(-128)
 635 0224 8093 7A00 		sts 122,r24
 636               	.LVL63:
 637               	.LBB80:
 638               	.LBB81:
 187:/usr/lib/avr/include/util/delay.h **** 
 639               		.loc 3 187 0
 640 0228 8FE3      		ldi r24,lo8(7999)
 641 022a 9FE1      		ldi r25,hi8(7999)
 642 022c 0197      	1:	sbiw r24,1
 643 022e 01F4      		brne 1b
 644 0230 00C0      		rjmp .
 645 0232 0000      		nop
 646               	.LVL64:
 647               	.LBE81:
 648               	.LBE80:
 174:main.c        ****   _delay_ms(2);
 175:main.c        ****   ADCSRA |= (1 << ADSC);
 649               		.loc 4 175 0
 650 0234 8091 7A00 		lds r24,122
 651 0238 8064      		ori r24,lo8(64)
 652 023a 8093 7A00 		sts 122,r24
 653               	.L33:
 176:main.c        **** 
 177:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring 
 654               		.loc 4 177 0 discriminator 1
 655 023e 8091 7A00 		lds r24,122
 656 0242 86FD      		sbrc r24,6
 657 0244 00C0      		rjmp .L33
 178:main.c        ****   low = ADCL;
 658               		.loc 4 178 0
 659 0246 8091 7800 		lds r24,120
 660               	.LVL65:
 179:main.c        ****   high = ADCH;
 661               		.loc 4 179 0
 662 024a 2091 7900 		lds r18,121
 663               	.LVL66:
 180:main.c        ****   return (high << 8) | low;
 664               		.loc 4 180 0
 665 024e 90E0      		ldi r25,0
 181:main.c        **** 
 182:main.c        **** }
 666               		.loc 4 182 0
 667 0250 922B      		or r25,r18
 668 0252 0895      		ret
 669               		.cfi_endproc
 670               	.LFE28:
 672               	.global	readVcc
 674               	readVcc:
 675               	.LFB29:
 183:main.c        **** 
 184:main.c        **** uint16_t readVcc(void) {
 676               		.loc 4 184 0
 677               		.cfi_startproc
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 0 */
 681               	.L__stack_usage = 0
 185:main.c        ****   ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
 682               		.loc 4 185 0
 683 0254 8EE5      		ldi r24,lo8(94)
 684 0256 8093 7C00 		sts 124,r24
 186:main.c        ****   ADCSRA |= _BV(ADEN);
 685               		.loc 4 186 0
 686 025a 8091 7A00 		lds r24,122
 687 025e 8068      		ori r24,lo8(-128)
 688 0260 8093 7A00 		sts 122,r24
 187:main.c        ****   ADCSRB &= ~_BV(MUX5);
 689               		.loc 4 187 0
 690 0264 8091 7B00 		lds r24,123
 691 0268 8F7D      		andi r24,lo8(-33)
 692 026a 8093 7B00 		sts 123,r24
 693               	.LVL67:
 694               	.LBB82:
 695               	.LBB83:
 187:/usr/lib/avr/include/util/delay.h **** 
 696               		.loc 3 187 0
 697 026e 8FE3      		ldi r24,lo8(7999)
 698 0270 9FE1      		ldi r25,hi8(7999)
 699 0272 0197      	1:	sbiw r24,1
 700 0274 01F4      		brne 1b
 701 0276 00C0      		rjmp .
 702 0278 0000      		nop
 703               	.LVL68:
 704               	.LBE83:
 705               	.LBE82:
 188:main.c        ****   _delay_ms(2);
 189:main.c        ****   ADCSRA |= 1 << ADSC;
 706               		.loc 4 189 0
 707 027a 8091 7A00 		lds r24,122
 708 027e 8064      		ori r24,lo8(64)
 709 0280 8093 7A00 		sts 122,r24
 710               	.L37:
 190:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring
 711               		.loc 4 190 0 discriminator 1
 712 0284 8091 7A00 		lds r24,122
 713 0288 86FD      		sbrc r24,6
 714 028a 00C0      		rjmp .L37
 191:main.c        ****   ADCSRA |= 1 << ADSC;
 715               		.loc 4 191 0
 716 028c 8091 7A00 		lds r24,122
 717 0290 8064      		ori r24,lo8(64)
 718 0292 8093 7A00 		sts 122,r24
 719               	.L38:
 192:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 720               		.loc 4 192 0 discriminator 1
 721 0296 8091 7A00 		lds r24,122
 722 029a 86FD      		sbrc r24,6
 723 029c 00C0      		rjmp .L38
 193:main.c        ****   return 1125300L / (ADCL | (ADCH<<8));
 724               		.loc 4 193 0
 725 029e 2091 7800 		lds r18,120
 726 02a2 8091 7900 		lds r24,121
 727 02a6 30E0      		ldi r19,0
 728 02a8 382B      		or r19,r24
 729 02aa 032E      		mov __tmp_reg__,r19
 730 02ac 000C      		lsl r0
 731 02ae 440B      		sbc r20,r20
 732 02b0 550B      		sbc r21,r21
 733 02b2 64EB      		ldi r22,lo8(-76)
 734 02b4 7BE2      		ldi r23,lo8(43)
 735 02b6 81E1      		ldi r24,lo8(17)
 736 02b8 90E0      		ldi r25,0
 737 02ba 0E94 0000 		call __divmodsi4
 194:main.c        **** }
 738               		.loc 4 194 0
 739 02be C901      		movw r24,r18
 740 02c0 0895      		ret
 741               		.cfi_endproc
 742               	.LFE29:
 744               	.global	GetTemp
 746               	GetTemp:
 747               	.LFB30:
 195:main.c        **** 
 196:main.c        **** uint16_t GetTemp(void) {
 748               		.loc 4 196 0
 749               		.cfi_startproc
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 197:main.c        **** 
 198:main.c        ****   ADMUX = _BV(REFS1) | _BV(REFS0) | 7; // Set internal V reference, temperature reading
 754               		.loc 4 198 0
 755 02c2 87EC      		ldi r24,lo8(-57)
 756 02c4 8093 7C00 		sts 124,r24
 199:main.c        ****   ADCSRB = 0x20; // ref  24.6
 757               		.loc 4 199 0
 758 02c8 80E2      		ldi r24,lo8(32)
 759 02ca 8093 7B00 		sts 123,r24
 200:main.c        ****   ADCSRA &= ~(_BV(ADATE) | _BV(ADIE)); // Clear auto trigger and interrupt enable
 760               		.loc 4 200 0
 761 02ce 8091 7A00 		lds r24,122
 762 02d2 877D      		andi r24,lo8(-41)
 763 02d4 8093 7A00 		sts 122,r24
 201:main.c        ****   ADCSRA |= _BV(ADEN); // enable the ADC
 764               		.loc 4 201 0
 765 02d8 8091 7A00 		lds r24,122
 766 02dc 8068      		ori r24,lo8(-128)
 767 02de 8093 7A00 		sts 122,r24
 768               	.LVL69:
 769               	.LBB84:
 770               	.LBB85:
 187:/usr/lib/avr/include/util/delay.h **** 
 771               		.loc 3 187 0
 772 02e2 8FE3      		ldi r24,lo8(7999)
 773 02e4 9FE1      		ldi r25,hi8(7999)
 774 02e6 0197      	1:	sbiw r24,1
 775 02e8 01F4      		brne 1b
 776 02ea 00C0      		rjmp .
 777 02ec 0000      		nop
 778               	.LVL70:
 779               	.LBE85:
 780               	.LBE84:
 202:main.c        ****   _delay_ms(2); // delay for voltages to become stable.
 203:main.c        **** 
 204:main.c        ****   ADCSRA |= _BV(ADSC); // measuring
 781               		.loc 4 204 0
 782 02ee 8091 7A00 		lds r24,122
 783 02f2 8064      		ori r24,lo8(64)
 784 02f4 8093 7A00 		sts 122,r24
 785               	.L42:
 205:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 786               		.loc 4 205 0 discriminator 1
 787 02f8 8091 7A00 		lds r24,122
 788 02fc 86FD      		sbrc r24,6
 789 02fe 00C0      		rjmp .L42
 206:main.c        **** 
 207:main.c        ****   ADCSRA |= _BV(ADSC);
 790               		.loc 4 207 0
 791 0300 8091 7A00 		lds r24,122
 792 0304 8064      		ori r24,lo8(64)
 793 0306 8093 7A00 		sts 122,r24
 794               	.L43:
 208:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 795               		.loc 4 208 0 discriminator 1
 796 030a 8091 7A00 		lds r24,122
 797 030e 86FD      		sbrc r24,6
 798 0310 00C0      		rjmp .L43
 209:main.c        **** 
 210:main.c        ****   return (ADCL | (ADCH << 8));
 799               		.loc 4 210 0
 800 0312 8091 7800 		lds r24,120
 801 0316 2091 7900 		lds r18,121
 802 031a 90E0      		ldi r25,0
 211:main.c        **** }
 803               		.loc 4 211 0
 804 031c 922B      		or r25,r18
 805 031e 0895      		ret
 806               		.cfi_endproc
 807               	.LFE30:
 809               	.global	freeRam
 811               	freeRam:
 812               	.LFB31:
 212:main.c        **** 
 213:main.c        **** uint16_t freeRam(void) {
 813               		.loc 4 213 0
 814               		.cfi_startproc
 815 0320 CF93      		push r28
 816               	.LCFI2:
 817               		.cfi_def_cfa_offset 3
 818               		.cfi_offset 28, -2
 819 0322 DF93      		push r29
 820               	.LCFI3:
 821               		.cfi_def_cfa_offset 4
 822               		.cfi_offset 29, -3
 823 0324 00D0      		rcall .
 824               	.LCFI4:
 825               		.cfi_def_cfa_offset 6
 826 0326 CDB7      		in r28,__SP_L__
 827 0328 DEB7      		in r29,__SP_H__
 828               	.LCFI5:
 829               		.cfi_def_cfa_register 28
 830               	/* prologue: function */
 831               	/* frame size = 2 */
 832               	/* stack size = 4 */
 833               	.L__stack_usage = 4
 214:main.c        ****   extern char __heap_start, * __brkval;
 215:main.c        ****   int v;
 216:main.c        ****   return (uint16_t) & v - (__brkval == 0 ? (int) & __heap_start : (int) __brkval);
 834               		.loc 4 216 0
 835 032a 2091 0000 		lds r18,__brkval
 836 032e 3091 0000 		lds r19,__brkval+1
 837 0332 2115      		cp r18,__zero_reg__
 838 0334 3105      		cpc r19,__zero_reg__
 839 0336 01F4      		brne .L47
 840 0338 20E0      		ldi r18,lo8(__heap_start)
 841 033a 30E0      		ldi r19,hi8(__heap_start)
 842               	.L47:
 217:main.c        **** }
 843               		.loc 4 217 0 discriminator 4
 844 033c CE01      		movw r24,r28
 845 033e 0196      		adiw r24,1
 846 0340 821B      		sub r24,r18
 847 0342 930B      		sbc r25,r19
 848               	/* epilogue start */
 849 0344 0F90      		pop __tmp_reg__
 850 0346 0F90      		pop __tmp_reg__
 851 0348 DF91      		pop r29
 852 034a CF91      		pop r28
 853 034c 0895      		ret
 854               		.cfi_endproc
 855               	.LFE31:
 857               	.global	I2C_init
 859               	I2C_init:
 860               	.LFB32:
 218:main.c        **** 
 219:main.c        **** void I2C_init(uint8_t address) // setup ATmega as I2C slave
 220:main.c        **** {
 861               		.loc 4 220 0
 862               		.cfi_startproc
 863               	.LVL71:
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866               	/* stack size = 0 */
 867               	.L__stack_usage = 0
 221:main.c        ****   cli();
 868               		.loc 4 221 0
 869               	/* #APP */
 870               	 ;  221 "main.c" 1
 871 034e F894      		cli
 872               	 ;  0 "" 2
 222:main.c        **** 
 223:main.c        ****   TWAR = (address << 1);
 873               		.loc 4 223 0
 874               	/* #NOAPP */
 875 0350 880F      		lsl r24
 876               	.LVL72:
 877 0352 8093 BA00 		sts 186,r24
 224:main.c        ****   TWCR = (1 << TWEN) | // TWI Interface enabled.
 878               		.loc 4 224 0
 879 0356 85EC      		ldi r24,lo8(-59)
 880 0358 8093 BC00 		sts 188,r24
 225:main.c        ****     (1 << TWIE) | (1 << TWINT) | // Enable TWI Interupt and clear the flag.
 226:main.c        ****     (1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // Prepare to ACK next time the Slave is addressed.
 227:main.c        ****     (0 << TWWC);
 228:main.c        **** 
 229:main.c        ****   buffer_address = 0xFF;
 881               		.loc 4 229 0
 882 035c 8FEF      		ldi r24,lo8(-1)
 883 035e 8093 0000 		sts buffer_address,r24
 884 0362 0895      		ret
 885               		.cfi_endproc
 886               	.LFE32:
 888               	.global	__vector_9
 890               	__vector_9:
 891               	.LFB33:
 230:main.c        **** 
 231:main.c        **** }
 232:main.c        **** 
 233:main.c        **** ISR(PCINT0_vect) {
 892               		.loc 4 233 0
 893               		.cfi_startproc
 894 0364 1F92      		push r1
 895               	.LCFI6:
 896               		.cfi_def_cfa_offset 3
 897               		.cfi_offset 1, -2
 898 0366 0F92      		push r0
 899               	.LCFI7:
 900               		.cfi_def_cfa_offset 4
 901               		.cfi_offset 0, -3
 902 0368 0FB6      		in r0,__SREG__
 903 036a 0F92      		push r0
 904 036c 1124      		clr __zero_reg__
 905 036e 8F93      		push r24
 906               	.LCFI8:
 907               		.cfi_def_cfa_offset 5
 908               		.cfi_offset 24, -4
 909 0370 9F93      		push r25
 910               	.LCFI9:
 911               		.cfi_def_cfa_offset 6
 912               		.cfi_offset 25, -5
 913               	/* prologue: Signal */
 914               	/* frame size = 0 */
 915               	/* stack size = 5 */
 916               	.L__stack_usage = 5
 234:main.c        ****   sei();
 917               		.loc 4 234 0
 918               	/* #APP */
 919               	 ;  234 "main.c" 1
 920 0372 7894      		sei
 921               	 ;  0 "" 2
 235:main.c        ****   if (bit_is_clear(PINB, PB4)) fanspin++;
 922               		.loc 4 235 0
 923               	/* #NOAPP */
 924 0374 1C99      		sbic 0x3,4
 925 0376 00C0      		rjmp .L50
 926               		.loc 4 235 0 is_stmt 0 discriminator 1
 927 0378 8091 0000 		lds r24,fanspin
 928 037c 9091 0000 		lds r25,fanspin+1
 929 0380 0196      		adiw r24,1
 930 0382 9093 0000 		sts fanspin+1,r25
 931 0386 8093 0000 		sts fanspin,r24
 932               	.L50:
 933               	/* epilogue start */
 236:main.c        **** } // counting VENT_RPM
 934               		.loc 4 236 0 is_stmt 1
 935 038a 9F91      		pop r25
 936 038c 8F91      		pop r24
 937 038e 0F90      		pop r0
 938 0390 0FBE      		out __SREG__,r0
 939 0392 0F90      		pop r0
 940 0394 1F90      		pop r1
 941 0396 1895      		reti
 942               		.cfi_endproc
 943               	.LFE33:
 945               	.global	__vector_23
 947               	__vector_23:
 948               	.LFB34:
 237:main.c        **** 
 238:main.c        **** ISR(TIMER0_OVF_vect) {
 949               		.loc 4 238 0
 950               		.cfi_startproc
 951 0398 1F92      		push r1
 952               	.LCFI10:
 953               		.cfi_def_cfa_offset 3
 954               		.cfi_offset 1, -2
 955 039a 0F92      		push r0
 956               	.LCFI11:
 957               		.cfi_def_cfa_offset 4
 958               		.cfi_offset 0, -3
 959 039c 0FB6      		in r0,__SREG__
 960 039e 0F92      		push r0
 961 03a0 1124      		clr __zero_reg__
 962 03a2 8F93      		push r24
 963               	.LCFI12:
 964               		.cfi_def_cfa_offset 5
 965               		.cfi_offset 24, -4
 966 03a4 9F93      		push r25
 967               	.LCFI13:
 968               		.cfi_def_cfa_offset 6
 969               		.cfi_offset 25, -5
 970               	/* prologue: Signal */
 971               	/* frame size = 0 */
 972               	/* stack size = 5 */
 973               	.L__stack_usage = 5
 239:main.c        ****   isrtimer++;
 974               		.loc 4 239 0
 975 03a6 8091 0000 		lds r24,isrtimer
 976 03aa 9091 0000 		lds r25,isrtimer+1
 977 03ae 0196      		adiw r24,1
 978 03b0 9093 0000 		sts isrtimer+1,r25
 979 03b4 8093 0000 		sts isrtimer,r24
 980               	/* epilogue start */
 240:main.c        **** } // reuse timer0 for counting VENT_RPM
 981               		.loc 4 240 0
 982 03b8 9F91      		pop r25
 983 03ba 8F91      		pop r24
 984 03bc 0F90      		pop r0
 985 03be 0FBE      		out __SREG__,r0
 986 03c0 0F90      		pop r0
 987 03c2 1F90      		pop r1
 988 03c4 1895      		reti
 989               		.cfi_endproc
 990               	.LFE34:
 992               	.global	__vector_36
 994               	__vector_36:
 995               	.LFB35:
 241:main.c        **** 
 242:main.c        **** ISR(TWI_vect) {
 996               		.loc 4 242 0
 997               		.cfi_startproc
 998 03c6 1F92      		push r1
 999               	.LCFI14:
 1000               		.cfi_def_cfa_offset 3
 1001               		.cfi_offset 1, -2
 1002 03c8 0F92      		push r0
 1003               	.LCFI15:
 1004               		.cfi_def_cfa_offset 4
 1005               		.cfi_offset 0, -3
 1006 03ca 0FB6      		in r0,__SREG__
 1007 03cc 0F92      		push r0
 1008 03ce 1124      		clr __zero_reg__
 1009 03d0 2F93      		push r18
 1010               	.LCFI16:
 1011               		.cfi_def_cfa_offset 5
 1012               		.cfi_offset 18, -4
 1013 03d2 3F93      		push r19
 1014               	.LCFI17:
 1015               		.cfi_def_cfa_offset 6
 1016               		.cfi_offset 19, -5
 1017 03d4 4F93      		push r20
 1018               	.LCFI18:
 1019               		.cfi_def_cfa_offset 7
 1020               		.cfi_offset 20, -6
 1021 03d6 5F93      		push r21
 1022               	.LCFI19:
 1023               		.cfi_def_cfa_offset 8
 1024               		.cfi_offset 21, -7
 1025 03d8 6F93      		push r22
 1026               	.LCFI20:
 1027               		.cfi_def_cfa_offset 9
 1028               		.cfi_offset 22, -8
 1029 03da 7F93      		push r23
 1030               	.LCFI21:
 1031               		.cfi_def_cfa_offset 10
 1032               		.cfi_offset 23, -9
 1033 03dc 8F93      		push r24
 1034               	.LCFI22:
 1035               		.cfi_def_cfa_offset 11
 1036               		.cfi_offset 24, -10
 1037 03de 9F93      		push r25
 1038               	.LCFI23:
 1039               		.cfi_def_cfa_offset 12
 1040               		.cfi_offset 25, -11
 1041 03e0 AF93      		push r26
 1042               	.LCFI24:
 1043               		.cfi_def_cfa_offset 13
 1044               		.cfi_offset 26, -12
 1045 03e2 BF93      		push r27
 1046               	.LCFI25:
 1047               		.cfi_def_cfa_offset 14
 1048               		.cfi_offset 27, -13
 1049 03e4 CF93      		push r28
 1050               	.LCFI26:
 1051               		.cfi_def_cfa_offset 15
 1052               		.cfi_offset 28, -14
 1053 03e6 EF93      		push r30
 1054               	.LCFI27:
 1055               		.cfi_def_cfa_offset 16
 1056               		.cfi_offset 30, -15
 1057 03e8 FF93      		push r31
 1058               	.LCFI28:
 1059               		.cfi_def_cfa_offset 17
 1060               		.cfi_offset 31, -16
 1061               	/* prologue: Signal */
 1062               	/* frame size = 0 */
 1063               	/* stack size = 16 */
 1064               	.L__stack_usage = 16
 243:main.c        **** 
 244:main.c        ****   switch (TW_STATUS) {
 1065               		.loc 4 244 0
 1066 03ea 8091 B900 		lds r24,185
 1067 03ee 887F      		andi r24,lo8(-8)
 1068 03f0 8038      		cpi r24,lo8(-128)
 1069 03f2 01F0      		breq .L55
 1070 03f4 00F4      		brsh .L56
 1071 03f6 8823      		tst r24
 1072 03f8 01F4      		brne .+2
 1073 03fa 00C0      		rjmp .L57
 1074 03fc 8036      		cpi r24,lo8(96)
 1075 03fe 01F0      		breq .+2
 1076 0400 00C0      		rjmp .L54
 245:main.c        **** 
 246:main.c        ****   case TW_SR_SLA_ACK:
 247:main.c        **** 
 248:main.c        ****     TWCR = (1 << TWIE) | (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
 1077               		.loc 4 248 0
 1078 0402 85EC      		ldi r24,lo8(-59)
 1079 0404 8093 BC00 		sts 188,r24
 249:main.c        ****     buffer_address = 0xFF; // set buffer pos undefined
 1080               		.loc 4 249 0
 1081 0408 8FEF      		ldi r24,lo8(-1)
 1082 040a 8093 0000 		sts buffer_address,r24
 250:main.c        ****     break;
 1083               		.loc 4 250 0
 1084 040e 00C0      		rjmp .L53
 1085               	.L56:
 244:main.c        **** 
 1086               		.loc 4 244 0
 1087 0410 883A      		cpi r24,lo8(-88)
 1088 0412 01F4      		brne .+2
 1089 0414 00C0      		rjmp .L59
 1090 0416 883B      		cpi r24,lo8(-72)
 1091 0418 01F4      		brne .+2
 1092 041a 00C0      		rjmp .L59
 1093 041c 00C0      		rjmp .L54
 1094               	.L55:
 251:main.c        ****    
 252:main.c        ****   case TW_SR_DATA_ACK: // received data from master
 253:main.c        ****     
 254:main.c        ****     if (buffer_address == 0xFF) {
 1095               		.loc 4 254 0
 1096 041e 8091 0000 		lds r24,buffer_address
 1097 0422 8F3F      		cpi r24,lo8(-1)
 1098 0424 01F0      		breq .+2
 1099 0426 00C0      		rjmp .L61
 255:main.c        **** 
 256:main.c        ****       commandbyte = TWDR;
 1100               		.loc 4 256 0
 1101 0428 6091 BB00 		lds r22,187
 1102 042c 6093 0000 		sts commandbyte,r22
 257:main.c        ****       if (crc_active)   crc = _crc8_ccitt_update(0, commandbyte);
 1103               		.loc 4 257 0
 1104 0430 8091 0000 		lds r24,crc_active
 1105 0434 8823      		tst r24
 1106 0436 01F0      		breq .L62
 1107               		.loc 4 257 0 is_stmt 0 discriminator 1
 1108 0438 80E0      		ldi r24,0
 1109 043a 0E94 0000 		call _crc8_ccitt_update
 1110               	.LVL73:
 1111 043e 8093 0000 		sts crc,r24
 1112               	.L62:
 258:main.c        ****       buffer_address = 0;
 1113               		.loc 4 258 0 is_stmt 1
 1114 0442 1092 0000 		sts buffer_address,__zero_reg__
 259:main.c        ****       i2cerror = 0;
 1115               		.loc 4 259 0
 1116 0446 1092 0000 		sts i2cerror,__zero_reg__
 260:main.c        **** 
 261:main.c        **** 
 262:main.c        ****       switch (commandbyte) {		 
 1117               		.loc 4 262 0
 1118 044a E091 0000 		lds r30,commandbyte
 1119 044e 8E2F      		mov r24,r30
 1120 0450 90E0      		ldi r25,0
 1121 0452 8831      		cpi r24,24
 1122 0454 9105      		cpc r25,__zero_reg__
 1123 0456 00F0      		brlo .+2
 1124 0458 00C0      		rjmp .L63
 1125 045a FC01      		movw r30,r24
 1126 045c E050      		subi r30,lo8(-(gs(.L65)))
 1127 045e F040      		sbci r31,hi8(-(gs(.L65)))
 1128 0460 0C94 0000 		jmp __tablejump2__
 1129               		.section	.progmem.gcc_sw_table,"a",@progbits
 1130               		.p2align	1
 1131               	.L65:
 1132 0000 0000      		.word gs(.L64)
 1133 0002 0000      		.word gs(.L66)
 1134 0004 0000      		.word gs(.L67)
 1135 0006 0000      		.word gs(.L68)
 1136 0008 0000      		.word gs(.L69)
 1137 000a 0000      		.word gs(.L70)
 1138 000c 0000      		.word gs(.L71)
 1139 000e 0000      		.word gs(.L63)
 1140 0010 0000      		.word gs(.L72)
 1141 0012 0000      		.word gs(.L73)
 1142 0014 0000      		.word gs(.L74)
 1143 0016 0000      		.word gs(.L75)
 1144 0018 0000      		.word gs(.L63)
 1145 001a 0000      		.word gs(.L63)
 1146 001c 0000      		.word gs(.L63)
 1147 001e 0000      		.word gs(.L63)
 1148 0020 0000      		.word gs(.L63)
 1149 0022 0000      		.word gs(.L63)
 1150 0024 0000      		.word gs(.L63)
 1151 0026 0000      		.word gs(.L63)
 1152 0028 0000      		.word gs(.L63)
 1153 002a 0000      		.word gs(.L63)
 1154 002c 0000      		.word gs(.L63)
 1155 002e 0000      		.word gs(.L76)
 1156               		.text
 1157               	.L64:
 263:main.c        **** 
 264:main.c        **** 		  case 0x00: i2cbuffer = a0; break;
 1158               		.loc 4 264 0
 1159 0464 8091 0000 		lds r24,a0
 1160 0468 9091 0000 		lds r25,a0+1
 1161 046c 00C0      		rjmp .L268
 1162               	.L66:
 265:main.c        **** 		  case 0x01: i2cbuffer = a1; break;
 1163               		.loc 4 265 0
 1164 046e 8091 0000 		lds r24,a1
 1165 0472 9091 0000 		lds r25,a1+1
 1166 0476 00C0      		rjmp .L268
 1167               	.L67:
 266:main.c        **** 		  case 0x02: i2cbuffer = a2; break;
 1168               		.loc 4 266 0
 1169 0478 8091 0000 		lds r24,a2
 1170 047c 9091 0000 		lds r25,a2+1
 1171 0480 00C0      		rjmp .L268
 1172               	.L68:
 267:main.c        **** 		  case 0x03: i2cbuffer = a3; break;
 1173               		.loc 4 267 0
 1174 0482 8091 0000 		lds r24,a3
 1175 0486 9091 0000 		lds r25,a3+1
 1176 048a 00C0      		rjmp .L268
 1177               	.L69:
 268:main.c        **** 		  case 0x04: i2cbuffer = a4; break;
 1178               		.loc 4 268 0
 1179 048c 8091 0000 		lds r24,a4
 1180 0490 9091 0000 		lds r25,a4+1
 1181 0494 00C0      		rjmp .L268
 1182               	.L70:
 269:main.c        **** 		  case 0x05: i2cbuffer = a5; break;
 1183               		.loc 4 269 0
 1184 0496 8091 0000 		lds r24,a5
 1185 049a 9091 0000 		lds r25,a5+1
 1186 049e 00C0      		rjmp .L268
 1187               	.L71:
 270:main.c        **** 		  case 0x06: i2cbuffer = a7; break;
 1188               		.loc 4 270 0
 1189 04a0 8091 0000 		lds r24,a7
 1190 04a4 9091 0000 		lds r25,a7+1
 1191 04a8 00C0      		rjmp .L268
 1192               	.L72:
 271:main.c        **** 		  case 0x08: i2cbuffer = rpm;break;
 1193               		.loc 4 271 0
 1194 04aa 8091 0000 		lds r24,rpm
 1195 04ae 9091 0000 		lds r25,rpm+1
 1196 04b2 00C0      		rjmp .L268
 1197               	.L73:
 272:main.c        **** 		  case 0x09: i2cbuffer = vcc; break;
 1198               		.loc 4 272 0
 1199 04b4 8091 0000 		lds r24,vcc
 1200 04b8 9091 0000 		lds r25,vcc+1
 1201 04bc 00C0      		rjmp .L268
 1202               	.L74:
 273:main.c        **** 		  case 0x0A: i2cbuffer = temp;break;
 1203               		.loc 4 273 0
 1204 04be 8091 0000 		lds r24,temp
 1205 04c2 9091 0000 		lds r25,temp+1
 1206 04c6 00C0      		rjmp .L268
 1207               	.L75:
 274:main.c        **** 		  case 0x0B: i2cbuffer = freeRam(); break;
 1208               		.loc 4 274 0
 1209 04c8 0E94 0000 		call freeRam
 1210               	.LVL74:
 1211 04cc 00C0      		rjmp .L268
 1212               	.L76:
 275:main.c        **** 		  case 0x17: i2cbuffer = a7avg; break;
 1213               		.loc 4 275 0
 1214 04ce 8091 0000 		lds r24,a7avg
 1215 04d2 9091 0000 		lds r25,a7avg+1
 1216               	.L268:
 1217 04d6 9093 0000 		sts i2cbuffer+1,r25
 1218 04da 8093 0000 		sts i2cbuffer,r24
 1219 04de 00C0      		rjmp .L63
 1220               	.L61:
 276:main.c        **** 
 277:main.c        **** 
 278:main.c        **** 	    }
 279:main.c        ****       } 
 280:main.c        ****       else { 
 281:main.c        **** 
 282:main.c        ****       if (buffer_address == 0) {
 1221               		.loc 4 282 0
 1222 04e0 8111      		cpse r24,__zero_reg__
 1223 04e2 00C0      		rjmp .L77
 283:main.c        **** 					      twdrbuffer = TWDR;
 1224               		.loc 4 283 0
 1225 04e4 8091 BB00 		lds r24,187
 1226 04e8 8093 0000 		sts twdrbuffer,r24
 284:main.c        ****       					      if (commandbyte == 0xFE) crc_active = twdrbuffer;
 1227               		.loc 4 284 0
 1228 04ec 9091 0000 		lds r25,commandbyte
 1229 04f0 9E3F      		cpi r25,lo8(-2)
 1230 04f2 01F4      		brne .L78
 1231               		.loc 4 284 0 is_stmt 0 discriminator 1
 1232 04f4 8093 0000 		sts crc_active,r24
 1233               	.L78:
 285:main.c        ****        					      crc = _crc8_ccitt_update(crc,TWDR);
 1234               		.loc 4 285 0 is_stmt 1
 1235 04f8 6091 BB00 		lds r22,187
 1236 04fc 8091 0000 		lds r24,crc
 1237 0500 0E94 0000 		call _crc8_ccitt_update
 1238               	.LVL75:
 1239 0504 8093 0000 		sts crc,r24
 1240               	.L77:
 286:main.c        **** 
 287:main.c        ****       }
 288:main.c        ****  
 289:main.c        **** 
 290:main.c        ****       if ((crc_active && (buffer_address == 1) && (TWDR == crc)) ||   (!crc_active && buffer_addres
 1241               		.loc 4 290 0
 1242 0508 9091 0000 		lds r25,crc_active
 1243 050c 8091 0000 		lds r24,buffer_address
 1244 0510 9923      		tst r25
 1245 0512 01F0      		breq .L79
 1246               		.loc 4 290 0 is_stmt 0 discriminator 1
 1247 0514 8130      		cpi r24,lo8(1)
 1248 0516 01F0      		breq .+2
 1249 0518 00C0      		rjmp .L80
 1250               		.loc 4 290 0 discriminator 3
 1251 051a 9091 BB00 		lds r25,187
 1252 051e 8091 0000 		lds r24,crc
 1253 0522 9813      		cpse r25,r24
 1254 0524 00C0      		rjmp .L80
 1255 0526 00C0      		rjmp .L81
 1256               	.L79:
 1257               		.loc 4 290 0 discriminator 6
 1258 0528 8111      		cpse r24,__zero_reg__
 1259 052a 00C0      		rjmp .L80
 1260               	.L81:
 291:main.c        **** 
 292:main.c        **** 
 293:main.c        ****            if (commandbyte == 0x87 ) {newbllevel = twdrbuffer;}
 1261               		.loc 4 293 0 is_stmt 1
 1262 052c 8091 0000 		lds r24,commandbyte
 1263 0530 8738      		cpi r24,lo8(-121)
 1264 0532 01F4      		brne .L82
 1265               		.loc 4 293 0 is_stmt 0 discriminator 1
 1266 0534 8091 0000 		lds r24,twdrbuffer
 1267 0538 8093 0000 		sts newbllevel,r24
 1268 053c 00C0      		rjmp .L83
 1269               	.L82:
 294:main.c        ****       else if (commandbyte == 0x98 ) {displaychange = 1; if (twdrbuffer == 0xFF) {write_lcd(0x029,9
 1270               		.loc 4 294 0 is_stmt 1
 1271 053e 8839      		cpi r24,lo8(-104)
 1272 0540 01F4      		brne .L84
 1273               		.loc 4 294 0 is_stmt 0 discriminator 1
 1274 0542 81E0      		ldi r24,lo8(1)
 1275 0544 8093 0000 		sts displaychange,r24
 1276 0548 C091 0000 		lds r28,twdrbuffer
 1277 054c 69E0      		ldi r22,lo8(9)
 1278 054e CF3F      		cpi r28,lo8(-1)
 1279 0550 01F4      		brne .L85
 1280               		.loc 4 294 0 discriminator 2
 1281 0552 89E2      		ldi r24,lo8(41)
 1282 0554 90E0      		ldi r25,0
 1283 0556 0E94 0000 		call write_lcd
 1284               	.LVL76:
 1285 055a 69E0      		ldi r22,lo8(9)
 1286 055c 83E1      		ldi r24,lo8(19)
 1287 055e 90E0      		ldi r25,0
 1288 0560 0E94 0000 		call write_lcd
 1289               	.LVL77:
 1290 0564 C093 0000 		sts display,r28
 1291 0568 00C0      		rjmp .L83
 1292               	.L85:
 1293               		.loc 4 294 0 discriminator 3
 1294 056a 88E2      		ldi r24,lo8(40)
 1295 056c 90E0      		ldi r25,0
 1296 056e 0E94 0000 		call write_lcd
 1297               	.LVL78:
 1298 0572 1092 0000 		sts display,__zero_reg__
 1299 0576 00C0      		rjmp .L83
 1300               	.L84:
 295:main.c        ****       else if (commandbyte == 0x99 ) {displaychange = 1; if (twdrbuffer == 0xFF) {write_lcd(0x023,9
 1301               		.loc 4 295 0 is_stmt 1
 1302 0578 8939      		cpi r24,lo8(-103)
 1303 057a 01F4      		brne .L86
 1304               		.loc 4 295 0 is_stmt 0 discriminator 1
 1305 057c 81E0      		ldi r24,lo8(1)
 1306 057e 8093 0000 		sts displaychange,r24
 1307 0582 8091 0000 		lds r24,twdrbuffer
 1308 0586 69E0      		ldi r22,lo8(9)
 1309 0588 8F3F      		cpi r24,lo8(-1)
 1310 058a 01F4      		brne .L87
 1311               		.loc 4 295 0 discriminator 2
 1312 058c 83E2      		ldi r24,lo8(35)
 1313 058e 90E0      		ldi r25,0
 1314 0590 00C0      		rjmp .L266
 1315               	.L87:
 1316               		.loc 4 295 0 discriminator 3
 1317 0592 82E2      		ldi r24,lo8(34)
 1318 0594 90E0      		ldi r25,0
 1319               	.L266:
 1320 0596 0E94 0000 		call write_lcd
 1321               	.LVL79:
 1322 059a 00C0      		rjmp .L83
 1323               	.L86:
 296:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1324               		.loc 4 296 0 is_stmt 1
 1325 059c 8D38      		cpi r24,lo8(-115)
 1326 059e 01F4      		brne .L88
 1327               		.loc 4 296 0 is_stmt 0 discriminator 1
 1328 05a0 8091 0000 		lds r24,twdrbuffer
 1329 05a4 8F3F      		cpi r24,lo8(-1)
 1330 05a6 01F4      		brne .L89
 1331               		.loc 4 296 0 discriminator 2
 1332 05a8 469A      		sbi 0x8,6
 1333 05aa 00C0      		rjmp .L83
 1334               	.L89:
 1335               		.loc 4 296 0 discriminator 3
 1336 05ac 4698      		cbi 0x8,6
 1337 05ae 00C0      		rjmp .L83
 1338               	.L88:
 297:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTD |= _BV(PD7);} else {PORTD &= ~
 1339               		.loc 4 297 0 is_stmt 1
 1340 05b0 8E38      		cpi r24,lo8(-114)
 1341 05b2 01F4      		brne .L90
 1342               		.loc 4 297 0 is_stmt 0 discriminator 1
 1343 05b4 8091 0000 		lds r24,twdrbuffer
 1344 05b8 8F3F      		cpi r24,lo8(-1)
 1345 05ba 01F4      		brne .L91
 1346               		.loc 4 297 0 discriminator 2
 1347 05bc 5F9A      		sbi 0xb,7
 1348 05be 00C0      		rjmp .L83
 1349               	.L91:
 1350               		.loc 4 297 0 discriminator 3
 1351 05c0 5F98      		cbi 0xb,7
 1352 05c2 00C0      		rjmp .L83
 1353               	.L90:
 298:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1354               		.loc 4 298 0 is_stmt 1
 1355 05c4 8F38      		cpi r24,lo8(-113)
 1356 05c6 01F4      		brne .L92
 1357               		.loc 4 298 0 is_stmt 0 discriminator 1
 1358 05c8 8091 0000 		lds r24,twdrbuffer
 1359 05cc 8F3F      		cpi r24,lo8(-1)
 1360 05ce 01F4      		brne .L93
 1361               		.loc 4 298 0 discriminator 2
 1362 05d0 2E9A      		sbi 0x5,6
 1363 05d2 00C0      		rjmp .L83
 1364               	.L93:
 1365               		.loc 4 298 0 discriminator 3
 1366 05d4 2E98      		cbi 0x5,6
 1367 05d6 00C0      		rjmp .L83
 1368               	.L92:
 299:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1369               		.loc 4 299 0 is_stmt 1
 1370 05d8 8039      		cpi r24,lo8(-112)
 1371 05da 01F4      		brne .L94
 1372               		.loc 4 299 0 is_stmt 0 discriminator 1
 1373 05dc 8091 0000 		lds r24,twdrbuffer
 1374 05e0 8F3F      		cpi r24,lo8(-1)
 1375 05e2 01F4      		brne .L95
 1376               		.loc 4 299 0 discriminator 2
 1377 05e4 479A      		sbi 0x8,7
 1378 05e6 00C0      		rjmp .L83
 1379               	.L95:
 1380               		.loc 4 299 0 discriminator 3
 1381 05e8 4798      		cbi 0x8,7
 1382 05ea 00C0      		rjmp .L83
 1383               	.L94:
 300:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0x00) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1384               		.loc 4 300 0 is_stmt 1
 1385 05ec 8139      		cpi r24,lo8(-111)
 1386 05ee 01F4      		brne .L96
 1387               		.loc 4 300 0 is_stmt 0 discriminator 1
 1388 05f0 8091 0000 		lds r24,twdrbuffer
 1389 05f4 8111      		cpse r24,__zero_reg__
 1390 05f6 00C0      		rjmp .L97
 1391               		.loc 4 300 0 discriminator 2
 1392 05f8 729A      		sbi 0xe,2
 1393 05fa 00C0      		rjmp .L83
 1394               	.L97:
 1395               		.loc 4 300 0 discriminator 3
 1396 05fc 7298      		cbi 0xe,2
 1397 05fe 00C0      		rjmp .L83
 1398               	.L96:
 301:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1399               		.loc 4 301 0 is_stmt 1
 1400 0600 8239      		cpi r24,lo8(-110)
 1401 0602 01F4      		brne .L98
 1402               		.loc 4 301 0 is_stmt 0 discriminator 1
 1403 0604 8091 0000 		lds r24,twdrbuffer
 1404 0608 8F3F      		cpi r24,lo8(-1)
 1405 060a 01F4      		brne .L99
 1406               		.loc 4 301 0 discriminator 2
 1407 060c 2D9A      		sbi 0x5,5
 1408 060e 00C0      		rjmp .L83
 1409               	.L99:
 1410               		.loc 4 301 0 discriminator 3
 1411 0610 8130      		cpi r24,lo8(1)
 1412 0612 01F4      		brne .L100
 1413               		.loc 4 301 0 discriminator 4
 1414 0614 2D9A      		sbi 0x5,5
 1415 0616 82E0      		ldi r24,lo8(2)
 1416 0618 8093 0000 		sts twdrbuffer,r24
 1417 061c 00C0      		rjmp .L83
 1418               	.L100:
 1419               		.loc 4 301 0 discriminator 5
 1420 061e 2D98      		cbi 0x5,5
 1421 0620 1092 0000 		sts twdrbuffer,__zero_reg__
 1422 0624 00C0      		rjmp .L83
 1423               	.L98:
 302:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1424               		.loc 4 302 0 is_stmt 1
 1425 0626 8339      		cpi r24,lo8(-109)
 1426 0628 01F4      		brne .L101
 1427               		.loc 4 302 0 is_stmt 0 discriminator 1
 1428 062a 8091 0000 		lds r24,twdrbuffer
 1429 062e 87BD      		out 0x27,r24
 1430 0630 8091 0000 		lds r24,twdrbuffer
 1431 0634 8093 0000 		sts fanlevel,r24
 1432 0638 00C0      		rjmp .L83
 1433               	.L101:
 303:main.c        ****       else if (commandbyte == 0x94 ) {led[led_position].r = twdrbuffer;changeled = 1;}  //set r col
 1434               		.loc 4 303 0 is_stmt 1
 1435 063a 8439      		cpi r24,lo8(-108)
 1436 063c 01F4      		brne .L102
 1437               		.loc 4 303 0 is_stmt 0 discriminator 1
 1438 063e 8091 0000 		lds r24,led_position
 1439 0642 90E0      		ldi r25,0
 1440 0644 FC01      		movw r30,r24
 1441 0646 EE0F      		lsl r30
 1442 0648 FF1F      		rol r31
 1443 064a 8E0F      		add r24,r30
 1444 064c 9F1F      		adc r25,r31
 1445 064e FC01      		movw r30,r24
 1446 0650 E050      		subi r30,lo8(-(led))
 1447 0652 F040      		sbci r31,hi8(-(led))
 1448 0654 8091 0000 		lds r24,twdrbuffer
 1449 0658 8183      		std Z+1,r24
 1450 065a 00C0      		rjmp .L267
 1451               	.L102:
 304:main.c        ****       else if (commandbyte == 0x95 ) {led[led_position].g = twdrbuffer;changeled = 1;}  //set g col
 1452               		.loc 4 304 0 is_stmt 1
 1453 065c 8539      		cpi r24,lo8(-107)
 1454 065e 01F4      		brne .L103
 1455               		.loc 4 304 0 is_stmt 0 discriminator 1
 1456 0660 8091 0000 		lds r24,led_position
 1457 0664 90E0      		ldi r25,0
 1458 0666 FC01      		movw r30,r24
 1459 0668 EE0F      		lsl r30
 1460 066a FF1F      		rol r31
 1461 066c 8E0F      		add r24,r30
 1462 066e 9F1F      		adc r25,r31
 1463 0670 FC01      		movw r30,r24
 1464 0672 E050      		subi r30,lo8(-(led))
 1465 0674 F040      		sbci r31,hi8(-(led))
 1466 0676 8091 0000 		lds r24,twdrbuffer
 1467 067a 8083      		st Z,r24
 1468 067c 00C0      		rjmp .L267
 1469               	.L103:
 305:main.c        ****       else if (commandbyte == 0x96 ) {led[led_position].b = twdrbuffer;changeled = 1;}  //set b col
 1470               		.loc 4 305 0 is_stmt 1
 1471 067e 8639      		cpi r24,lo8(-106)
 1472 0680 01F4      		brne .L104
 1473               		.loc 4 305 0 is_stmt 0 discriminator 1
 1474 0682 8091 0000 		lds r24,led_position
 1475 0686 90E0      		ldi r25,0
 1476 0688 FC01      		movw r30,r24
 1477 068a EE0F      		lsl r30
 1478 068c FF1F      		rol r31
 1479 068e 8E0F      		add r24,r30
 1480 0690 9F1F      		adc r25,r31
 1481 0692 FC01      		movw r30,r24
 1482 0694 E050      		subi r30,lo8(-(led))
 1483 0696 F040      		sbci r31,hi8(-(led))
 1484 0698 8091 0000 		lds r24,twdrbuffer
 1485 069c 8283      		std Z+2,r24
 1486               	.L267:
 1487 069e 81E0      		ldi r24,lo8(1)
 1488 06a0 8093 0000 		sts changeled,r24
 1489 06a4 00C0      		rjmp .L83
 1490               	.L104:
 306:main.c        ****       else if (commandbyte == 0xFD ) {if (twdrbuffer == 0xFF) jumptobootloader = 1; } //jump to boo
 1491               		.loc 4 306 0 is_stmt 1
 1492 06a6 8D3F      		cpi r24,lo8(-3)
 1493 06a8 01F4      		brne .L105
 1494               		.loc 4 306 0 is_stmt 0 discriminator 1
 1495 06aa 8091 0000 		lds r24,twdrbuffer
 1496 06ae 8F3F      		cpi r24,lo8(-1)
 1497 06b0 01F4      		brne .L83
 1498               		.loc 4 306 0 discriminator 2
 1499 06b2 81E0      		ldi r24,lo8(1)
 1500 06b4 8093 0000 		sts jumptobootloader,r24
 1501 06b8 00C0      		rjmp .L83
 1502               	.L105:
 307:main.c        ****       else if (commandbyte == 0xA1 ) {led_position = twdrbuffer;}
 1503               		.loc 4 307 0 is_stmt 1
 1504 06ba 813A      		cpi r24,lo8(-95)
 1505 06bc 01F4      		brne .L106
 1506               		.loc 4 307 0 is_stmt 0 discriminator 1
 1507 06be 8091 0000 		lds r24,twdrbuffer
 1508 06c2 8093 0000 		sts led_position,r24
 1509 06c6 00C0      		rjmp .L83
 1510               	.L106:
 308:main.c        ****       else if (commandbyte == 0xA0 ) {watchdog = twdrbuffer;}
 1511               		.loc 4 308 0 is_stmt 1
 1512 06c8 803A      		cpi r24,lo8(-96)
 1513 06ca 01F4      		brne .L80
 1514               		.loc 4 308 0 is_stmt 0 discriminator 1
 1515 06cc 8091 0000 		lds r24,twdrbuffer
 1516 06d0 8093 0000 		sts watchdog,r24
 1517 06d4 00C0      		rjmp .L83
 1518               	.L80:
 309:main.c        ****       else {i2cerror++;} 
 1519               		.loc 4 309 0 is_stmt 1
 1520 06d6 8091 0000 		lds r24,i2cerror
 1521 06da 8F5F      		subi r24,lo8(-(1))
 1522 06dc 8093 0000 		sts i2cerror,r24
 1523               	.L83:
 310:main.c        **** 
 311:main.c        **** 
 312:main.c        ****       } 
 313:main.c        ****       else {i2cerror++;}
 314:main.c        **** 
 315:main.c        ****       buffer_address++;
 1524               		.loc 4 315 0
 1525 06e0 8091 0000 		lds r24,buffer_address
 1526 06e4 8F5F      		subi r24,lo8(-(1))
 1527 06e6 8093 0000 		sts buffer_address,r24
 1528               	.L63:
 316:main.c        **** 
 317:main.c        ****       }
 318:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1529               		.loc 4 318 0
 1530 06ea 85EC      		ldi r24,lo8(-59)
 1531 06ec 8093 BC00 		sts 188,r24
 319:main.c        ****       if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1532               		.loc 4 319 0
 1533 06f0 8091 0000 		lds r24,commandbyte
 1534 06f4 8239      		cpi r24,lo8(-110)
 1535 06f6 01F0      		breq .+2
 1536 06f8 00C0      		rjmp .L53
 1537 06fa 8091 0000 		lds r24,twdrbuffer
 1538 06fe 8230      		cpi r24,lo8(2)
 1539 0700 01F0      		breq .+2
 1540 0702 00C0      		rjmp .L53
 1541               	.LVL80:
 1542               	.LBB86:
 1543               	.LBB87:
 1544               		.loc 3 276 0
 1545 0704 85E8      		ldi r24,lo8(-123)
 1546 0706 8A95      	1:	dec r24
 1547 0708 01F4      		brne 1b
 1548 070a 0000      		nop
 1549               	.LVL81:
 1550               	.LBE87:
 1551               	.LBE86:
 1552               		.loc 4 319 0
 1553 070c 2D98      		cbi 0x5,5
 1554 070e 00C0      		rjmp .L53
 1555               	.L59:
 320:main.c        ****       break;
 321:main.c        **** 
 322:main.c        ****     case TW_ST_SLA_ACK: //  slave adressed
 323:main.c        ****     case TW_ST_DATA_ACK:
 324:main.c        ****       
 325:main.c        ****       //_delay_us(1); 
 326:main.c        **** 
 327:main.c        **** 	     switch(commandbyte)  {		 
 1556               		.loc 4 327 0
 1557 0710 8091 0000 		lds r24,commandbyte
 1558 0714 8331      		cpi r24,lo8(19)
 1559 0716 01F4      		brne .+2
 1560 0718 00C0      		rjmp .L110
 1561 071a 00F4      		brsh .L111
 1562 071c 8C30      		cpi r24,lo8(12)
 1563 071e 01F4      		brne .+2
 1564 0720 00C0      		rjmp .L112
 1565 0722 00F4      		brsh .L113
 1566 0724 8730      		cpi r24,lo8(7)
 1567 0726 01F4      		brne .+2
 1568 0728 00C0      		rjmp .L114
 1569 072a 00C0      		rjmp .L115
 1570               	.L113:
 1571 072c 8F30      		cpi r24,lo8(15)
 1572 072e 01F4      		brne .+2
 1573 0730 00C0      		rjmp .L116
 1574 0732 00F4      		brsh .L117
 1575 0734 8D30      		cpi r24,lo8(13)
 1576 0736 01F4      		brne .+2
 1577 0738 00C0      		rjmp .L118
 1578 073a 8E30      		cpi r24,lo8(14)
 1579 073c 01F4      		brne .+2
 1580 073e 00C0      		rjmp .L119
 1581 0740 00C0      		rjmp .L109
 1582               	.L117:
 1583 0742 9091 0000 		lds r25,buffer_address
 1584 0746 8131      		cpi r24,lo8(17)
 1585 0748 01F4      		brne .+2
 1586 074a 00C0      		rjmp .L120
 1587 074c 00F4      		brsh .+2
 1588 074e 00C0      		rjmp .L265
 1589 0750 00C0      		rjmp .L309
 1590               	.L111:
 1591 0752 8032      		cpi r24,lo8(32)
 1592 0754 01F0      		breq .L123
 1593 0756 00F4      		brsh .L124
 1594 0758 8631      		cpi r24,lo8(22)
 1595 075a 01F4      		brne .+2
 1596 075c 00C0      		rjmp .L125
 1597 075e 00F4      		brsh .L126
 1598 0760 8431      		cpi r24,lo8(20)
 1599 0762 01F4      		brne .+2
 1600 0764 00C0      		rjmp .L127
 1601 0766 8531      		cpi r24,lo8(21)
 1602 0768 01F4      		brne .+2
 1603 076a 00C0      		rjmp .L128
 1604 076c 00C0      		rjmp .L109
 1605               	.L126:
 1606 076e 8731      		cpi r24,lo8(23)
 1607 0770 01F4      		brne .+2
 1608 0772 00C0      		rjmp .L115
 1609 0774 8831      		cpi r24,lo8(24)
 1610 0776 01F0      		breq .L129
 1611 0778 00C0      		rjmp .L109
 1612               	.L124:
 1613 077a 8F37      		cpi r24,lo8(127)
 1614 077c 01F4      		brne .+2
 1615 077e 00C0      		rjmp .L130
 1616 0780 00F4      		brsh .L131
 1617 0782 8132      		cpi r24,lo8(33)
 1618 0784 01F0      		breq .L132
 1619 0786 8E37      		cpi r24,lo8(126)
 1620 0788 01F4      		brne .+2
 1621 078a 00C0      		rjmp .L133
 1622 078c 00C0      		rjmp .L109
 1623               	.L131:
 1624 078e 8738      		cpi r24,lo8(-121)
 1625 0790 01F0      		breq .L134
 1626 0792 00F4      		brsh .+2
 1627 0794 00C0      		rjmp .L109
 1628 0796 8D58      		subi r24,lo8(-(115))
 1629 0798 8A30      		cpi r24,lo8(10)
 1630 079a 00F0      		brlo .+2
 1631 079c 00C0      		rjmp .L109
 1632               	.L134:
 328:main.c        **** 
 329:main.c        ****                  case 0x87:
 330:main.c        ****                  case 0x8D:
 331:main.c        ****                  case 0x8E:
 332:main.c        ****                  case 0x8F:
 333:main.c        ****                  case 0x90:
 334:main.c        ****                  case 0x91:
 335:main.c        ****                  case 0x92:
 336:main.c        ****                  case 0x93:
 337:main.c        ****                  case 0x94:
 338:main.c        ****                  case 0x95:
 339:main.c        ****                  case 0x96:  { TWDR = crc;  crc = 0xFF;} break;
 1633               		.loc 4 339 0
 1634 079e 8091 0000 		lds r24,crc
 1635 07a2 8093 BB00 		sts 187,r24
 1636 07a6 8FEF      		ldi r24,lo8(-1)
 1637 07a8 00C0      		rjmp .L272
 1638               	.L129:
 340:main.c        **** 
 341:main.c        ****                  case 0x18:  
 342:main.c        ****                           if (buffer_address == 0)  {TWDR = display; crc = _crc8_ccitt_update(crc,T
 1639               		.loc 4 342 0
 1640 07aa 8091 0000 		lds r24,buffer_address
 1641 07ae 8111      		cpse r24,__zero_reg__
 1642 07b0 00C0      		rjmp .L185
 1643               		.loc 4 342 0 is_stmt 0 discriminator 1
 1644 07b2 8091 0000 		lds r24,display
 1645 07b6 00C0      		rjmp .L270
 1646               	.L123:
 343:main.c        ****                       else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 344:main.c        ****                       else     {TWDR = 0xFF; i2cerror++;}
 345:main.c        **** 
 346:main.c        ****                             break;
 347:main.c        **** 
 348:main.c        **** 
 349:main.c        **** 
 350:main.c        ****                  case 0x20:  
 351:main.c        ****                            if (buffer_address == 0)  {TWDR = watchdog; crc = _crc8_ccitt_update(crc
 1647               		.loc 4 351 0 is_stmt 1
 1648 07b8 8091 0000 		lds r24,buffer_address
 1649 07bc 8111      		cpse r24,__zero_reg__
 1650 07be 00C0      		rjmp .L185
 1651               		.loc 4 351 0 is_stmt 0 discriminator 1
 1652 07c0 8091 0000 		lds r24,watchdog
 1653               	.L270:
 1654 07c4 8093 BB00 		sts 187,r24
 1655               	.L273:
 1656 07c8 6091 BB00 		lds r22,187
 1657 07cc 8091 0000 		lds r24,crc
 1658 07d0 0E94 0000 		call _crc8_ccitt_update
 1659               	.LVL82:
 1660               	.L272:
 1661 07d4 8093 0000 		sts crc,r24
 1662 07d8 00C0      		rjmp .L135
 1663               	.L132:
 352:main.c        ****                       else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 353:main.c        ****                       else     {TWDR = 0xFF; i2cerror++;}
 354:main.c        **** 
 355:main.c        ****                             break;
 356:main.c        **** 
 357:main.c        **** 
 358:main.c        ****                  case 0x21:  
 359:main.c        ****                            if (buffer_address == 0)  {TWDR = led_position; crc = _crc8_ccitt_update
 1664               		.loc 4 359 0 is_stmt 1
 1665 07da 8091 0000 		lds r24,buffer_address
 1666 07de 8111      		cpse r24,__zero_reg__
 1667 07e0 00C0      		rjmp .L185
 1668               		.loc 4 359 0 is_stmt 0 discriminator 1
 1669 07e2 8091 0000 		lds r24,led_position
 1670 07e6 00C0      		rjmp .L270
 1671               	.L127:
 360:main.c        ****                       else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 361:main.c        ****                       else     {TWDR = 0xFF; i2cerror++;}
 362:main.c        **** 
 363:main.c        ****                             break;
 364:main.c        **** 
 365:main.c        **** 
 366:main.c        ****                  case 0x14:
 367:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_
 1672               		.loc 4 367 0 is_stmt 1
 1673 07e8 8091 0000 		lds r24,buffer_address
 1674 07ec 8111      		cpse r24,__zero_reg__
 1675 07ee 00C0      		rjmp .L185
 1676 07f0 00C0      		rjmp .L275
 1677               	.L128:
 368:main.c        ****                            else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 369:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 370:main.c        ****                            break; 
 371:main.c        ****                  case 0x15:
 372:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[led_position].g; crc = _crc8_
 1678               		.loc 4 372 0
 1679 07f2 8091 0000 		lds r24,buffer_address
 1680 07f6 8111      		cpse r24,__zero_reg__
 1681 07f8 00C0      		rjmp .L185
 1682 07fa 00C0      		rjmp .L276
 1683               	.L125:
 373:main.c        ****                            else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 374:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 375:main.c        ****                            break; 
 376:main.c        **** 
 377:main.c        ****                  case 0x16: 
 378:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[led_position].b; crc = _crc8_
 1684               		.loc 4 378 0
 1685 07fc 8091 0000 		lds r24,buffer_address
 1686 0800 8111      		cpse r24,__zero_reg__
 1687 0802 00C0      		rjmp .L185
 1688 0804 00C0      		rjmp .L277
 1689               	.L115:
 379:main.c        ****                            else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 380:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 381:main.c        ****                            break; 
 382:main.c        **** 
 383:main.c        ****                  case 0x00:
 384:main.c        ****                  case 0x01:
 385:main.c        ****                  case 0x02:
 386:main.c        ****                  case 0x03:
 387:main.c        ****                  case 0x04:
 388:main.c        ****                  case 0x05:
 389:main.c        ****                  case 0x06:
 390:main.c        ****                  case 0x08: 
 391:main.c        ****                  case 0x09: 
 392:main.c        ****                  case 0x0A: 
 393:main.c        ****                  case 0x0B: 
 394:main.c        ****                  case 0x17:      
 395:main.c        ****                                  if (buffer_address == 0) {TWDR = i2cbuffer & 0xFF; crc = _crc8_cci
 1690               		.loc 4 395 0
 1691 0806 8091 0000 		lds r24,buffer_address
 1692 080a 8111      		cpse r24,__zero_reg__
 1693 080c 00C0      		rjmp .L148
 1694               		.loc 4 395 0 is_stmt 0 discriminator 1
 1695 080e 8091 0000 		lds r24,i2cbuffer
 1696 0812 00C0      		rjmp .L270
 1697               	.L148:
 396:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1698               		.loc 4 396 0 is_stmt 1
 1699 0814 8130      		cpi r24,lo8(1)
 1700 0816 01F4      		brne .L149
 1701               		.loc 4 396 0 is_stmt 0 discriminator 1
 1702 0818 8091 0000 		lds r24,i2cbuffer+1
 1703 081c 00C0      		rjmp .L270
 1704               	.L149:
 397:main.c        ****                             else if (crc_active && buffer_address == 2) {TWDR = crc;}
 1705               		.loc 4 397 0 is_stmt 1
 1706 081e 9091 0000 		lds r25,crc_active
 1707 0822 9923      		tst r25
 1708 0824 01F4      		brne .+2
 1709 0826 00C0      		rjmp .L186
 1710               		.loc 4 397 0 is_stmt 0 discriminator 1
 1711 0828 8230      		cpi r24,lo8(2)
 1712 082a 01F0      		breq .+2
 1713 082c 00C0      		rjmp .L186
 1714 082e 00C0      		rjmp .L278
 1715               	.L112:
 398:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 399:main.c        ****                             break; 
 400:main.c        ****                            
 401:main.c        ****                  case 0x0C:     
 402:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_
 1716               		.loc 4 402 0 is_stmt 1
 1717 0830 8091 0000 		lds r24,buffer_address
 1718 0834 8111      		cpse r24,__zero_reg__
 1719 0836 00C0      		rjmp .L151
 1720               	.L275:
 1721               		.loc 4 402 0 is_stmt 0 discriminator 1
 1722 0838 8091 0000 		lds r24,led_position
 1723 083c 90E0      		ldi r25,0
 1724 083e FC01      		movw r30,r24
 1725 0840 EE0F      		lsl r30
 1726 0842 FF1F      		rol r31
 1727 0844 8E0F      		add r24,r30
 1728 0846 9F1F      		adc r25,r31
 1729 0848 FC01      		movw r30,r24
 1730 084a E050      		subi r30,lo8(-(led))
 1731 084c F040      		sbci r31,hi8(-(led))
 1732 084e 8181      		ldd r24,Z+1
 1733 0850 00C0      		rjmp .L270
 1734               	.L151:
 403:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[led_position].g; crc = _crc8_
 1735               		.loc 4 403 0 is_stmt 1
 1736 0852 8130      		cpi r24,lo8(1)
 1737 0854 01F4      		brne .L152
 1738               	.L276:
 1739               		.loc 4 403 0 is_stmt 0 discriminator 1
 1740 0856 8091 0000 		lds r24,led_position
 1741 085a 90E0      		ldi r25,0
 1742 085c FC01      		movw r30,r24
 1743 085e EE0F      		lsl r30
 1744 0860 FF1F      		rol r31
 1745 0862 8E0F      		add r24,r30
 1746 0864 9F1F      		adc r25,r31
 1747 0866 FC01      		movw r30,r24
 1748 0868 E050      		subi r30,lo8(-(led))
 1749 086a F040      		sbci r31,hi8(-(led))
 1750 086c 8081      		ld r24,Z
 1751 086e 00C0      		rjmp .L270
 1752               	.L152:
 404:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[led_position].b; crc = _crc8_
 1753               		.loc 4 404 0 is_stmt 1
 1754 0870 8230      		cpi r24,lo8(2)
 1755 0872 01F4      		brne .L153
 1756               	.L277:
 1757               		.loc 4 404 0 is_stmt 0 discriminator 1
 1758 0874 8091 0000 		lds r24,led_position
 1759 0878 90E0      		ldi r25,0
 1760 087a FC01      		movw r30,r24
 1761 087c EE0F      		lsl r30
 1762 087e FF1F      		rol r31
 1763 0880 8E0F      		add r24,r30
 1764 0882 9F1F      		adc r25,r31
 1765 0884 FC01      		movw r30,r24
 1766 0886 E050      		subi r30,lo8(-(led))
 1767 0888 F040      		sbci r31,hi8(-(led))
 1768 088a 8281      		ldd r24,Z+2
 1769 088c 00C0      		rjmp .L270
 1770               	.L153:
 405:main.c        ****                            else if (crc_active && buffer_address == 3)  {TWDR = crc;}
 1771               		.loc 4 405 0 is_stmt 1
 1772 088e 9091 0000 		lds r25,crc_active
 1773 0892 9923      		tst r25
 1774 0894 01F4      		brne .+2
 1775 0896 00C0      		rjmp .L186
 1776               		.loc 4 405 0 is_stmt 0 discriminator 1
 1777 0898 8330      		cpi r24,lo8(3)
 1778 089a 01F0      		breq .+2
 1779 089c 00C0      		rjmp .L186
 1780 089e 00C0      		rjmp .L278
 1781               	.L118:
 406:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 407:main.c        ****                            break; 
 408:main.c        **** 
 409:main.c        **** 
 410:main.c        **** 
 411:main.c        ****                  case 0x0D:      
 412:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC6)) {TWDR = 0xFF;}
 1782               		.loc 4 412 0 is_stmt 1
 1783 08a0 8091 0000 		lds r24,buffer_address
 1784 08a4 8111      		cpse r24,__zero_reg__
 1785 08a6 00C0      		rjmp .L185
 1786               		.loc 4 412 0 is_stmt 0 discriminator 1
 1787 08a8 369B      		sbis 0x6,6
 1788 08aa 00C0      		rjmp .L176
 1789 08ac 00C0      		rjmp .L294
 1790               	.L119:
 413:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 414:main.c        ****                             else {TWDR = 0xFF; i2cerror++;}
 415:main.c        ****                             break;
 416:main.c        **** 
 417:main.c        ****                  case 0x0E:     
 418:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PIND,PD7)) {TWDR = 0xFF;}
 1791               		.loc 4 418 0 is_stmt 1
 1792 08ae 8091 0000 		lds r24,buffer_address
 1793 08b2 8111      		cpse r24,__zero_reg__
 1794 08b4 00C0      		rjmp .L185
 1795               		.loc 4 418 0 is_stmt 0 discriminator 1
 1796 08b6 4F9B      		sbis 0x9,7
 1797 08b8 00C0      		rjmp .L176
 1798 08ba 00C0      		rjmp .L294
 1799               	.L116:
 419:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 420:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 421:main.c        ****                             break;
 422:main.c        **** 
 423:main.c        **** 
 424:main.c        ****                  case 0x0F:     
 425:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINB,PB6)) {TWDR = 0xFF;}
 1800               		.loc 4 425 0 is_stmt 1
 1801 08bc 8091 0000 		lds r24,buffer_address
 1802 08c0 8111      		cpse r24,__zero_reg__
 1803 08c2 00C0      		rjmp .L185
 1804               		.loc 4 425 0 is_stmt 0 discriminator 1
 1805 08c4 1E9B      		sbis 0x3,6
 1806 08c6 00C0      		rjmp .L176
 1807 08c8 00C0      		rjmp .L294
 1808               	.L265:
 426:main.c        ****                             else if (crc_active && buffer_address == 1) { TWDR = crc;}
 427:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 428:main.c        ****                             break;
 429:main.c        **** 
 430:main.c        ****                  case 0x10:  
 431:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC7)) {TWDR = 0xFF;}
 1809               		.loc 4 431 0 is_stmt 1
 1810 08ca 9111      		cpse r25,__zero_reg__
 1811 08cc 00C0      		rjmp .L175
 1812               		.loc 4 431 0 is_stmt 0 discriminator 1
 1813 08ce 379B      		sbis 0x6,7
 1814 08d0 00C0      		rjmp .L176
 1815 08d2 00C0      		rjmp .L294
 1816               	.L120:
 432:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 433:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 434:main.c        ****                             break;
 435:main.c        **** 
 436:main.c        **** 
 437:main.c        ****                  case 0x11:  
 438:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINE,PE2)) {TWDR = 0x00;}
 1817               		.loc 4 438 0 is_stmt 1
 1818 08d4 9111      		cpse r25,__zero_reg__
 1819 08d6 00C0      		rjmp .L171
 1820               		.loc 4 438 0 is_stmt 0 discriminator 1
 1821 08d8 629B      		sbis 0xc,2
 1822 08da 00C0      		rjmp .L294
 1823 08dc 00C0      		rjmp .L176
 1824               	.L171:
 439:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 1825               		.loc 4 439 0 is_stmt 1
 1826 08de 8091 0000 		lds r24,crc_active
 1827 08e2 8823      		tst r24
 1828 08e4 01F0      		breq .L174
 1829               		.loc 4 439 0 is_stmt 0 discriminator 1
 1830 08e6 9130      		cpi r25,lo8(1)
 1831 08e8 01F4      		brne .+2
 1832 08ea 00C0      		rjmp .L278
 1833               	.L174:
 440:main.c        ****                             else                          {TWDR = 0xFF; buffer_address = 0xFE; i2ce
 1834               		.loc 4 440 0 is_stmt 1
 1835 08ec 8FEF      		ldi r24,lo8(-1)
 1836 08ee 8093 BB00 		sts 187,r24
 1837 08f2 8EEF      		ldi r24,lo8(-2)
 1838 08f4 8093 0000 		sts buffer_address,r24
 1839 08f8 00C0      		rjmp .L271
 1840               	.L309:
 441:main.c        ****                             break;
 442:main.c        **** 
 443:main.c        **** 
 444:main.c        ****                  case 0x12:  
 445:main.c        ****                                  if (buffer_address == 0)  {if (bit_is_set(PINB,PB5)) {TWDR = 0xFF;
 1841               		.loc 4 445 0
 1842 08fa 9111      		cpse r25,__zero_reg__
 1843 08fc 00C0      		rjmp .L175
 1844               		.loc 4 445 0 is_stmt 0 discriminator 1
 1845 08fe 1D9B      		sbis 0x3,5
 1846 0900 00C0      		rjmp .L176
 1847               	.L294:
 1848               		.loc 4 445 0 discriminator 2
 1849 0902 8FEF      		ldi r24,lo8(-1)
 1850 0904 00C0      		rjmp .L270
 1851               	.L176:
 1852               		.loc 4 445 0 discriminator 3
 1853 0906 1092 BB00 		sts 187,__zero_reg__
 1854 090a 00C0      		rjmp .L273
 1855               	.L175:
 446:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 1856               		.loc 4 446 0 is_stmt 1
 1857 090c 8091 0000 		lds r24,crc_active
 1858 0910 8823      		tst r24
 1859 0912 01F0      		breq .L186
 1860               		.loc 4 446 0 is_stmt 0 discriminator 1
 1861 0914 9130      		cpi r25,lo8(1)
 1862 0916 01F4      		brne .L186
 1863 0918 00C0      		rjmp .L278
 1864               	.L110:
 447:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 448:main.c        ****                             break;
 449:main.c        **** 
 450:main.c        **** 
 451:main.c        ****                  case 0x13:  
 452:main.c        ****                                  if (buffer_address == 0) {TWDR = OCR0A; crc = _crc8_ccitt_update(c
 1865               		.loc 4 452 0 is_stmt 1
 1866 091a 8091 0000 		lds r24,buffer_address
 1867 091e 8111      		cpse r24,__zero_reg__
 1868 0920 00C0      		rjmp .L185
 1869               		.loc 4 452 0 is_stmt 0 discriminator 1
 1870 0922 87B5      		in r24,0x27
 1871 0924 00C0      		rjmp .L270
 1872               	.L133:
 453:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 454:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 455:main.c        ****                             break;
 456:main.c        **** 
 457:main.c        **** 
 458:main.c        **** 
 459:main.c        ****                  case 0x7E:  
 460:main.c        ****                                  if (buffer_address == 0) {TWDR = crc_active; crc = _crc8_ccitt_upd
 1873               		.loc 4 460 0 is_stmt 1
 1874 0926 8091 0000 		lds r24,buffer_address
 1875 092a 9091 0000 		lds r25,crc_active
 1876 092e 8111      		cpse r24,__zero_reg__
 1877 0930 00C0      		rjmp .L308
 1878               		.loc 4 460 0 is_stmt 0 discriminator 1
 1879 0932 9093 BB00 		sts 187,r25
 1880 0936 00C0      		rjmp .L273
 1881               	.L130:
 461:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 462:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 463:main.c        ****                             break;
 464:main.c        **** 
 465:main.c        **** 
 466:main.c        ****                  case 0x7F:  
 467:main.c        ****                                  if (buffer_address == 0) {TWDR = FW_VERSION; crc = _crc8_ccitt_upd
 1882               		.loc 4 467 0 is_stmt 1
 1883 0938 8091 0000 		lds r24,buffer_address
 1884 093c 8111      		cpse r24,__zero_reg__
 1885 093e 00C0      		rjmp .L185
 1886               		.loc 4 467 0 is_stmt 0 discriminator 1
 1887 0940 81E0      		ldi r24,lo8(1)
 1888 0942 00C0      		rjmp .L270
 1889               	.L114:
 468:main.c        ****                             else if (crc_active && buffer_address == 1) {TWDR = crc;}
 469:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 470:main.c        ****                             break;
 471:main.c        **** 
 472:main.c        **** 
 473:main.c        ****                 case 0x07:
 474:main.c        ****                            if (buffer_address == 0)  {TWDR = bllevel; if (crc_active) crc = _crc8_c
 1890               		.loc 4 474 0 is_stmt 1
 1891 0944 8091 0000 		lds r24,buffer_address
 1892 0948 8111      		cpse r24,__zero_reg__
 1893 094a 00C0      		rjmp .L185
 1894               		.loc 4 474 0 is_stmt 0 discriminator 1
 1895 094c 8091 0000 		lds r24,bllevel
 1896 0950 8093 BB00 		sts 187,r24
 1897 0954 8091 0000 		lds r24,crc_active
 1898 0958 8823      		tst r24
 1899 095a 01F0      		breq .L135
 1900 095c 00C0      		rjmp .L273
 1901               	.L185:
 475:main.c        ****                       else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 1902               		.loc 4 475 0 is_stmt 1
 1903 095e 9091 0000 		lds r25,crc_active
 1904               	.L308:
 1905 0962 9923      		tst r25
 1906 0964 01F0      		breq .L186
 1907               		.loc 4 475 0 is_stmt 0 discriminator 1
 1908 0966 8130      		cpi r24,lo8(1)
 1909 0968 01F4      		brne .L186
 1910               	.L278:
 1911               		.loc 4 475 0 discriminator 2
 1912 096a 8091 0000 		lds r24,crc
 1913 096e 00C0      		rjmp .L269
 1914               	.L186:
 476:main.c        ****                       else     {TWDR = 0xFF; i2cerror++;}
 1915               		.loc 4 476 0 is_stmt 1
 1916 0970 8FEF      		ldi r24,lo8(-1)
 1917 0972 8093 BB00 		sts 187,r24
 1918               	.L271:
 1919 0976 8091 0000 		lds r24,i2cerror
 1920 097a 8F5F      		subi r24,lo8(-(1))
 1921 097c 8093 0000 		sts i2cerror,r24
 1922 0980 00C0      		rjmp .L135
 1923               	.L109:
 477:main.c        **** 
 478:main.c        ****                             break;
 479:main.c        **** 
 480:main.c        **** 
 481:main.c        **** 
 482:main.c        ****                  default: TWDR = 0xFF; 
 1924               		.loc 4 482 0
 1925 0982 8FEF      		ldi r24,lo8(-1)
 1926               	.L269:
 1927 0984 8093 BB00 		sts 187,r24
 1928               	.L135:
 483:main.c        **** 
 484:main.c        **** 		 }	 
 485:main.c        **** 
 486:main.c        **** 
 487:main.c        **** 
 488:main.c        ****       
 489:main.c        ****       buffer_address++;
 1929               		.loc 4 489 0
 1930 0988 8091 0000 		lds r24,buffer_address
 1931 098c 8F5F      		subi r24,lo8(-(1))
 1932 098e 8093 0000 		sts buffer_address,r24
 1933 0992 00C0      		rjmp .L54
 1934               	.L57:
 490:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);        
 491:main.c        ****       break;                                 
 492:main.c        ****    
 493:main.c        ****     case TW_BUS_ERROR:   
 494:main.c        ****      TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1935               		.loc 4 494 0
 1936 0994 85ED      		ldi r24,lo8(-43)
 1937 0996 00C0      		rjmp .L274
 1938               	.L54:
 495:main.c        ****      break;
 496:main.c        **** 
 497:main.c        **** 
 498:main.c        ****     //case TW_SR_STOP:  TWCR |= (1<<TWINT)|(1<<TWEA)|(1<<TWEN);  break;
 499:main.c        **** 
 500:main.c        ****     default:         
 501:main.c        ****       TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)| (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|  (0<<TWWC);   
 1939               		.loc 4 501 0
 1940 0998 85EC      		ldi r24,lo8(-59)
 1941               	.L274:
 1942 099a 8093 BC00 		sts 188,r24
 1943               	.L53:
 1944               	/* epilogue start */
 502:main.c        ****                                                                                                    
 503:main.c        ****       
 504:main.c        ****   }
 505:main.c        **** 
 506:main.c        **** 
 507:main.c        **** 
 508:main.c        **** }
 1945               		.loc 4 508 0
 1946 099e FF91      		pop r31
 1947 09a0 EF91      		pop r30
 1948 09a2 CF91      		pop r28
 1949 09a4 BF91      		pop r27
 1950 09a6 AF91      		pop r26
 1951 09a8 9F91      		pop r25
 1952 09aa 8F91      		pop r24
 1953 09ac 7F91      		pop r23
 1954 09ae 6F91      		pop r22
 1955 09b0 5F91      		pop r21
 1956 09b2 4F91      		pop r20
 1957 09b4 3F91      		pop r19
 1958 09b6 2F91      		pop r18
 1959 09b8 0F90      		pop r0
 1960 09ba 0FBE      		out __SREG__,r0
 1961 09bc 0F90      		pop r0
 1962 09be 1F90      		pop r1
 1963 09c0 1895      		reti
 1964               		.cfi_endproc
 1965               	.LFE35:
 1967               	.global	setup
 1969               	setup:
 1970               	.LFB36:
 509:main.c        **** 
 510:main.c        **** 
 511:main.c        **** void setup(void)
 512:main.c        **** {
 1971               		.loc 4 512 0
 1972               		.cfi_startproc
 1973 09c2 CF93      		push r28
 1974               	.LCFI29:
 1975               		.cfi_def_cfa_offset 3
 1976               		.cfi_offset 28, -2
 1977 09c4 DF93      		push r29
 1978               	.LCFI30:
 1979               		.cfi_def_cfa_offset 4
 1980               		.cfi_offset 29, -3
 1981               	/* prologue: function */
 1982               	/* frame size = 0 */
 1983               	/* stack size = 2 */
 1984               	.L__stack_usage = 2
 513:main.c        ****    DDRF = 0b00000000;
 1985               		.loc 4 513 0
 1986 09c6 10BA      		out 0x10,__zero_reg__
 514:main.c        ****    DDRD = 0b10111000;
 1987               		.loc 4 514 0
 1988 09c8 88EB      		ldi r24,lo8(-72)
 1989 09ca 8AB9      		out 0xa,r24
 515:main.c        ****    PORTD= 0b00000000;
 1990               		.loc 4 515 0
 1991 09cc 1BB8      		out 0xb,__zero_reg__
 516:main.c        ****    DDRE = 0b00000000; 
 1992               		.loc 4 516 0
 1993 09ce 1DB8      		out 0xd,__zero_reg__
 517:main.c        ****    DDRE |= (1<<2);   // be carefull with hwb, check if its connected to GND via 10k (prototypes!)
 1994               		.loc 4 517 0
 1995 09d0 6A9A      		sbi 0xd,2
 518:main.c        ****    DDRB = 0b11100110;
 1996               		.loc 4 518 0
 1997 09d2 86EE      		ldi r24,lo8(-26)
 1998 09d4 84B9      		out 0x4,r24
 519:main.c        ****    DDRC = 0b11000000;
 1999               		.loc 4 519 0
 2000 09d6 80EC      		ldi r24,lo8(-64)
 2001 09d8 87B9      		out 0x7,r24
 520:main.c        ****    OCR0A = 0;           //    start value for FAN  0 / 255  (-> p-channel so inverted)       0x00 i
 2002               		.loc 4 520 0
 2003 09da 17BC      		out 0x27,__zero_reg__
 521:main.c        ****    TCCR0B  =  0b00000001;
 2004               		.loc 4 521 0
 2005 09dc 81E0      		ldi r24,lo8(1)
 2006 09de 85BD      		out 0x25,r24
 522:main.c        ****    TCCR0A  =  0b10000011;            // 8bit  62khz
 2007               		.loc 4 522 0
 2008 09e0 83E8      		ldi r24,lo8(-125)
 2009 09e2 84BD      		out 0x24,r24
 523:main.c        ****    TIMSK0 |= (1 << TOIE0);            // init interrupt for timer0 overflow
 2010               		.loc 4 523 0
 2011 09e4 EEE6      		ldi r30,lo8(110)
 2012 09e6 F0E0      		ldi r31,0
 2013 09e8 8081      		ld r24,Z
 2014 09ea 8160      		ori r24,lo8(1)
 2015 09ec 8083      		st Z,r24
 2016               	.LVL83:
 2017               	.LBB88:
 2018               	.LBB89:
 2019               		.file 5 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/power.h **** 
   5:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/power.h **** 
   8:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/avr/power.h ****      distribution.
  14:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/lib/avr/include/avr/power.h **** 
  18:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/lib/avr/include/avr/power.h **** 
  30:/usr/lib/avr/include/avr/power.h **** /* $Id$ */
  31:/usr/lib/avr/include/avr/power.h **** 
  32:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/lib/avr/include/avr/power.h **** 
  35:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** 
  39:/usr/lib/avr/include/avr/power.h **** /** \file */
  40:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  41:/usr/lib/avr/include/avr/power.h **** 
  42:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  43:/usr/lib/avr/include/avr/power.h **** 
  44:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  45:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  46:/usr/lib/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  47:/usr/lib/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  48:/usr/lib/avr/include/avr/power.h **** Register (CLKPR).
  49:/usr/lib/avr/include/avr/power.h **** 
  50:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  51:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  52:/usr/lib/avr/include/avr/power.h **** 
  53:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  54:/usr/lib/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  55:/usr/lib/avr/include/avr/power.h **** power reduction macros are not available..
  56:/usr/lib/avr/include/avr/power.h **** 
  57:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  58:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  59:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  60:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  61:/usr/lib/avr/include/avr/power.h **** 
  62:/usr/lib/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  63:/usr/lib/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  64:/usr/lib/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  65:/usr/lib/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  66:/usr/lib/avr/include/avr/power.h **** the clock below 131.072 kHz.
  67:/usr/lib/avr/include/avr/power.h **** 
  68:/usr/lib/avr/include/avr/power.h **** */
  69:/usr/lib/avr/include/avr/power.h **** 
  70:/usr/lib/avr/include/avr/power.h **** 
  71:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  72:/usr/lib/avr/include/avr/power.h **** 
  73:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  74:/usr/lib/avr/include/avr/power.h **** <small>
  75:/usr/lib/avr/include/avr/power.h **** <center>
  76:/usr/lib/avr/include/avr/power.h **** <table border="3">
  77:/usr/lib/avr/include/avr/power.h ****   <tr>
  78:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  79:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  80:/usr/lib/avr/include/avr/power.h ****   </tr>
  81:/usr/lib/avr/include/avr/power.h **** 
  82:/usr/lib/avr/include/avr/power.h ****   <tr>
  83:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  84:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  85:/usr/lib/avr/include/avr/power.h ****   </tr>
  86:/usr/lib/avr/include/avr/power.h **** 
  87:/usr/lib/avr/include/avr/power.h ****   <tr>
  88:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  89:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  90:/usr/lib/avr/include/avr/power.h ****   </tr>
  91:/usr/lib/avr/include/avr/power.h **** 
  92:/usr/lib/avr/include/avr/power.h ****   <tr>
  93:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  94:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  95:/usr/lib/avr/include/avr/power.h ****   </tr>
  96:/usr/lib/avr/include/avr/power.h **** 
  97:/usr/lib/avr/include/avr/power.h ****   <tr>
  98:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  99:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
 100:/usr/lib/avr/include/avr/power.h ****   </tr>
 101:/usr/lib/avr/include/avr/power.h **** 
 102:/usr/lib/avr/include/avr/power.h ****   <tr>
 103:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 104:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 105:/usr/lib/avr/include/avr/power.h ****   </tr>
 106:/usr/lib/avr/include/avr/power.h **** 
 107:/usr/lib/avr/include/avr/power.h ****   <tr>
 108:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 109:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 110:/usr/lib/avr/include/avr/power.h ****   </tr>
 111:/usr/lib/avr/include/avr/power.h **** 
 112:/usr/lib/avr/include/avr/power.h ****   <tr>
 113:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 114:/usr/lib/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 115:/usr/lib/avr/include/avr/power.h ****   </tr>
 116:/usr/lib/avr/include/avr/power.h **** 
 117:/usr/lib/avr/include/avr/power.h ****   <tr>
 118:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 119:/usr/lib/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 120:/usr/lib/avr/include/avr/power.h ****   </tr>
 121:/usr/lib/avr/include/avr/power.h **** 
 122:/usr/lib/avr/include/avr/power.h ****   <tr>
 123:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 124:/usr/lib/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 125:/usr/lib/avr/include/avr/power.h ****   </tr>
 126:/usr/lib/avr/include/avr/power.h **** 
 127:/usr/lib/avr/include/avr/power.h ****   <tr>
 128:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 129:/usr/lib/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 130:/usr/lib/avr/include/avr/power.h ****   </tr>
 131:/usr/lib/avr/include/avr/power.h **** 
 132:/usr/lib/avr/include/avr/power.h ****    <tr>
 133:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 134:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 135:/usr/lib/avr/include/avr/power.h ****   </tr>
 136:/usr/lib/avr/include/avr/power.h **** 
 137:/usr/lib/avr/include/avr/power.h ****   <tr>
 138:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 139:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 140:/usr/lib/avr/include/avr/power.h ****   </tr>
 141:/usr/lib/avr/include/avr/power.h **** 
 142:/usr/lib/avr/include/avr/power.h ****   <tr>
 143:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 144:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 145:/usr/lib/avr/include/avr/power.h ****   </tr>
 146:/usr/lib/avr/include/avr/power.h **** 
 147:/usr/lib/avr/include/avr/power.h ****   <tr>
 148:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 149:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 150:/usr/lib/avr/include/avr/power.h ****   </tr>
 151:/usr/lib/avr/include/avr/power.h ****   
 152:/usr/lib/avr/include/avr/power.h ****   <tr>
 153:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 154:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 155:/usr/lib/avr/include/avr/power.h ****   </tr>
 156:/usr/lib/avr/include/avr/power.h **** 
 157:/usr/lib/avr/include/avr/power.h ****   <tr>
 158:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 159:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 160:/usr/lib/avr/include/avr/power.h ****   </tr>
 161:/usr/lib/avr/include/avr/power.h **** 
 162:/usr/lib/avr/include/avr/power.h ****   <tr>
 163:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 164:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 165:/usr/lib/avr/include/avr/power.h ****   </tr>
 166:/usr/lib/avr/include/avr/power.h **** 
 167:/usr/lib/avr/include/avr/power.h ****   <tr>
 168:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 169:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 170:/usr/lib/avr/include/avr/power.h ****   </tr>
 171:/usr/lib/avr/include/avr/power.h **** 
 172:/usr/lib/avr/include/avr/power.h ****   <tr>
 173:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 174:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 175:/usr/lib/avr/include/avr/power.h ****   </tr>
 176:/usr/lib/avr/include/avr/power.h **** 
 177:/usr/lib/avr/include/avr/power.h ****   <tr>
 178:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 179:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 180:/usr/lib/avr/include/avr/power.h ****   </tr>
 181:/usr/lib/avr/include/avr/power.h **** 
 182:/usr/lib/avr/include/avr/power.h ****   <tr>
 183:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 184:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 185:/usr/lib/avr/include/avr/power.h ****   </tr>
 186:/usr/lib/avr/include/avr/power.h **** 
 187:/usr/lib/avr/include/avr/power.h ****   <tr>
 188:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 189:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 190:/usr/lib/avr/include/avr/power.h ****   </tr>
 191:/usr/lib/avr/include/avr/power.h **** 
 192:/usr/lib/avr/include/avr/power.h ****   <tr>
 193:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 194:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 195:/usr/lib/avr/include/avr/power.h ****   </tr>
 196:/usr/lib/avr/include/avr/power.h **** 
 197:/usr/lib/avr/include/avr/power.h ****   <tr>
 198:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 199:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 200:/usr/lib/avr/include/avr/power.h ****   </tr>
 201:/usr/lib/avr/include/avr/power.h **** 
 202:/usr/lib/avr/include/avr/power.h ****   <tr>
 203:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 204:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 205:/usr/lib/avr/include/avr/power.h ****   </tr>
 206:/usr/lib/avr/include/avr/power.h **** 
 207:/usr/lib/avr/include/avr/power.h ****   <tr>
 208:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 209:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 210:/usr/lib/avr/include/avr/power.h ****   </tr>
 211:/usr/lib/avr/include/avr/power.h **** 
 212:/usr/lib/avr/include/avr/power.h ****   <tr>
 213:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 214:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 215:/usr/lib/avr/include/avr/power.h ****   </tr>
 216:/usr/lib/avr/include/avr/power.h **** 
 217:/usr/lib/avr/include/avr/power.h ****   <tr>
 218:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 219:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 220:/usr/lib/avr/include/avr/power.h ****   </tr>
 221:/usr/lib/avr/include/avr/power.h **** 
 222:/usr/lib/avr/include/avr/power.h ****   <tr>
 223:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 224:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 225:/usr/lib/avr/include/avr/power.h ****   </tr>
 226:/usr/lib/avr/include/avr/power.h **** 
 227:/usr/lib/avr/include/avr/power.h ****   <tr>
 228:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 229:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 230:/usr/lib/avr/include/avr/power.h ****   </tr>
 231:/usr/lib/avr/include/avr/power.h **** 
 232:/usr/lib/avr/include/avr/power.h ****   <tr>
 233:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 234:/usr/lib/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 235:/usr/lib/avr/include/avr/power.h ****   </tr>
 236:/usr/lib/avr/include/avr/power.h **** 
 237:/usr/lib/avr/include/avr/power.h ****   <tr>
 238:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 239:/usr/lib/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 240:/usr/lib/avr/include/avr/power.h ****   </tr>
 241:/usr/lib/avr/include/avr/power.h **** 
 242:/usr/lib/avr/include/avr/power.h ****   <tr>
 243:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 244:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 245:/usr/lib/avr/include/avr/power.h ****   </tr>
 246:/usr/lib/avr/include/avr/power.h **** 
 247:/usr/lib/avr/include/avr/power.h ****   <tr>
 248:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 249:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 250:/usr/lib/avr/include/avr/power.h ****   </tr>
 251:/usr/lib/avr/include/avr/power.h **** 
 252:/usr/lib/avr/include/avr/power.h ****   <tr>
 253:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 254:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 255:/usr/lib/avr/include/avr/power.h ****   </tr>
 256:/usr/lib/avr/include/avr/power.h **** 
 257:/usr/lib/avr/include/avr/power.h ****   <tr>
 258:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 259:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 260:/usr/lib/avr/include/avr/power.h ****   </tr>
 261:/usr/lib/avr/include/avr/power.h **** 
 262:/usr/lib/avr/include/avr/power.h ****   <tr>
 263:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 264:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 265:/usr/lib/avr/include/avr/power.h ****   </tr>
 266:/usr/lib/avr/include/avr/power.h **** 
 267:/usr/lib/avr/include/avr/power.h ****   <tr>
 268:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 269:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 270:/usr/lib/avr/include/avr/power.h ****   </tr>
 271:/usr/lib/avr/include/avr/power.h **** 
 272:/usr/lib/avr/include/avr/power.h ****   <tr>
 273:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 274:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 275:/usr/lib/avr/include/avr/power.h ****   </tr>
 276:/usr/lib/avr/include/avr/power.h **** 
 277:/usr/lib/avr/include/avr/power.h ****   <tr>
 278:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 279:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 280:/usr/lib/avr/include/avr/power.h ****   </tr>
 281:/usr/lib/avr/include/avr/power.h **** 
 282:/usr/lib/avr/include/avr/power.h ****   <tr>
 283:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 284:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 285:/usr/lib/avr/include/avr/power.h ****   </tr>
 286:/usr/lib/avr/include/avr/power.h **** 
 287:/usr/lib/avr/include/avr/power.h ****   <tr>
 288:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 289:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 290:/usr/lib/avr/include/avr/power.h ****   </tr>
 291:/usr/lib/avr/include/avr/power.h **** 
 292:/usr/lib/avr/include/avr/power.h ****   <tr>
 293:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 294:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 295:/usr/lib/avr/include/avr/power.h ****   </tr>
 296:/usr/lib/avr/include/avr/power.h **** 
 297:/usr/lib/avr/include/avr/power.h ****   <tr>
 298:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 299:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 300:/usr/lib/avr/include/avr/power.h ****   </tr>
 301:/usr/lib/avr/include/avr/power.h **** 
 302:/usr/lib/avr/include/avr/power.h ****   <tr>
 303:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 304:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 305:/usr/lib/avr/include/avr/power.h ****   </tr>
 306:/usr/lib/avr/include/avr/power.h **** 
 307:/usr/lib/avr/include/avr/power.h ****   <tr>
 308:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 309:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 310:/usr/lib/avr/include/avr/power.h ****   </tr>
 311:/usr/lib/avr/include/avr/power.h **** 
 312:/usr/lib/avr/include/avr/power.h ****   <tr>
 313:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 314:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 315:/usr/lib/avr/include/avr/power.h ****   </tr>
 316:/usr/lib/avr/include/avr/power.h **** 
 317:/usr/lib/avr/include/avr/power.h ****   <tr>
 318:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 319:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 320:/usr/lib/avr/include/avr/power.h ****   </tr>
 321:/usr/lib/avr/include/avr/power.h **** 
 322:/usr/lib/avr/include/avr/power.h ****   <tr>
 323:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 324:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 325:/usr/lib/avr/include/avr/power.h ****   </tr>
 326:/usr/lib/avr/include/avr/power.h **** 
 327:/usr/lib/avr/include/avr/power.h ****   <tr>
 328:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 329:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 330:/usr/lib/avr/include/avr/power.h ****   </tr>
 331:/usr/lib/avr/include/avr/power.h **** 
 332:/usr/lib/avr/include/avr/power.h ****   <tr>
 333:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 334:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 335:/usr/lib/avr/include/avr/power.h ****   </tr>
 336:/usr/lib/avr/include/avr/power.h **** 
 337:/usr/lib/avr/include/avr/power.h ****   <tr>
 338:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 339:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 340:/usr/lib/avr/include/avr/power.h ****   </tr>
 341:/usr/lib/avr/include/avr/power.h **** 
 342:/usr/lib/avr/include/avr/power.h ****   <tr>
 343:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 344:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 345:/usr/lib/avr/include/avr/power.h ****   </tr>
 346:/usr/lib/avr/include/avr/power.h **** 
 347:/usr/lib/avr/include/avr/power.h ****   <tr>
 348:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 349:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 350:/usr/lib/avr/include/avr/power.h ****   </tr>
 351:/usr/lib/avr/include/avr/power.h **** 
 352:/usr/lib/avr/include/avr/power.h ****   <tr>
 353:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 354:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 355:/usr/lib/avr/include/avr/power.h ****   </tr>
 356:/usr/lib/avr/include/avr/power.h **** 
 357:/usr/lib/avr/include/avr/power.h ****   <tr>
 358:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 359:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 360:/usr/lib/avr/include/avr/power.h ****   </tr>
 361:/usr/lib/avr/include/avr/power.h **** 
 362:/usr/lib/avr/include/avr/power.h ****   <tr>
 363:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 364:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 365:/usr/lib/avr/include/avr/power.h ****   </tr>
 366:/usr/lib/avr/include/avr/power.h **** 
 367:/usr/lib/avr/include/avr/power.h ****   <tr>
 368:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 369:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 370:/usr/lib/avr/include/avr/power.h ****   </tr>
 371:/usr/lib/avr/include/avr/power.h **** 
 372:/usr/lib/avr/include/avr/power.h ****   <tr>
 373:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 374:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 375:/usr/lib/avr/include/avr/power.h ****   </tr>
 376:/usr/lib/avr/include/avr/power.h **** 
 377:/usr/lib/avr/include/avr/power.h ****   <tr>
 378:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 379:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 380:/usr/lib/avr/include/avr/power.h ****   </tr>
 381:/usr/lib/avr/include/avr/power.h **** 
 382:/usr/lib/avr/include/avr/power.h ****   <tr>
 383:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 384:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 385:/usr/lib/avr/include/avr/power.h ****   </tr>
 386:/usr/lib/avr/include/avr/power.h **** 
 387:/usr/lib/avr/include/avr/power.h ****   <tr>
 388:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 389:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 390:/usr/lib/avr/include/avr/power.h ****   </tr>
 391:/usr/lib/avr/include/avr/power.h **** 
 392:/usr/lib/avr/include/avr/power.h ****   <tr>
 393:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 394:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 395:/usr/lib/avr/include/avr/power.h ****   </tr>
 396:/usr/lib/avr/include/avr/power.h **** 
 397:/usr/lib/avr/include/avr/power.h ****   <tr>
 398:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 399:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 400:/usr/lib/avr/include/avr/power.h ****   </tr>
 401:/usr/lib/avr/include/avr/power.h **** 
 402:/usr/lib/avr/include/avr/power.h ****   <tr>
 403:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 404:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 405:/usr/lib/avr/include/avr/power.h ****   </tr>
 406:/usr/lib/avr/include/avr/power.h **** 
 407:/usr/lib/avr/include/avr/power.h ****   <tr>
 408:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 409:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 410:/usr/lib/avr/include/avr/power.h ****   </tr>
 411:/usr/lib/avr/include/avr/power.h **** 
 412:/usr/lib/avr/include/avr/power.h ****   <tr>
 413:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 414:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 415:/usr/lib/avr/include/avr/power.h ****   </tr>
 416:/usr/lib/avr/include/avr/power.h **** 
 417:/usr/lib/avr/include/avr/power.h ****   <tr>
 418:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 419:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 420:/usr/lib/avr/include/avr/power.h ****   </tr>
 421:/usr/lib/avr/include/avr/power.h **** 
 422:/usr/lib/avr/include/avr/power.h ****   <tr>
 423:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 424:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 425:/usr/lib/avr/include/avr/power.h ****   </tr>
 426:/usr/lib/avr/include/avr/power.h **** 
 427:/usr/lib/avr/include/avr/power.h ****   <tr>
 428:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 429:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 430:/usr/lib/avr/include/avr/power.h ****   </tr>
 431:/usr/lib/avr/include/avr/power.h **** 
 432:/usr/lib/avr/include/avr/power.h ****   <tr>
 433:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 434:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 435:/usr/lib/avr/include/avr/power.h ****   </tr>
 436:/usr/lib/avr/include/avr/power.h **** 
 437:/usr/lib/avr/include/avr/power.h ****   <tr>
 438:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 439:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 440:/usr/lib/avr/include/avr/power.h ****   </tr>
 441:/usr/lib/avr/include/avr/power.h **** 
 442:/usr/lib/avr/include/avr/power.h ****   <tr>
 443:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 444:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 445:/usr/lib/avr/include/avr/power.h ****   </tr>
 446:/usr/lib/avr/include/avr/power.h **** 
 447:/usr/lib/avr/include/avr/power.h ****   <tr>
 448:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 449:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 450:/usr/lib/avr/include/avr/power.h ****   </tr>
 451:/usr/lib/avr/include/avr/power.h **** 
 452:/usr/lib/avr/include/avr/power.h ****   <tr>
 453:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 454:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 455:/usr/lib/avr/include/avr/power.h ****   </tr>
 456:/usr/lib/avr/include/avr/power.h **** 
 457:/usr/lib/avr/include/avr/power.h ****   <tr>
 458:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 459:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 460:/usr/lib/avr/include/avr/power.h ****   </tr>
 461:/usr/lib/avr/include/avr/power.h **** 
 462:/usr/lib/avr/include/avr/power.h ****   <tr>
 463:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 464:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 465:/usr/lib/avr/include/avr/power.h ****   </tr>
 466:/usr/lib/avr/include/avr/power.h **** 
 467:/usr/lib/avr/include/avr/power.h ****   <tr>
 468:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 469:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 470:/usr/lib/avr/include/avr/power.h ****   </tr>
 471:/usr/lib/avr/include/avr/power.h **** 
 472:/usr/lib/avr/include/avr/power.h ****   <tr>
 473:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 474:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 475:/usr/lib/avr/include/avr/power.h ****   </tr>
 476:/usr/lib/avr/include/avr/power.h **** 
 477:/usr/lib/avr/include/avr/power.h ****   <tr>
 478:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 479:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 480:/usr/lib/avr/include/avr/power.h ****   </tr>
 481:/usr/lib/avr/include/avr/power.h **** 
 482:/usr/lib/avr/include/avr/power.h ****   <tr>
 483:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 484:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 485:/usr/lib/avr/include/avr/power.h ****   </tr>
 486:/usr/lib/avr/include/avr/power.h **** 
 487:/usr/lib/avr/include/avr/power.h ****   <tr>
 488:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 489:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 490:/usr/lib/avr/include/avr/power.h ****   </tr>
 491:/usr/lib/avr/include/avr/power.h **** 
 492:/usr/lib/avr/include/avr/power.h ****   <tr>
 493:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 494:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 495:/usr/lib/avr/include/avr/power.h ****   </tr>
 496:/usr/lib/avr/include/avr/power.h **** 
 497:/usr/lib/avr/include/avr/power.h ****   <tr>
 498:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 499:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 500:/usr/lib/avr/include/avr/power.h ****   </tr>
 501:/usr/lib/avr/include/avr/power.h **** 
 502:/usr/lib/avr/include/avr/power.h ****   <tr>
 503:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 504:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 505:/usr/lib/avr/include/avr/power.h ****   </tr>
 506:/usr/lib/avr/include/avr/power.h **** 
 507:/usr/lib/avr/include/avr/power.h ****   <tr>
 508:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 509:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 510:/usr/lib/avr/include/avr/power.h ****   </tr>
 511:/usr/lib/avr/include/avr/power.h **** 
 512:/usr/lib/avr/include/avr/power.h ****   <tr>
 513:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 514:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 515:/usr/lib/avr/include/avr/power.h ****   </tr>
 516:/usr/lib/avr/include/avr/power.h **** 
 517:/usr/lib/avr/include/avr/power.h ****   <tr>
 518:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 519:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 520:/usr/lib/avr/include/avr/power.h ****   </tr>
 521:/usr/lib/avr/include/avr/power.h **** 
 522:/usr/lib/avr/include/avr/power.h ****   <tr>
 523:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 524:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 525:/usr/lib/avr/include/avr/power.h ****   </tr>
 526:/usr/lib/avr/include/avr/power.h **** 
 527:/usr/lib/avr/include/avr/power.h ****   <tr>
 528:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 529:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 530:/usr/lib/avr/include/avr/power.h ****   </tr>
 531:/usr/lib/avr/include/avr/power.h **** 
 532:/usr/lib/avr/include/avr/power.h ****   <tr>
 533:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 534:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 535:/usr/lib/avr/include/avr/power.h ****   </tr>
 536:/usr/lib/avr/include/avr/power.h **** 
 537:/usr/lib/avr/include/avr/power.h ****   <tr>
 538:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 539:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 540:/usr/lib/avr/include/avr/power.h ****   </tr>
 541:/usr/lib/avr/include/avr/power.h **** </table>
 542:/usr/lib/avr/include/avr/power.h **** </center>
 543:/usr/lib/avr/include/avr/power.h **** </small>
 544:/usr/lib/avr/include/avr/power.h **** 
 545:/usr/lib/avr/include/avr/power.h **** @} */
 546:/usr/lib/avr/include/avr/power.h **** 
 547:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 548:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 549:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 550:/usr/lib/avr/include/avr/power.h **** #endif
 551:/usr/lib/avr/include/avr/power.h **** 
 552:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 553:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 554:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 555:/usr/lib/avr/include/avr/power.h **** #endif
 556:/usr/lib/avr/include/avr/power.h **** 
 557:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 558:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 559:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 560:/usr/lib/avr/include/avr/power.h **** #endif
 561:/usr/lib/avr/include/avr/power.h **** 
 562:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 563:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 564:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 565:/usr/lib/avr/include/avr/power.h **** #endif
 566:/usr/lib/avr/include/avr/power.h **** 
 567:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 568:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 569:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 570:/usr/lib/avr/include/avr/power.h **** #endif
 571:/usr/lib/avr/include/avr/power.h **** 
 572:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 573:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 574:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 575:/usr/lib/avr/include/avr/power.h **** #endif
 576:/usr/lib/avr/include/avr/power.h **** 
 577:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 578:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 579:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 580:/usr/lib/avr/include/avr/power.h **** #endif
 581:/usr/lib/avr/include/avr/power.h **** 
 582:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 583:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 584:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 585:/usr/lib/avr/include/avr/power.h **** #endif
 586:/usr/lib/avr/include/avr/power.h **** 
 587:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSCR)
 588:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 589:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 590:/usr/lib/avr/include/avr/power.h **** #endif
 591:/usr/lib/avr/include/avr/power.h **** 
 592:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 593:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 594:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 595:/usr/lib/avr/include/avr/power.h **** #endif
 596:/usr/lib/avr/include/avr/power.h **** 
 597:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 598:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 599:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 600:/usr/lib/avr/include/avr/power.h **** #endif
 601:/usr/lib/avr/include/avr/power.h **** 
 602:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 603:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 604:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 605:/usr/lib/avr/include/avr/power.h **** #endif
 606:/usr/lib/avr/include/avr/power.h **** 
 607:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 609:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 610:/usr/lib/avr/include/avr/power.h **** #endif
 611:/usr/lib/avr/include/avr/power.h **** 
 612:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 613:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 614:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 615:/usr/lib/avr/include/avr/power.h **** #endif
 616:/usr/lib/avr/include/avr/power.h **** 
 617:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 618:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 619:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 620:/usr/lib/avr/include/avr/power.h **** #endif
 621:/usr/lib/avr/include/avr/power.h **** 
 622:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 625:/usr/lib/avr/include/avr/power.h **** #endif
 626:/usr/lib/avr/include/avr/power.h **** 
 627:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 628:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 629:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 630:/usr/lib/avr/include/avr/power.h **** #endif
 631:/usr/lib/avr/include/avr/power.h **** 
 632:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 633:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 634:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 635:/usr/lib/avr/include/avr/power.h **** #endif
 636:/usr/lib/avr/include/avr/power.h **** 
 637:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 638:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 639:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 640:/usr/lib/avr/include/avr/power.h **** #endif
 641:/usr/lib/avr/include/avr/power.h **** 
 642:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCO)
 643:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 644:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 645:/usr/lib/avr/include/avr/power.h **** #endif
 646:/usr/lib/avr/include/avr/power.h **** 
 647:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 648:/usr/lib/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 649:/usr/lib/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 650:/usr/lib/avr/include/avr/power.h **** #endif
 651:/usr/lib/avr/include/avr/power.h **** 
 652:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 653:/usr/lib/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 654:/usr/lib/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 655:/usr/lib/avr/include/avr/power.h **** #endif
 656:/usr/lib/avr/include/avr/power.h **** 
 657:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 658:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 659:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 660:/usr/lib/avr/include/avr/power.h **** #endif
 661:/usr/lib/avr/include/avr/power.h **** 
 662:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 663:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))
 664:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))
 665:/usr/lib/avr/include/avr/power.h **** #endif
 666:/usr/lib/avr/include/avr/power.h **** 
 667:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFRS)
 668:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_enable()             (PRR0 &= (uint8_t)~(1 << PRLFRS))
 669:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_disable()            (PRR0 |= (uint8_t)(1 << PRLFRS))
 670:/usr/lib/avr/include/avr/power.h **** #endif
 671:/usr/lib/avr/include/avr/power.h **** 
 672:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 673:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 674:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 675:/usr/lib/avr/include/avr/power.h **** #endif
 676:/usr/lib/avr/include/avr/power.h **** 
 677:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 678:/usr/lib/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 679:/usr/lib/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 680:/usr/lib/avr/include/avr/power.h **** #endif
 681:/usr/lib/avr/include/avr/power.h **** 
 682:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 683:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 684:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 685:/usr/lib/avr/include/avr/power.h **** #endif
 686:/usr/lib/avr/include/avr/power.h **** 
 687:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 688:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 689:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 690:/usr/lib/avr/include/avr/power.h **** #endif
 691:/usr/lib/avr/include/avr/power.h **** 
 692:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 693:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 694:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 695:/usr/lib/avr/include/avr/power.h **** #endif
 696:/usr/lib/avr/include/avr/power.h **** 
 697:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 698:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 699:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 700:/usr/lib/avr/include/avr/power.h **** #endif
 701:/usr/lib/avr/include/avr/power.h **** 
 702:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 704:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 705:/usr/lib/avr/include/avr/power.h **** #endif
 706:/usr/lib/avr/include/avr/power.h **** 
 707:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 709:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 710:/usr/lib/avr/include/avr/power.h **** #endif
 711:/usr/lib/avr/include/avr/power.h **** 
 712:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 713:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 714:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 715:/usr/lib/avr/include/avr/power.h **** #endif
 716:/usr/lib/avr/include/avr/power.h **** 
 717:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 718:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 719:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 720:/usr/lib/avr/include/avr/power.h **** #endif
 721:/usr/lib/avr/include/avr/power.h **** 
 722:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 723:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 724:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 725:/usr/lib/avr/include/avr/power.h **** #endif
 726:/usr/lib/avr/include/avr/power.h **** 
 727:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 728:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 729:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 730:/usr/lib/avr/include/avr/power.h **** #endif
 731:/usr/lib/avr/include/avr/power.h **** 
 732:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 733:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 734:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 735:/usr/lib/avr/include/avr/power.h **** #endif
 736:/usr/lib/avr/include/avr/power.h **** 
 737:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI1)
 738:/usr/lib/avr/include/avr/power.h **** #define power_twi1_enable()             (PRR0 &= (uint8_t)~(1 << PRTWI1))
 739:/usr/lib/avr/include/avr/power.h **** #define power_twi1_disable()            (PRR0 |= (uint8_t)(1 << PRTWI1))
 740:/usr/lib/avr/include/avr/power.h **** #endif
 741:/usr/lib/avr/include/avr/power.h **** 
 742:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 743:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 744:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 745:/usr/lib/avr/include/avr/power.h **** #endif
 746:/usr/lib/avr/include/avr/power.h **** 
 747:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 748:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 749:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 750:/usr/lib/avr/include/avr/power.h **** #endif
 751:/usr/lib/avr/include/avr/power.h **** 
 752:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 753:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 754:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 755:/usr/lib/avr/include/avr/power.h **** #endif
 756:/usr/lib/avr/include/avr/power.h **** 
 757:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 758:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 759:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 760:/usr/lib/avr/include/avr/power.h **** #endif
 761:/usr/lib/avr/include/avr/power.h **** 
 762:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 763:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 764:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 765:/usr/lib/avr/include/avr/power.h **** #endif
 766:/usr/lib/avr/include/avr/power.h **** 
 767:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 768:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 769:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 770:/usr/lib/avr/include/avr/power.h **** #endif
 771:/usr/lib/avr/include/avr/power.h **** 
 772:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 773:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 774:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 775:/usr/lib/avr/include/avr/power.h **** #endif
 776:/usr/lib/avr/include/avr/power.h **** 
 777:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 778:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 779:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 780:/usr/lib/avr/include/avr/power.h **** #endif
 781:/usr/lib/avr/include/avr/power.h **** 
 782:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 783:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 784:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 785:/usr/lib/avr/include/avr/power.h **** #endif
 786:/usr/lib/avr/include/avr/power.h **** 
 787:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 788:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 789:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 790:/usr/lib/avr/include/avr/power.h **** #endif
 791:/usr/lib/avr/include/avr/power.h **** 
 792:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFPH)
 793:/usr/lib/avr/include/avr/power.h **** #define power_lfph_enable()             (PRR1 &= (uint8_t)~(1 << PRLFPH))
 794:/usr/lib/avr/include/avr/power.h **** #define power_lfph_disable()            (PRR1 |= (uint8_t)(1 << PRLFPH))
 795:/usr/lib/avr/include/avr/power.h **** #endif
 796:/usr/lib/avr/include/avr/power.h **** 
 797:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 798:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 799:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 800:/usr/lib/avr/include/avr/power.h **** #endif
 801:/usr/lib/avr/include/avr/power.h **** 
 802:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFTP)
 803:/usr/lib/avr/include/avr/power.h **** #define power_lftp_enable()             (PRR1 &= (uint8_t)~(1 << PRLFTP))
 804:/usr/lib/avr/include/avr/power.h **** #define power_lftp_disable()            (PRR1 |= (uint8_t)(1 << PRLFTP))
 805:/usr/lib/avr/include/avr/power.h **** #endif
 806:/usr/lib/avr/include/avr/power.h **** 
 807:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 808:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 809:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 810:/usr/lib/avr/include/avr/power.h **** #endif
 811:/usr/lib/avr/include/avr/power.h **** 
 812:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSPI)
 813:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR1 &= (uint8_t)~(1 << PRSPI))
 814:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR1 |= (uint8_t)(1 << PRSPI))
 815:/usr/lib/avr/include/avr/power.h **** #endif
 816:/usr/lib/avr/include/avr/power.h **** 
 817:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 818:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 819:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 820:/usr/lib/avr/include/avr/power.h **** #endif
 821:/usr/lib/avr/include/avr/power.h **** 
 822:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 824:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 825:/usr/lib/avr/include/avr/power.h **** #endif
 826:/usr/lib/avr/include/avr/power.h **** 
 827:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 828:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 829:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 830:/usr/lib/avr/include/avr/power.h **** #endif
 831:/usr/lib/avr/include/avr/power.h **** 
 832:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 833:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 834:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 835:/usr/lib/avr/include/avr/power.h **** #endif
 836:/usr/lib/avr/include/avr/power.h **** 
 837:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 838:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 839:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 840:/usr/lib/avr/include/avr/power.h **** #endif
 841:/usr/lib/avr/include/avr/power.h **** 
 842:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 843:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 844:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 845:/usr/lib/avr/include/avr/power.h **** #endif
 846:/usr/lib/avr/include/avr/power.h **** 
 847:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 848:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 849:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 850:/usr/lib/avr/include/avr/power.h **** #endif
 851:/usr/lib/avr/include/avr/power.h **** 
 852:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 853:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 854:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 855:/usr/lib/avr/include/avr/power.h **** #endif
 856:/usr/lib/avr/include/avr/power.h **** 
 857:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 858:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 859:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 860:/usr/lib/avr/include/avr/power.h **** #endif
 861:/usr/lib/avr/include/avr/power.h **** 
 862:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 863:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 864:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 865:/usr/lib/avr/include/avr/power.h **** #endif
 866:/usr/lib/avr/include/avr/power.h **** 
 867:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 868:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 869:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 870:/usr/lib/avr/include/avr/power.h **** #endif
 871:/usr/lib/avr/include/avr/power.h **** 
 872:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART3)
 873:/usr/lib/avr/include/avr/power.h **** #define power_usart3_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART3))
 874:/usr/lib/avr/include/avr/power.h **** #define power_usart3_disable()          (PRR1 |= (uint8_t)(1 << PRUSART3))
 875:/usr/lib/avr/include/avr/power.h **** #endif
 876:/usr/lib/avr/include/avr/power.h **** 
 877:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 878:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 879:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 880:/usr/lib/avr/include/avr/power.h **** #endif
 881:/usr/lib/avr/include/avr/power.h **** 
 882:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 883:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 884:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 885:/usr/lib/avr/include/avr/power.h **** #endif
 886:/usr/lib/avr/include/avr/power.h **** 
 887:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 888:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 889:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 890:/usr/lib/avr/include/avr/power.h **** #endif
 891:/usr/lib/avr/include/avr/power.h **** 
 892:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 893:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 894:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 895:/usr/lib/avr/include/avr/power.h **** #endif
 896:/usr/lib/avr/include/avr/power.h **** 
 897:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 898:/usr/lib/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 899:/usr/lib/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 900:/usr/lib/avr/include/avr/power.h **** #endif
 901:/usr/lib/avr/include/avr/power.h **** 
 902:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 903:/usr/lib/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 904:/usr/lib/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 905:/usr/lib/avr/include/avr/power.h **** #endif
 906:/usr/lib/avr/include/avr/power.h **** 
 907:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 908:/usr/lib/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 909:/usr/lib/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 910:/usr/lib/avr/include/avr/power.h **** #endif
 911:/usr/lib/avr/include/avr/power.h **** 
 912:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 913:/usr/lib/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 914:/usr/lib/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 915:/usr/lib/avr/include/avr/power.h **** #endif
 916:/usr/lib/avr/include/avr/power.h **** 
 917:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 918:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 919:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 920:/usr/lib/avr/include/avr/power.h **** #endif
 921:/usr/lib/avr/include/avr/power.h **** 
 922:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 923:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 924:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 925:/usr/lib/avr/include/avr/power.h **** #endif
 926:/usr/lib/avr/include/avr/power.h **** 
 927:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSPI2)
 928:/usr/lib/avr/include/avr/power.h **** #define power_spi2_enable()             (PRR2 &= (uint8_t)~(1 << PRSPI2))
 929:/usr/lib/avr/include/avr/power.h **** #define power_spi2_disable()            (PRR2 |= (uint8_t)(1 << PRSPI2))
 930:/usr/lib/avr/include/avr/power.h **** #endif
 931:/usr/lib/avr/include/avr/power.h **** 
 932:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 933:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 934:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 935:/usr/lib/avr/include/avr/power.h **** #endif
 936:/usr/lib/avr/include/avr/power.h **** 
 937:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 938:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 939:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 940:/usr/lib/avr/include/avr/power.h **** #endif
 941:/usr/lib/avr/include/avr/power.h **** 
 942:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTWI2)
 943:/usr/lib/avr/include/avr/power.h **** #define power_twi2_enable()             (PRR2 &= (uint8_t)~(1 << PRTWI2))
 944:/usr/lib/avr/include/avr/power.h **** #define power_twi2_disable()            (PRR2 |= (uint8_t)(1 << PRTWI2))
 945:/usr/lib/avr/include/avr/power.h **** #endif
 946:/usr/lib/avr/include/avr/power.h **** 
 947:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 948:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 949:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 950:/usr/lib/avr/include/avr/power.h **** #endif
 951:/usr/lib/avr/include/avr/power.h **** 
 952:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 953:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 954:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 955:/usr/lib/avr/include/avr/power.h **** #endif
 956:/usr/lib/avr/include/avr/power.h **** 
 957:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 958:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 959:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 960:/usr/lib/avr/include/avr/power.h **** #endif
 961:/usr/lib/avr/include/avr/power.h **** 
 962:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 963:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 964:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 965:/usr/lib/avr/include/avr/power.h **** #endif
 966:/usr/lib/avr/include/avr/power.h **** 
 967:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 968:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 969:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 970:/usr/lib/avr/include/avr/power.h **** #endif
 971:/usr/lib/avr/include/avr/power.h **** 
 972:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 973:/usr/lib/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 974:/usr/lib/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 975:/usr/lib/avr/include/avr/power.h **** #endif
 976:/usr/lib/avr/include/avr/power.h **** 
 977:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 978:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 979:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 980:/usr/lib/avr/include/avr/power.h **** #endif
 981:/usr/lib/avr/include/avr/power.h **** 
 982:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 983:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 984:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 985:/usr/lib/avr/include/avr/power.h **** #endif
 986:/usr/lib/avr/include/avr/power.h **** 
 987:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 988:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 989:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 990:/usr/lib/avr/include/avr/power.h **** #endif
 991:/usr/lib/avr/include/avr/power.h **** 
 992:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 993:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 994:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 995:/usr/lib/avr/include/avr/power.h **** #endif
 996:/usr/lib/avr/include/avr/power.h **** 
 997:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 998:/usr/lib/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 999:/usr/lib/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
1000:/usr/lib/avr/include/avr/power.h **** #endif
1001:/usr/lib/avr/include/avr/power.h **** 
1002:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
1003:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
1004:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
1005:/usr/lib/avr/include/avr/power.h **** #endif
1006:/usr/lib/avr/include/avr/power.h **** 
1007:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
1008:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
1009:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
1010:/usr/lib/avr/include/avr/power.h **** #endif
1011:/usr/lib/avr/include/avr/power.h **** 
1012:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
1013:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
1014:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
1015:/usr/lib/avr/include/avr/power.h **** #endif
1016:/usr/lib/avr/include/avr/power.h **** 
1017:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
1018:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
1019:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
1020:/usr/lib/avr/include/avr/power.h **** #endif
1021:/usr/lib/avr/include/avr/power.h **** 
1022:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
1023:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
1024:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
1025:/usr/lib/avr/include/avr/power.h **** #endif
1026:/usr/lib/avr/include/avr/power.h **** 
1027:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
1028:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
1029:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
1030:/usr/lib/avr/include/avr/power.h **** #endif
1031:/usr/lib/avr/include/avr/power.h **** 
1032:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
1033:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
1034:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
1035:/usr/lib/avr/include/avr/power.h **** #endif
1036:/usr/lib/avr/include/avr/power.h **** 
1037:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
1038:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
1039:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
1040:/usr/lib/avr/include/avr/power.h **** #endif
1041:/usr/lib/avr/include/avr/power.h **** 
1042:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1043:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1044:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1045:/usr/lib/avr/include/avr/power.h **** #endif
1046:/usr/lib/avr/include/avr/power.h **** 
1047:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1048:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1049:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1050:/usr/lib/avr/include/avr/power.h **** #endif
1051:/usr/lib/avr/include/avr/power.h **** 
1052:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1053:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1054:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1055:/usr/lib/avr/include/avr/power.h **** #endif
1056:/usr/lib/avr/include/avr/power.h **** 
1057:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1058:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1059:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1060:/usr/lib/avr/include/avr/power.h **** #endif
1061:/usr/lib/avr/include/avr/power.h **** 
1062:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1063:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1064:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1065:/usr/lib/avr/include/avr/power.h **** #endif
1066:/usr/lib/avr/include/avr/power.h **** 
1067:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1068:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1069:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1070:/usr/lib/avr/include/avr/power.h **** #endif
1071:/usr/lib/avr/include/avr/power.h **** 
1072:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1073:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1074:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1075:/usr/lib/avr/include/avr/power.h **** #endif
1076:/usr/lib/avr/include/avr/power.h **** 
1077:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1078:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1079:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1080:/usr/lib/avr/include/avr/power.h **** #endif
1081:/usr/lib/avr/include/avr/power.h **** 
1082:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1083:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1084:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1085:/usr/lib/avr/include/avr/power.h **** #endif
1086:/usr/lib/avr/include/avr/power.h **** 
1087:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1088:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1089:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1090:/usr/lib/avr/include/avr/power.h **** #endif
1091:/usr/lib/avr/include/avr/power.h **** 
1092:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1093:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1094:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1095:/usr/lib/avr/include/avr/power.h **** #endif
1096:/usr/lib/avr/include/avr/power.h **** 
1097:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1098:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1099:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1100:/usr/lib/avr/include/avr/power.h **** #endif
1101:/usr/lib/avr/include/avr/power.h **** 
1102:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1103:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1104:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1105:/usr/lib/avr/include/avr/power.h **** #endif
1106:/usr/lib/avr/include/avr/power.h **** 
1107:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1108:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1109:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1110:/usr/lib/avr/include/avr/power.h **** #endif
1111:/usr/lib/avr/include/avr/power.h **** 
1112:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1113:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1114:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1115:/usr/lib/avr/include/avr/power.h **** #endif
1116:/usr/lib/avr/include/avr/power.h **** 
1117:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1118:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1119:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1120:/usr/lib/avr/include/avr/power.h **** #endif
1121:/usr/lib/avr/include/avr/power.h **** 
1122:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1123:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1124:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1125:/usr/lib/avr/include/avr/power.h **** #endif
1126:/usr/lib/avr/include/avr/power.h **** 
1127:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1128:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1129:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1130:/usr/lib/avr/include/avr/power.h **** #endif
1131:/usr/lib/avr/include/avr/power.h **** 
1132:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1133:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1134:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1135:/usr/lib/avr/include/avr/power.h **** #endif
1136:/usr/lib/avr/include/avr/power.h **** 
1137:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1138:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1139:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1140:/usr/lib/avr/include/avr/power.h **** #endif
1141:/usr/lib/avr/include/avr/power.h **** 
1142:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1143:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1144:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1145:/usr/lib/avr/include/avr/power.h **** #endif
1146:/usr/lib/avr/include/avr/power.h **** 
1147:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1148:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1149:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1150:/usr/lib/avr/include/avr/power.h **** #endif
1151:/usr/lib/avr/include/avr/power.h **** 
1152:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1153:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1154:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1155:/usr/lib/avr/include/avr/power.h **** #endif
1156:/usr/lib/avr/include/avr/power.h **** 
1157:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1158:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1159:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1160:/usr/lib/avr/include/avr/power.h **** #endif
1161:/usr/lib/avr/include/avr/power.h **** 
1162:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1163:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1164:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1165:/usr/lib/avr/include/avr/power.h **** #endif
1166:/usr/lib/avr/include/avr/power.h **** 
1167:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1168:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1169:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1170:/usr/lib/avr/include/avr/power.h **** #endif
1171:/usr/lib/avr/include/avr/power.h **** 
1172:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1173:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1174:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1175:/usr/lib/avr/include/avr/power.h **** #endif
1176:/usr/lib/avr/include/avr/power.h **** 
1177:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1178:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1179:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1180:/usr/lib/avr/include/avr/power.h **** #endif
1181:/usr/lib/avr/include/avr/power.h **** 
1182:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1183:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1184:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1185:/usr/lib/avr/include/avr/power.h **** #endif
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** static __inline void
1188:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1189:/usr/lib/avr/include/avr/power.h **** __power_all_enable()
1190:/usr/lib/avr/include/avr/power.h **** {
1191:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1192:/usr/lib/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1193:/usr/lib/avr/include/avr/power.h **** #endif
1194:/usr/lib/avr/include/avr/power.h **** 
1195:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1196:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1197:/usr/lib/avr/include/avr/power.h **** #endif
1198:/usr/lib/avr/include/avr/power.h **** 
1199:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1200:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1201:/usr/lib/avr/include/avr/power.h **** #endif
1202:/usr/lib/avr/include/avr/power.h **** 
1203:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1204:/usr/lib/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1205:/usr/lib/avr/include/avr/power.h **** #endif
1206:/usr/lib/avr/include/avr/power.h **** 
1207:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1208:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1209:/usr/lib/avr/include/avr/power.h **** #endif
1210:/usr/lib/avr/include/avr/power.h **** 
1211:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1212:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1213:/usr/lib/avr/include/avr/power.h **** #endif
1214:/usr/lib/avr/include/avr/power.h **** 
1215:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1216:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1217:/usr/lib/avr/include/avr/power.h **** #endif
1218:/usr/lib/avr/include/avr/power.h **** 
1219:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1220:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1221:/usr/lib/avr/include/avr/power.h **** #endif
1222:/usr/lib/avr/include/avr/power.h **** 
1223:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1224:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1225:/usr/lib/avr/include/avr/power.h **** #endif
1226:/usr/lib/avr/include/avr/power.h **** 
1227:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1228:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1229:/usr/lib/avr/include/avr/power.h **** #endif
1230:/usr/lib/avr/include/avr/power.h **** 
1231:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1232:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1233:/usr/lib/avr/include/avr/power.h **** #endif
1234:/usr/lib/avr/include/avr/power.h **** }
1235:/usr/lib/avr/include/avr/power.h **** 
1236:/usr/lib/avr/include/avr/power.h **** static __inline void
1237:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1238:/usr/lib/avr/include/avr/power.h **** __power_all_disable()
1239:/usr/lib/avr/include/avr/power.h **** {
1240:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1241:/usr/lib/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1242:/usr/lib/avr/include/avr/power.h **** #endif
1243:/usr/lib/avr/include/avr/power.h **** 
1244:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1245:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1246:/usr/lib/avr/include/avr/power.h **** #endif
1247:/usr/lib/avr/include/avr/power.h **** 
1248:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1249:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1250:/usr/lib/avr/include/avr/power.h **** #endif
1251:/usr/lib/avr/include/avr/power.h **** 
1252:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1253:/usr/lib/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1254:/usr/lib/avr/include/avr/power.h **** #endif
1255:/usr/lib/avr/include/avr/power.h **** 
1256:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1257:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1258:/usr/lib/avr/include/avr/power.h **** #endif
1259:/usr/lib/avr/include/avr/power.h **** 
1260:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1261:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1262:/usr/lib/avr/include/avr/power.h **** #endif
1263:/usr/lib/avr/include/avr/power.h **** 
1264:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1265:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1266:/usr/lib/avr/include/avr/power.h **** #endif
1267:/usr/lib/avr/include/avr/power.h **** 
1268:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1269:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1270:/usr/lib/avr/include/avr/power.h **** #endif
1271:/usr/lib/avr/include/avr/power.h **** 
1272:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1273:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1274:/usr/lib/avr/include/avr/power.h **** #endif
1275:/usr/lib/avr/include/avr/power.h **** 
1276:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1277:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1278:/usr/lib/avr/include/avr/power.h **** #endif
1279:/usr/lib/avr/include/avr/power.h **** 
1280:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1281:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1282:/usr/lib/avr/include/avr/power.h **** #endif
1283:/usr/lib/avr/include/avr/power.h **** }
1284:/usr/lib/avr/include/avr/power.h **** 
1285:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1286:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_enable
1287:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1288:/usr/lib/avr/include/avr/power.h **** #endif
1289:/usr/lib/avr/include/avr/power.h **** 
1290:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_disable
1291:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1292:/usr/lib/avr/include/avr/power.h **** #endif
1293:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1294:/usr/lib/avr/include/avr/power.h **** 
1295:/usr/lib/avr/include/avr/power.h **** 
1296:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1297:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1298:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1299:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1300:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1301:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1302:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1303:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1304:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1305:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1310:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1311:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1312:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1313:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1314:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1315:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1316:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1317:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA6617C__) \
1318:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA664251__) \
1319:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1320:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1321:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1323:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1324:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1325:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1326:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1327:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1328:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1329:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1330:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1331:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1332:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1333:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1334:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1335:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1336:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1337:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1338:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PB__) \
1339:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1340:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1341:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1342:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1343:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16M1__) \
1344:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1345:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325P__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250P__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1372:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1373:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1374:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1375:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1376:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1377:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1378:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1379:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PB__) \
1380:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1381:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1382:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1383:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1384:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1385:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1386:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1387:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1388:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1389:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1390:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1391:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1392:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1393:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1394:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1395:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__) \
1396:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1397:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1398:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1399:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PB__) \
1400:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1401:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1402:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1403:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1404:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1405:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1406:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1407:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1408:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1409:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1410:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1411:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__) \
1412:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__) \
1413:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1414:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1415:/usr/lib/avr/include/avr/power.h **** 
1416:/usr/lib/avr/include/avr/power.h **** 
1417:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1418:/usr/lib/avr/include/avr/power.h **** 
1419:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1420:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1421:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low.
1422:/usr/lib/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1423:/usr/lib/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1424:/usr/lib/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1425:/usr/lib/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1426:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1427:/usr/lib/avr/include/avr/power.h **** 
1428:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1429:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1430:/usr/lib/avr/include/avr/power.h **** macros are not available.
1431:/usr/lib/avr/include/avr/power.h **** */
1432:/usr/lib/avr/include/avr/power.h **** 
1433:/usr/lib/avr/include/avr/power.h **** 
1434:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1435:/usr/lib/avr/include/avr/power.h **** \code 
1436:/usr/lib/avr/include/avr/power.h **** typedef enum
1437:/usr/lib/avr/include/avr/power.h **** {
1438:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1439:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1440:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1441:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1442:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1443:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1444:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1445:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1446:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1447:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1448:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1449:/usr/lib/avr/include/avr/power.h **** \endcode
1450:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1451:/usr/lib/avr/include/avr/power.h **** System Clock Prescale Register.
1452:/usr/lib/avr/include/avr/power.h **** 
1453:/usr/lib/avr/include/avr/power.h **** \code
1454:/usr/lib/avr/include/avr/power.h **** typedef enum
1455:/usr/lib/avr/include/avr/power.h **** {
1456:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 1,
1457:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 2,
1458:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 4,
1459:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 8,
1460:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 16,
1461:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 32,
1462:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 64,
1463:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 128
1464:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1465:/usr/lib/avr/include/avr/power.h **** \endcode
1466:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1467:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1468:/usr/lib/avr/include/avr/power.h **** 
1469:/usr/lib/avr/include/avr/power.h **** */
1470:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1471:/usr/lib/avr/include/avr/power.h **** typedef enum
1472:/usr/lib/avr/include/avr/power.h **** {
1473:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1474:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1475:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1476:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1477:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1478:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1479:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1480:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1481:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1482:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1483:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1484:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1485:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1486:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1487:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1488:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__)
1489:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1490:/usr/lib/avr/include/avr/power.h **** #endif
1491:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1492:/usr/lib/avr/include/avr/power.h **** 
1493:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1494:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1495:/usr/lib/avr/include/avr/power.h **** 
1496:/usr/lib/avr/include/avr/power.h **** /**
1497:/usr/lib/avr/include/avr/power.h ****    \ingroup avr_power
1498:/usr/lib/avr/include/avr/power.h ****    \fn clock_prescale_set(clock_div_t x)
1499:/usr/lib/avr/include/avr/power.h **** 
1500:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1501:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1502:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1503:/usr/lib/avr/include/avr/power.h **** 
1504:/usr/lib/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1505:/usr/lib/avr/include/avr/power.h **** 
1506:/usr/lib/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1507:/usr/lib/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1508:/usr/lib/avr/include/avr/power.h **** */
1509:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1510:/usr/lib/avr/include/avr/power.h **** {
1511:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1512:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 2020               		.loc 5 1512 0
 2021 09ee 90E0      		ldi r25,0
 2022 09f0 80E8      		ldi r24,lo8(-128)
 2023               	/* #APP */
 2024               	 ;  1512 "/usr/lib/avr/include/avr/power.h" 1
 2025 09f2 0FB6      		in __tmp_reg__,__SREG__
 2026 09f4 F894      		cli
 2027 09f6 8093 6100 		sts 97, r24
 2028 09fa 9093 6100 		sts 97, r25
 2029 09fe 0FBE      		out __SREG__, __tmp_reg__
 2030               	 ;  0 "" 2
 2031               	.LVL84:
 2032               	/* #NOAPP */
 2033               	.LBE89:
 2034               	.LBE88:
 524:main.c        ****    clock_prescale_set(clock_div_1);
 525:main.c        ****    I2C_init(I2C_ADDR);
 2035               		.loc 4 525 0
 2036 0a00 8AE2      		ldi r24,lo8(42)
 2037 0a02 0E94 0000 		call I2C_init
 2038               	.LVL85:
 526:main.c        ****    PCICR |= _BV(PCIE0);              // enable pin change interrupt for PB0 (rpm)
 2039               		.loc 4 526 0
 2040 0a06 E8E6      		ldi r30,lo8(104)
 2041 0a08 F0E0      		ldi r31,0
 2042 0a0a 8081      		ld r24,Z
 2043 0a0c 8160      		ori r24,lo8(1)
 2044 0a0e 8083      		st Z,r24
 527:main.c        ****    PCMSK0 |= (1 << PCINT4);
 2045               		.loc 4 527 0
 2046 0a10 EBE6      		ldi r30,lo8(107)
 2047 0a12 F0E0      		ldi r31,0
 2048 0a14 8081      		ld r24,Z
 2049 0a16 8061      		ori r24,lo8(16)
 2050 0a18 8083      		st Z,r24
 528:main.c        ****    sei();
 2051               		.loc 4 528 0
 2052               	/* #APP */
 2053               	 ;  528 "main.c" 1
 2054 0a1a 7894      		sei
 2055               	 ;  0 "" 2
 529:main.c        **** 
 530:main.c        ****    led[0].r = 255;
 2056               		.loc 4 530 0
 2057               	/* #NOAPP */
 2058 0a1c C0E0      		ldi r28,lo8(led)
 2059 0a1e D0E0      		ldi r29,hi8(led)
 2060 0a20 8FEF      		ldi r24,lo8(-1)
 2061 0a22 8983      		std Y+1,r24
 531:main.c        ****    led[0].g = 255;
 2062               		.loc 4 531 0
 2063 0a24 8883      		st Y,r24
 532:main.c        ****    led[0].b = 255;
 2064               		.loc 4 532 0
 2065 0a26 8A83      		std Y+2,r24
 533:main.c        ****  
 534:main.c        ****    led[1].r = 255;
 2066               		.loc 4 534 0
 2067 0a28 8C83      		std Y+4,r24
 535:main.c        ****    led[1].g = 255;
 2068               		.loc 4 535 0
 2069 0a2a 8B83      		std Y+3,r24
 536:main.c        ****    led[1].b = 255;
 2070               		.loc 4 536 0
 2071 0a2c 8D83      		std Y+5,r24
 537:main.c        **** 
 538:main.c        ****    ws2812_setleds(led,2);
 2072               		.loc 4 538 0
 2073 0a2e 62E0      		ldi r22,lo8(2)
 2074 0a30 70E0      		ldi r23,0
 2075 0a32 CE01      		movw r24,r28
 2076 0a34 0E94 0000 		call ws2812_setleds
 2077               	.LVL86:
 539:main.c        **** 
 540:main.c        ****    setup_lcd();
 2078               		.loc 4 540 0
 2079 0a38 0E94 0000 		call setup_lcd
 2080               	.LVL87:
 541:main.c        **** 
 542:main.c        ****    init_backlight();
 2081               		.loc 4 542 0
 2082 0a3c 0E94 0000 		call init_backlight
 2083               	.LVL88:
 543:main.c        **** 
 544:main.c        **** 
 545:main.c        ****    led[0].r = 0;
 2084               		.loc 4 545 0
 2085 0a40 1982      		std Y+1,__zero_reg__
 546:main.c        ****    led[0].g = 0;
 2086               		.loc 4 546 0
 2087 0a42 1882      		st Y,__zero_reg__
 547:main.c        ****    led[0].b = 0;
 2088               		.loc 4 547 0
 2089 0a44 1A82      		std Y+2,__zero_reg__
 548:main.c        **** 
 549:main.c        ****  
 550:main.c        ****    led[1].r = 0;
 2090               		.loc 4 550 0
 2091 0a46 1C82      		std Y+4,__zero_reg__
 551:main.c        ****    led[1].g = 0;
 2092               		.loc 4 551 0
 2093 0a48 1B82      		std Y+3,__zero_reg__
 552:main.c        ****    led[1].b = 0;
 2094               		.loc 4 552 0
 2095 0a4a 1D82      		std Y+5,__zero_reg__
 553:main.c        **** 
 554:main.c        ****    ws2812_setleds(led,2);
 2096               		.loc 4 554 0
 2097 0a4c 62E0      		ldi r22,lo8(2)
 2098 0a4e 70E0      		ldi r23,0
 2099 0a50 CE01      		movw r24,r28
 2100 0a52 0E94 0000 		call ws2812_setleds
 2101               	.LVL89:
 555:main.c        **** 
 556:main.c        **** 
 557:main.c        ****    OCR0A = 210;
 2102               		.loc 4 557 0
 2103 0a56 82ED      		ldi r24,lo8(-46)
 2104 0a58 87BD      		out 0x27,r24
 2105               	.LVL90:
 2106               	.LBB90:
 2107               	.LBB91:
 2108               		.file 6 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2109               		.loc 6 473 0
 2110 0a5a 99E2      		ldi r25,lo8(41)
 2111 0a5c 88E1      		ldi r24,lo8(24)
 2112               	/* #APP */
 2113               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 2114 0a5e 0FB6      		in __tmp_reg__,__SREG__
 2115 0a60 F894      		cli
 2116 0a62 A895      		wdr
 2117 0a64 8093 6000 		sts 96, r24
 2118 0a68 0FBE      		out __SREG__,__tmp_reg__
 2119 0a6a 9093 6000 		sts 96, r25
 2120               	 	
 2121               	 ;  0 "" 2
 2122               	.LVL91:
 2123               	/* epilogue start */
 2124               	/* #NOAPP */
 2125               	.LBE91:
 2126               	.LBE90:
 558:main.c        ****    wdt_enable(WDTO_8S);
 559:main.c        ****    
 560:main.c        **** }
 2127               		.loc 4 560 0
 2128 0a6e DF91      		pop r29
 2129 0a70 CF91      		pop r28
 2130 0a72 0895      		ret
 2131               		.cfi_endproc
 2132               	.LFE36:
 2134               	.global	__floatunsisf
 2135               	.global	__mulsf3
 2136               	.global	__fixunssfsi
 2137               		.section	.text.startup,"ax",@progbits
 2138               	.global	main
 2140               	main:
 2141               	.LFB37:
 561:main.c        **** 
 562:main.c        **** 
 563:main.c        **** int main(void)
 564:main.c        **** {
 2142               		.loc 4 564 0
 2143               		.cfi_startproc
 2144               	/* prologue: function */
 2145               	/* frame size = 0 */
 2146               	/* stack size = 0 */
 2147               	.L__stack_usage = 0
 2148               	.LVL92:
 565:main.c        ****   uint8_t adcselect = 0;
 566:main.c        ****   setup();
 2149               		.loc 4 566 0
 2150 0000 0E94 0000 		call setup
 2151               	.LVL93:
 565:main.c        ****   uint8_t adcselect = 0;
 2152               		.loc 4 565 0
 2153 0004 10E0      		ldi r17,0
 567:main.c        **** 
 568:main.c        ****   while(1) {  
 569:main.c        **** 
 570:main.c        **** 
 571:main.c        ****   if (jumptobootloader > 0) {
 572:main.c        ****    TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 2154               		.loc 4 572 0
 2155 0006 01ED      		ldi r16,lo8(-47)
 573:main.c        ****    asm volatile("jmp 0x7C00");
 574:main.c        ****   }
 575:main.c        **** 
 576:main.c        ****  
 577:main.c        **** 
 578:main.c        ****   if (watchdog == 0x01) {
 579:main.c        **** 
 580:main.c        ****   if (SCL_LINE) {watchi2c++;} else {watchi2c = 0;led[0].r=0; led[0].g=0;led[0].b=0; ws2812_setleds(
 581:main.c        **** 
 582:main.c        ****   if (watchi2c > 10000) {led[0].r=255; led[0].g=255;led[0].b=0; ws2812_setleds(led,1);}
 2156               		.loc 4 582 0
 2157 0008 FF24      		clr r15
 2158 000a FA94      		dec r15
 583:main.c        ****   }
 584:main.c        **** 
 585:main.c        ****   if (!SDA_LINE) {i2cerror++;}
 586:main.c        ****   
 587:main.c        ****   if (i2cerror > 200) {
 588:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 589:main.c        ****   I2C_init(I2C_ADDR); 
 590:main.c        ****   i2cerror = 0;
 591:main.c        ****   sei();
 592:main.c        ****   }                    
 593:main.c        **** 
 594:main.c        ****   wdt_reset();	
 595:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 64khz
 596:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 2159               		.loc 4 596 0
 2160 000c 3EE1      		ldi r19,lo8(30)
 2161 000e E32E      		mov r14,r19
 597:main.c        ****   fanspin = 0;
 598:main.c        ****   isrtimer = 0;
 599:main.c        ****   if (fanlevel == 254) { //fan minimal auto
 600:main.c        ****   if (rpm > 1950) {OCR0A++;}
 601:main.c        ****   if (rpm < 1800) {OCR0A--;}
 602:main.c        ****   }
 603:main.c        ****   }
 604:main.c        ****   if (displaychange) {init_backlight(); displaychange = 0;}
 605:main.c        **** 
 606:main.c        ****   if (changeled)  {
 607:main.c        ****       ws2812_setleds(led,led_position+1);
 608:main.c        ****       changeled = 0;
 609:main.c        ****                      }
 610:main.c        **** 
 611:main.c        ****   if (newbllevel != bllevel  && 0 <= newbllevel && newbllevel < 32) {
 612:main.c        **** 
 613:main.c        ****   if (newbllevel < bllevel) {bllevel--;}   else {bllevel++;}
 614:main.c        **** 
 615:main.c        ****   write_backlight(0b01011000);
 616:main.c        ****   write_backlight(0b00011111 & bllevel);
 617:main.c        ****   }
 618:main.c        ****   
 619:main.c        **** 
 620:main.c        **** 
 621:main.c        **** 
 622:main.c        ****   if (adcselect < 10) {adcselect++;} else {adcselect = 0;}
 623:main.c        ****   
 624:main.c        ****   switch(adcselect)
 625:main.c        ****   {
 626:main.c        ****    case 0: a0 = read_analog(7);  break;
 627:main.c        ****    case 1: a1 = read_analog(6);  break;
 628:main.c        ****    case 2: a2 = read_analog(5);  break;
 629:main.c        ****    case 4: a3 = read_analog(4);  break; 
 630:main.c        ****    case 5: a4 = read_analog(1);  break; 
 631:main.c        ****    case 7: a5 = read_analog(0);  break;
 632:main.c        ****    case 8: vcc = readVcc();  break;
 633:main.c        ****    case 10: temp = GetTemp();   break;
 634:main.c        **** 
 635:main.c        ****  
 636:main.c        ****    default: {a7 = read_analog(9);  //read A7 more frequently 
 637:main.c        ****            if (a7 > a7max) a7max = a7;
 638:main.c        ****            if (a7 < a7min) a7min = a7;
 639:main.c        ****            a7count++;
 640:main.c        ****            if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max
 2162               		.loc 4 640 0
 2163 0010 C0E0      		ldi r28,0
 2164 0012 D4E0      		ldi r29,lo8(4)
 2165               	.LVL94:
 2166               	.L312:
 571:main.c        ****    TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 2167               		.loc 4 571 0
 2168 0014 8091 0000 		lds r24,jumptobootloader
 2169 0018 8823      		tst r24
 2170 001a 01F0      		breq .L313
 572:main.c        ****    asm volatile("jmp 0x7C00");
 2171               		.loc 4 572 0
 2172 001c 0093 BC00 		sts 188,r16
 573:main.c        ****   }
 2173               		.loc 4 573 0
 2174               	/* #APP */
 2175               	 ;  573 "main.c" 1
 2176 0020 0C94 003E 		jmp 0x7C00
 2177               	 ;  0 "" 2
 2178               	/* #NOAPP */
 2179               	.L313:
 578:main.c        **** 
 2180               		.loc 4 578 0
 2181 0024 8091 0000 		lds r24,watchdog
 2182 0028 8130      		cpi r24,lo8(1)
 2183 002a 01F4      		brne .L315
 580:main.c        **** 
 2184               		.loc 4 580 0
 2185 002c 489B      		sbis 0x9,0
 2186 002e 00C0      		rjmp .L316
 580:main.c        **** 
 2187               		.loc 4 580 0 is_stmt 0 discriminator 1
 2188 0030 8091 0000 		lds r24,watchi2c
 2189 0034 9091 0000 		lds r25,watchi2c+1
 2190 0038 0196      		adiw r24,1
 2191 003a 9093 0000 		sts watchi2c+1,r25
 2192 003e 8093 0000 		sts watchi2c,r24
 2193 0042 00C0      		rjmp .L317
 2194               	.L316:
 580:main.c        **** 
 2195               		.loc 4 580 0 discriminator 2
 2196 0044 1092 0000 		sts watchi2c+1,__zero_reg__
 2197 0048 1092 0000 		sts watchi2c,__zero_reg__
 2198 004c 1092 0000 		sts led+1,__zero_reg__
 2199 0050 1092 0000 		sts led,__zero_reg__
 2200 0054 1092 0000 		sts led+2,__zero_reg__
 2201 0058 61E0      		ldi r22,lo8(1)
 2202 005a 70E0      		ldi r23,0
 2203 005c 80E0      		ldi r24,lo8(led)
 2204 005e 90E0      		ldi r25,hi8(led)
 2205 0060 0E94 0000 		call ws2812_setleds
 2206               	.LVL95:
 2207               	.L317:
 582:main.c        ****   }
 2208               		.loc 4 582 0 is_stmt 1
 2209 0064 8091 0000 		lds r24,watchi2c
 2210 0068 9091 0000 		lds r25,watchi2c+1
 2211 006c 8131      		cpi r24,17
 2212 006e 9742      		sbci r25,39
 2213 0070 00F0      		brlo .L315
 582:main.c        ****   }
 2214               		.loc 4 582 0 is_stmt 0 discriminator 1
 2215 0072 F092 0000 		sts led+1,r15
 2216 0076 F092 0000 		sts led,r15
 2217 007a 1092 0000 		sts led+2,__zero_reg__
 2218 007e 61E0      		ldi r22,lo8(1)
 2219 0080 70E0      		ldi r23,0
 2220 0082 80E0      		ldi r24,lo8(led)
 2221 0084 90E0      		ldi r25,hi8(led)
 2222 0086 0E94 0000 		call ws2812_setleds
 2223               	.LVL96:
 2224               	.L315:
 585:main.c        ****   
 2225               		.loc 4 585 0 is_stmt 1
 2226 008a 4999      		sbic 0x9,1
 2227 008c 00C0      		rjmp .L319
 585:main.c        ****   
 2228               		.loc 4 585 0 is_stmt 0 discriminator 1
 2229 008e 8091 0000 		lds r24,i2cerror
 2230 0092 8F5F      		subi r24,lo8(-(1))
 2231 0094 8093 0000 		sts i2cerror,r24
 2232               	.L319:
 587:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 2233               		.loc 4 587 0 is_stmt 1
 2234 0098 8091 0000 		lds r24,i2cerror
 2235 009c 893C      		cpi r24,lo8(-55)
 2236 009e 00F0      		brlo .L320
 588:main.c        ****   I2C_init(I2C_ADDR); 
 2237               		.loc 4 588 0
 2238 00a0 0093 BC00 		sts 188,r16
 589:main.c        ****   i2cerror = 0;
 2239               		.loc 4 589 0
 2240 00a4 8AE2      		ldi r24,lo8(42)
 2241 00a6 0E94 0000 		call I2C_init
 2242               	.LVL97:
 590:main.c        ****   sei();
 2243               		.loc 4 590 0
 2244 00aa 1092 0000 		sts i2cerror,__zero_reg__
 591:main.c        ****   }                    
 2245               		.loc 4 591 0
 2246               	/* #APP */
 2247               	 ;  591 "main.c" 1
 2248 00ae 7894      		sei
 2249               	 ;  0 "" 2
 2250               	/* #NOAPP */
 2251               	.L320:
 594:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 64khz
 2252               		.loc 4 594 0
 2253               	/* #APP */
 2254               	 ;  594 "main.c" 1
 2255 00b0 A895      		wdr
 2256               	 ;  0 "" 2
 595:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 2257               		.loc 4 595 0
 2258               	/* #NOAPP */
 2259 00b2 8091 0000 		lds r24,isrtimer
 2260 00b6 9091 0000 		lds r25,isrtimer+1
 2261 00ba 8331      		cpi r24,19
 2262 00bc 9A47      		sbci r25,122
 2263 00be 00F0      		brlo .L322
 596:main.c        ****   fanspin = 0;
 2264               		.loc 4 596 0
 2265 00c0 2091 0000 		lds r18,fanspin
 2266 00c4 3091 0000 		lds r19,fanspin+1
 2267 00c8 E29E      		mul r14,r18
 2268 00ca C001      		movw r24,r0
 2269 00cc E39E      		mul r14,r19
 2270 00ce 900D      		add r25,r0
 2271 00d0 1124      		clr __zero_reg__
 2272 00d2 9093 0000 		sts rpm+1,r25
 2273 00d6 8093 0000 		sts rpm,r24
 597:main.c        ****   isrtimer = 0;
 2274               		.loc 4 597 0
 2275 00da 1092 0000 		sts fanspin+1,__zero_reg__
 2276 00de 1092 0000 		sts fanspin,__zero_reg__
 598:main.c        ****   if (fanlevel == 254) { //fan minimal auto
 2277               		.loc 4 598 0
 2278 00e2 1092 0000 		sts isrtimer+1,__zero_reg__
 2279 00e6 1092 0000 		sts isrtimer,__zero_reg__
 599:main.c        ****   if (rpm > 1950) {OCR0A++;}
 2280               		.loc 4 599 0
 2281 00ea 2091 0000 		lds r18,fanlevel
 2282 00ee 2E3F      		cpi r18,lo8(-2)
 2283 00f0 01F4      		brne .L322
 600:main.c        ****   if (rpm < 1800) {OCR0A--;}
 2284               		.loc 4 600 0
 2285 00f2 8F39      		cpi r24,-97
 2286 00f4 9740      		sbci r25,7
 2287 00f6 00F0      		brlo .L324
 600:main.c        ****   if (rpm < 1800) {OCR0A--;}
 2288               		.loc 4 600 0 is_stmt 0 discriminator 1
 2289 00f8 87B5      		in r24,0x27
 2290 00fa 8F5F      		subi r24,lo8(-(1))
 2291 00fc 87BD      		out 0x27,r24
 2292               	.L324:
 601:main.c        ****   }
 2293               		.loc 4 601 0 is_stmt 1
 2294 00fe 8091 0000 		lds r24,rpm
 2295 0102 9091 0000 		lds r25,rpm+1
 2296 0106 8830      		cpi r24,8
 2297 0108 9740      		sbci r25,7
 2298 010a 00F4      		brsh .L322
 601:main.c        ****   }
 2299               		.loc 4 601 0 is_stmt 0 discriminator 1
 2300 010c 87B5      		in r24,0x27
 2301 010e 8150      		subi r24,lo8(-(-1))
 2302 0110 87BD      		out 0x27,r24
 2303               	.L322:
 604:main.c        **** 
 2304               		.loc 4 604 0 is_stmt 1
 2305 0112 8091 0000 		lds r24,displaychange
 2306 0116 8823      		tst r24
 2307 0118 01F0      		breq .L325
 604:main.c        **** 
 2308               		.loc 4 604 0 is_stmt 0 discriminator 1
 2309 011a 0E94 0000 		call init_backlight
 2310               	.LVL98:
 2311 011e 1092 0000 		sts displaychange,__zero_reg__
 2312               	.L325:
 606:main.c        ****       ws2812_setleds(led,led_position+1);
 2313               		.loc 4 606 0 is_stmt 1
 2314 0122 8091 0000 		lds r24,changeled
 2315 0126 8823      		tst r24
 2316 0128 01F0      		breq .L326
 607:main.c        ****       changeled = 0;
 2317               		.loc 4 607 0
 2318 012a 6091 0000 		lds r22,led_position
 2319 012e 70E0      		ldi r23,0
 2320 0130 6F5F      		subi r22,-1
 2321 0132 7F4F      		sbci r23,-1
 2322 0134 80E0      		ldi r24,lo8(led)
 2323 0136 90E0      		ldi r25,hi8(led)
 2324 0138 0E94 0000 		call ws2812_setleds
 2325               	.LVL99:
 608:main.c        ****                      }
 2326               		.loc 4 608 0
 2327 013c 1092 0000 		sts changeled,__zero_reg__
 2328               	.L326:
 611:main.c        **** 
 2329               		.loc 4 611 0
 2330 0140 9091 0000 		lds r25,newbllevel
 2331 0144 8091 0000 		lds r24,bllevel
 2332 0148 9817      		cp r25,r24
 2333 014a 01F0      		breq .L327
 611:main.c        **** 
 2334               		.loc 4 611 0 is_stmt 0 discriminator 1
 2335 014c 9032      		cpi r25,lo8(32)
 2336 014e 00F4      		brsh .L327
 613:main.c        **** 
 2337               		.loc 4 613 0 is_stmt 1
 2338 0150 9817      		cp r25,r24
 2339 0152 00F4      		brsh .L328
 613:main.c        **** 
 2340               		.loc 4 613 0 is_stmt 0 discriminator 1
 2341 0154 8150      		subi r24,lo8(-(-1))
 2342 0156 00C0      		rjmp .L352
 2343               	.L328:
 613:main.c        **** 
 2344               		.loc 4 613 0 discriminator 2
 2345 0158 8F5F      		subi r24,lo8(-(1))
 2346               	.L352:
 2347 015a 8093 0000 		sts bllevel,r24
 615:main.c        ****   write_backlight(0b00011111 & bllevel);
 2348               		.loc 4 615 0 is_stmt 1 discriminator 2
 2349 015e 88E5      		ldi r24,lo8(88)
 2350 0160 0E94 0000 		call write_backlight
 2351               	.LVL100:
 616:main.c        ****   }
 2352               		.loc 4 616 0 discriminator 2
 2353 0164 8091 0000 		lds r24,bllevel
 2354 0168 8F71      		andi r24,lo8(31)
 2355 016a 0E94 0000 		call write_backlight
 2356               	.LVL101:
 2357               	.L327:
 622:main.c        ****   
 2358               		.loc 4 622 0
 2359 016e 1A30      		cpi r17,lo8(10)
 2360 0170 00F4      		brsh .L330
 622:main.c        ****   
 2361               		.loc 4 622 0 is_stmt 0 discriminator 1
 2362 0172 1F5F      		subi r17,lo8(-(1))
 2363               	.LVL102:
 624:main.c        ****   {
 2364               		.loc 4 624 0 is_stmt 1 discriminator 1
 2365 0174 812F      		mov r24,r17
 2366 0176 90E0      		ldi r25,0
 2367 0178 FC01      		movw r30,r24
 2368 017a 3197      		sbiw r30,1
 2369 017c EA30      		cpi r30,10
 2370 017e F105      		cpc r31,__zero_reg__
 2371 0180 00F0      		brlo .+2
 2372 0182 00C0      		rjmp .L331
 2373 0184 E050      		subi r30,lo8(-(gs(.L333)))
 2374 0186 F040      		sbci r31,hi8(-(gs(.L333)))
 2375 0188 0C94 0000 		jmp __tablejump2__
 2376               		.section	.progmem.gcc_sw_table,"a",@progbits
 2377               		.p2align	1
 2378               	.L333:
 2379 0030 0000      		.word gs(.L332)
 2380 0032 0000      		.word gs(.L334)
 2381 0034 0000      		.word gs(.L331)
 2382 0036 0000      		.word gs(.L335)
 2383 0038 0000      		.word gs(.L336)
 2384 003a 0000      		.word gs(.L331)
 2385 003c 0000      		.word gs(.L337)
 2386 003e 0000      		.word gs(.L338)
 2387 0040 0000      		.word gs(.L331)
 2388 0042 0000      		.word gs(.L339)
 2389               		.section	.text.startup
 2390               	.L330:
 2391               	.LVL103:
 626:main.c        ****    case 1: a1 = read_analog(6);  break;
 2392               		.loc 4 626 0
 2393 018c 87E0      		ldi r24,lo8(7)
 2394 018e 0E94 0000 		call read_analog
 2395               	.LVL104:
 2396 0192 9093 0000 		sts a0+1,r25
 2397 0196 8093 0000 		sts a0,r24
 2398 019a 10E0      		ldi r17,0
 2399 019c 00C0      		rjmp .L312
 2400               	.LVL105:
 2401               	.L332:
 627:main.c        ****    case 2: a2 = read_analog(5);  break;
 2402               		.loc 4 627 0
 2403 019e 86E0      		ldi r24,lo8(6)
 2404 01a0 0E94 0000 		call read_analog
 2405               	.LVL106:
 2406 01a4 9093 0000 		sts a1+1,r25
 2407 01a8 8093 0000 		sts a1,r24
 2408 01ac 00C0      		rjmp .L312
 2409               	.L334:
 628:main.c        ****    case 4: a3 = read_analog(4);  break; 
 2410               		.loc 4 628 0
 2411 01ae 85E0      		ldi r24,lo8(5)
 2412 01b0 0E94 0000 		call read_analog
 2413               	.LVL107:
 2414 01b4 9093 0000 		sts a2+1,r25
 2415 01b8 8093 0000 		sts a2,r24
 2416 01bc 00C0      		rjmp .L312
 2417               	.L335:
 629:main.c        ****    case 5: a4 = read_analog(1);  break; 
 2418               		.loc 4 629 0
 2419 01be 84E0      		ldi r24,lo8(4)
 2420 01c0 0E94 0000 		call read_analog
 2421               	.LVL108:
 2422 01c4 9093 0000 		sts a3+1,r25
 2423 01c8 8093 0000 		sts a3,r24
 2424 01cc 00C0      		rjmp .L312
 2425               	.L336:
 630:main.c        ****    case 7: a5 = read_analog(0);  break;
 2426               		.loc 4 630 0
 2427 01ce 81E0      		ldi r24,lo8(1)
 2428 01d0 0E94 0000 		call read_analog
 2429               	.LVL109:
 2430 01d4 9093 0000 		sts a4+1,r25
 2431 01d8 8093 0000 		sts a4,r24
 2432 01dc 00C0      		rjmp .L312
 2433               	.L337:
 631:main.c        ****    case 8: vcc = readVcc();  break;
 2434               		.loc 4 631 0
 2435 01de 80E0      		ldi r24,0
 2436 01e0 0E94 0000 		call read_analog
 2437               	.LVL110:
 2438 01e4 9093 0000 		sts a5+1,r25
 2439 01e8 8093 0000 		sts a5,r24
 2440 01ec 00C0      		rjmp .L312
 2441               	.L338:
 632:main.c        ****    case 10: temp = GetTemp();   break;
 2442               		.loc 4 632 0
 2443 01ee 0E94 0000 		call readVcc
 2444               	.LVL111:
 2445 01f2 9093 0000 		sts vcc+1,r25
 2446 01f6 8093 0000 		sts vcc,r24
 2447 01fa 00C0      		rjmp .L312
 2448               	.L339:
 633:main.c        **** 
 2449               		.loc 4 633 0
 2450 01fc 0E94 0000 		call GetTemp
 2451               	.LVL112:
 2452 0200 9093 0000 		sts temp+1,r25
 2453 0204 8093 0000 		sts temp,r24
 2454 0208 00C0      		rjmp .L312
 2455               	.L331:
 636:main.c        ****            if (a7 > a7max) a7max = a7;
 2456               		.loc 4 636 0
 2457 020a 89E0      		ldi r24,lo8(9)
 2458 020c 0E94 0000 		call read_analog
 2459               	.LVL113:
 2460 0210 9093 0000 		sts a7+1,r25
 2461 0214 8093 0000 		sts a7,r24
 637:main.c        ****            if (a7 < a7min) a7min = a7;
 2462               		.loc 4 637 0
 2463 0218 2091 0000 		lds r18,a7max
 2464 021c 3091 0000 		lds r19,a7max+1
 2465 0220 2817      		cp r18,r24
 2466 0222 3907      		cpc r19,r25
 2467 0224 00F4      		brsh .L341
 637:main.c        ****            if (a7 < a7min) a7min = a7;
 2468               		.loc 4 637 0 is_stmt 0 discriminator 1
 2469 0226 9093 0000 		sts a7max+1,r25
 2470 022a 8093 0000 		sts a7max,r24
 2471               	.L341:
 638:main.c        ****            a7count++;
 2472               		.loc 4 638 0 is_stmt 1
 2473 022e 2091 0000 		lds r18,a7min
 2474 0232 3091 0000 		lds r19,a7min+1
 2475 0236 8217      		cp r24,r18
 2476 0238 9307      		cpc r25,r19
 2477 023a 00F4      		brsh .L342
 638:main.c        ****            a7count++;
 2478               		.loc 4 638 0 is_stmt 0 discriminator 1
 2479 023c 9093 0000 		sts a7min+1,r25
 2480 0240 8093 0000 		sts a7min,r24
 2481               	.L342:
 639:main.c        ****            if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max
 2482               		.loc 4 639 0 is_stmt 1
 2483 0244 8091 0000 		lds r24,a7count
 2484 0248 8F5F      		subi r24,lo8(-(1))
 2485 024a 8093 0000 		sts a7count,r24
 2486               		.loc 4 640 0
 2487 024e 8D33      		cpi r24,lo8(61)
 2488 0250 00F4      		brsh .+2
 2489 0252 00C0      		rjmp .L312
 2490               		.loc 4 640 0 is_stmt 0 discriminator 1
 2491 0254 6091 0000 		lds r22,a7max
 2492 0258 7091 0000 		lds r23,a7max+1
 2493 025c 8091 0000 		lds r24,a7min
 2494 0260 9091 0000 		lds r25,a7min+1
 2495 0264 860F      		add r24,r22
 2496 0266 971F      		adc r25,r23
 2497 0268 9695      		lsr r25
 2498 026a 8795      		ror r24
 2499 026c 681B      		sub r22,r24
 2500 026e 790B      		sbc r23,r25
 2501 0270 80E0      		ldi r24,0
 2502 0272 90E0      		ldi r25,0
 2503 0274 0E94 0000 		call __floatunsisf
 2504               	.LVL114:
 2505 0278 24EF      		ldi r18,lo8(-12)
 2506 027a 3DEF      		ldi r19,lo8(-3)
 2507 027c 44E3      		ldi r20,lo8(52)
 2508 027e 5FE3      		ldi r21,lo8(63)
 2509 0280 0E94 0000 		call __mulsf3
 2510               	.LVL115:
 2511 0284 0E94 0000 		call __fixunssfsi
 2512               	.LVL116:
 2513 0288 7093 0000 		sts a7avg+1,r23
 2514 028c 6093 0000 		sts a7avg,r22
 2515 0290 D093 0000 		sts a7min+1,r29
 2516 0294 C093 0000 		sts a7min,r28
 2517 0298 1092 0000 		sts a7max+1,__zero_reg__
 2518 029c 1092 0000 		sts a7max,__zero_reg__
 2519 02a0 1092 0000 		sts a7count,__zero_reg__
 2520 02a4 00C0      		rjmp .L312
 2521               		.cfi_endproc
 2522               	.LFE37:
 2524               	.global	data_lcd_shpi397
 2525               		.data
 2528               	data_lcd_shpi397:
 2529 0000 FF00      		.word	255
 2530 0002 FF01      		.word	511
 2531 0004 9801      		.word	408
 2532 0006 0601      		.word	262
 2533 0008 0401      		.word	260
 2534 000a 0101      		.word	257
 2535 000c 0800      		.word	8
 2536 000e 1001      		.word	272
 2537 0010 2100      		.word	33
 2538 0012 0901      		.word	265
 2539 0014 3000      		.word	48
 2540 0016 0201      		.word	258
 2541 0018 3100      		.word	49
 2542 001a 0001      		.word	256
 2543 001c 4000      		.word	64
 2544 001e 1001      		.word	272
 2545 0020 4100      		.word	65
 2546 0022 5501      		.word	341
 2547 0024 4200      		.word	66
 2548 0026 0201      		.word	258
 2549 0028 4300      		.word	67
 2550 002a 0901      		.word	265
 2551 002c 4400      		.word	68
 2552 002e 0701      		.word	263
 2553 0030 5000      		.word	80
 2554 0032 7801      		.word	376
 2555 0034 5100      		.word	81
 2556 0036 7801      		.word	376
 2557 0038 5200      		.word	82
 2558 003a 0001      		.word	256
 2559 003c 5300      		.word	83
 2560 003e 6D01      		.word	365
 2561 0040 6000      		.word	96
 2562 0042 0701      		.word	263
 2563 0044 6100      		.word	97
 2564 0046 0001      		.word	256
 2565 0048 6200      		.word	98
 2566 004a 0801      		.word	264
 2567 004c 6300      		.word	99
 2568 004e 0001      		.word	256
 2569 0050 A000      		.word	160
 2570 0052 0001      		.word	256
 2571 0054 A100      		.word	161
 2572 0056 0701      		.word	263
 2573 0058 A200      		.word	162
 2574 005a 0C01      		.word	268
 2575 005c A300      		.word	163
 2576 005e 0B01      		.word	267
 2577 0060 A400      		.word	164
 2578 0062 0301      		.word	259
 2579 0064 A500      		.word	165
 2580 0066 0701      		.word	263
 2581 0068 A600      		.word	166
 2582 006a 0601      		.word	262
 2583 006c A700      		.word	167
 2584 006e 0401      		.word	260
 2585 0070 A800      		.word	168
 2586 0072 0801      		.word	264
 2587 0074 A900      		.word	169
 2588 0076 0C01      		.word	268
 2589 0078 AA00      		.word	170
 2590 007a 1301      		.word	275
 2591 007c AB00      		.word	171
 2592 007e 0601      		.word	262
 2593 0080 AC00      		.word	172
 2594 0082 0D01      		.word	269
 2595 0084 AD00      		.word	173
 2596 0086 1901      		.word	281
 2597 0088 AE00      		.word	174
 2598 008a 1001      		.word	272
 2599 008c AF00      		.word	175
 2600 008e 0001      		.word	256
 2601 0090 C000      		.word	192
 2602 0092 0001      		.word	256
 2603 0094 C100      		.word	193
 2604 0096 0701      		.word	263
 2605 0098 C200      		.word	194
 2606 009a 0C01      		.word	268
 2607 009c C300      		.word	195
 2608 009e 0B01      		.word	267
 2609 00a0 C400      		.word	196
 2610 00a2 0301      		.word	259
 2611 00a4 C500      		.word	197
 2612 00a6 0701      		.word	263
 2613 00a8 C600      		.word	198
 2614 00aa 0701      		.word	263
 2615 00ac C700      		.word	199
 2616 00ae 0401      		.word	260
 2617 00b0 C800      		.word	200
 2618 00b2 0801      		.word	264
 2619 00b4 C900      		.word	201
 2620 00b6 0C01      		.word	268
 2621 00b8 CA00      		.word	202
 2622 00ba 1301      		.word	275
 2623 00bc CB00      		.word	203
 2624 00be 0601      		.word	262
 2625 00c0 CC00      		.word	204
 2626 00c2 0D01      		.word	269
 2627 00c4 CD00      		.word	205
 2628 00c6 1801      		.word	280
 2629 00c8 CE00      		.word	206
 2630 00ca 1001      		.word	272
 2631 00cc CF00      		.word	207
 2632 00ce 0001      		.word	256
 2633 00d0 FF00      		.word	255
 2634 00d2 FF01      		.word	511
 2635 00d4 9801      		.word	408
 2636 00d6 0601      		.word	262
 2637 00d8 0401      		.word	260
 2638 00da 0601      		.word	262
 2639 00dc 0000      		.word	0
 2640 00de 2001      		.word	288
 2641 00e0 0100      		.word	1
 2642 00e2 0A01      		.word	266
 2643 00e4 0200      		.word	2
 2644 00e6 0001      		.word	256
 2645 00e8 0300      		.word	3
 2646 00ea 0001      		.word	256
 2647 00ec 0400      		.word	4
 2648 00ee 0101      		.word	257
 2649 00f0 0500      		.word	5
 2650 00f2 0101      		.word	257
 2651 00f4 0600      		.word	6
 2652 00f6 9801      		.word	408
 2653 00f8 0700      		.word	7
 2654 00fa 0601      		.word	262
 2655 00fc 0800      		.word	8
 2656 00fe 0101      		.word	257
 2657 0100 0900      		.word	9
 2658 0102 8001      		.word	384
 2659 0104 0A00      		.word	10
 2660 0106 0001      		.word	256
 2661 0108 0B00      		.word	11
 2662 010a 0001      		.word	256
 2663 010c 0C00      		.word	12
 2664 010e 0101      		.word	257
 2665 0110 0D00      		.word	13
 2666 0112 0101      		.word	257
 2667 0114 0E00      		.word	14
 2668 0116 0001      		.word	256
 2669 0118 0F00      		.word	15
 2670 011a 0001      		.word	256
 2671 011c 1000      		.word	16
 2672 011e F001      		.word	496
 2673 0120 1100      		.word	17
 2674 0122 F401      		.word	500
 2675 0124 1200      		.word	18
 2676 0126 0101      		.word	257
 2677 0128 1300      		.word	19
 2678 012a 0001      		.word	256
 2679 012c 1400      		.word	20
 2680 012e 0001      		.word	256
 2681 0130 1500      		.word	21
 2682 0132 C001      		.word	448
 2683 0134 1600      		.word	22
 2684 0136 0801      		.word	264
 2685 0138 1700      		.word	23
 2686 013a 0001      		.word	256
 2687 013c 1800      		.word	24
 2688 013e 0001      		.word	256
 2689 0140 1900      		.word	25
 2690 0142 0001      		.word	256
 2691 0144 1A00      		.word	26
 2692 0146 0001      		.word	256
 2693 0148 1B00      		.word	27
 2694 014a 0001      		.word	256
 2695 014c 1C00      		.word	28
 2696 014e 0001      		.word	256
 2697 0150 1D00      		.word	29
 2698 0152 0001      		.word	256
 2699 0154 2000      		.word	32
 2700 0156 0101      		.word	257
 2701 0158 2100      		.word	33
 2702 015a 2301      		.word	291
 2703 015c 2200      		.word	34
 2704 015e 4501      		.word	325
 2705 0160 2300      		.word	35
 2706 0162 6701      		.word	359
 2707 0164 2400      		.word	36
 2708 0166 0101      		.word	257
 2709 0168 2500      		.word	37
 2710 016a 2301      		.word	291
 2711 016c 2600      		.word	38
 2712 016e 4501      		.word	325
 2713 0170 2700      		.word	39
 2714 0172 6701      		.word	359
 2715 0174 3000      		.word	48
 2716 0176 1101      		.word	273
 2717 0178 3100      		.word	49
 2718 017a 1101      		.word	273
 2719 017c 3200      		.word	50
 2720 017e 0001      		.word	256
 2721 0180 3300      		.word	51
 2722 0182 EE01      		.word	494
 2723 0184 3400      		.word	52
 2724 0186 FF01      		.word	511
 2725 0188 3500      		.word	53
 2726 018a BB01      		.word	443
 2727 018c 3600      		.word	54
 2728 018e AA01      		.word	426
 2729 0190 3700      		.word	55
 2730 0192 DD01      		.word	477
 2731 0194 3800      		.word	56
 2732 0196 CC01      		.word	460
 2733 0198 3900      		.word	57
 2734 019a 6601      		.word	358
 2735 019c 3A00      		.word	58
 2736 019e 7701      		.word	375
 2737 01a0 3B00      		.word	59
 2738 01a2 2201      		.word	290
 2739 01a4 3C00      		.word	60
 2740 01a6 2201      		.word	290
 2741 01a8 3D00      		.word	61
 2742 01aa 2201      		.word	290
 2743 01ac 3E00      		.word	62
 2744 01ae 2201      		.word	290
 2745 01b0 3F00      		.word	63
 2746 01b2 2201      		.word	290
 2747 01b4 4000      		.word	64
 2748 01b6 2201      		.word	290
 2749 01b8 5200      		.word	82
 2750 01ba 1001      		.word	272
 2751 01bc 5300      		.word	83
 2752 01be 1001      		.word	272
 2753 01c0 FF00      		.word	255
 2754 01c2 FF01      		.word	511
 2755 01c4 9801      		.word	408
 2756 01c6 0601      		.word	262
 2757 01c8 0401      		.word	260
 2758 01ca 0701      		.word	263
 2759 01cc 1800      		.word	24
 2760 01ce 1D01      		.word	285
 2761 01d0 1700      		.word	23
 2762 01d2 2201      		.word	290
 2763 01d4 0200      		.word	2
 2764 01d6 7701      		.word	375
 2765 01d8 2600      		.word	38
 2766 01da B201      		.word	434
 2767 01dc E100      		.word	225
 2768 01de 7901      		.word	377
 2769 01e0 FF00      		.word	255
 2770 01e2 FF01      		.word	511
 2771 01e4 9801      		.word	408
 2772 01e6 0601      		.word	262
 2773 01e8 0401      		.word	260
 2774 01ea 0001      		.word	256
 2775 01ec 3A00      		.word	58
 2776 01ee 6001      		.word	352
 2777 01f0 3500      		.word	53
 2778 01f2 0001      		.word	256
 2779 01f4 1100      		.word	17
 2780 01f6 0001      		.word	256
 2781 01f8 FFFF      		.word	-1
 2782 01fa 2900      		.word	41
 2783 01fc 1300      		.word	19
 2784 01fe 0001      		.word	256
 2785 0200 FFFF      		.word	-1
 2786               	.global	watchi2c
 2787               		.section .bss
 2790               	watchi2c:
 2791 0000 0000      		.zero	2
 2792               	.global	i2cbuffer
 2795               	i2cbuffer:
 2796 0002 0000      		.zero	2
 2797               		.comm	isrtimer,2,1
 2798               		.comm	fanspin,2,1
 2799               		.comm	rpm,2,1
 2800               		.comm	temp,2,1
 2801               		.comm	vcc,2,1
 2802               		.comm	a7min,2,1
 2803               		.comm	a7max,2,1
 2804               		.comm	a7avg,2,1
 2805               		.comm	a7,2,1
 2806               		.comm	a5,2,1
 2807               		.comm	a4,2,1
 2808               		.comm	a3,2,1
 2809               		.comm	a2,2,1
 2810               		.comm	a1,2,1
 2811               		.comm	a0,2,1
 2812               	.global	fanlevel
 2813               		.data
 2816               	fanlevel:
 2817 0202 FE        		.byte	-2
 2818               	.global	i2cerror
 2819               		.section .bss
 2822               	i2cerror:
 2823 0004 00        		.zero	1
 2824               		.comm	crc,1,1
 2825               		.comm	changeled,1,1
 2826               	.global	newbllevel
 2827               		.data
 2830               	newbllevel:
 2831 0203 1F        		.byte	31
 2832               	.global	bllevel
 2835               	bllevel:
 2836 0204 1F        		.byte	31
 2837               		.comm	count,1,1
 2838               	.global	a7count
 2839               		.section .bss
 2842               	a7count:
 2843 0005 00        		.zero	1
 2844               		.comm	buffer_address,1,1
 2845               		.comm	twdrbuffer,1,1
 2846               	.global	commandbyte
 2847               		.data
 2850               	commandbyte:
 2851 0205 FF        		.byte	-1
 2852               	.global	crc_active
 2855               	crc_active:
 2856 0206 01        		.byte	1
 2857               	.global	led_position
 2858               		.section .bss
 2861               	led_position:
 2862 0006 00        		.zero	1
 2863               	.global	display
 2864               		.data
 2867               	display:
 2868 0207 FF        		.byte	-1
 2869               	.global	watchdog
 2870               		.section .bss
 2873               	watchdog:
 2874 0007 00        		.zero	1
 2875               	.global	jumptobootloader
 2878               	jumptobootloader:
 2879 0008 00        		.zero	1
 2880               	.global	displaychange
 2883               	displaychange:
 2884 0009 00        		.zero	1
 2885               		.comm	led,765,1
 2886               		.text
 2887               	.Letext0:
 2888               		.file 7 "/usr/lib/avr/include/stdint.h"
 2889               		.file 8 "light_ws2812.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccTYQV8G.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccTYQV8G.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccTYQV8G.s:4      *ABS*:0000003f __SREG__
     /tmp/ccTYQV8G.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccTYQV8G.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccTYQV8G.s:11     .text:00000000 _crc8_ccitt_update
     /tmp/ccTYQV8G.s:43     .text:00000012 ws2812_sendarray_mask
     /tmp/ccTYQV8G.s:93     .text:00000038 loop59
     /tmp/ccTYQV8G.s:130    .text:00000068 ws2812_setleds_pin
     /tmp/ccTYQV8G.s:167    .text:00000084 ws2812_setleds
     /tmp/ccTYQV8G.s:185    .text:0000008a ws2812_sendarray
     /tmp/ccTYQV8G.s:203    .text:00000090 write_backlight
     /tmp/ccTYQV8G.s:337    .text:0000010a init_backlight
     /tmp/ccTYQV8G.s:2835   .data:00000204 bllevel
     /tmp/ccTYQV8G.s:2830   .data:00000203 newbllevel
     /tmp/ccTYQV8G.s:414    .text:0000014a write_lcd
     /tmp/ccTYQV8G.s:509    .text:0000019e setup_lcd
     /tmp/ccTYQV8G.s:2528   .data:00000000 data_lcd_shpi397
     /tmp/ccTYQV8G.s:590    .text:000001e6 read_analog
     /tmp/ccTYQV8G.s:674    .text:00000254 readVcc
     /tmp/ccTYQV8G.s:746    .text:000002c2 GetTemp
     /tmp/ccTYQV8G.s:811    .text:00000320 freeRam
     /tmp/ccTYQV8G.s:859    .text:0000034e I2C_init
                            *COM*:00000001 buffer_address
     /tmp/ccTYQV8G.s:890    .text:00000364 __vector_9
                            *COM*:00000002 fanspin
     /tmp/ccTYQV8G.s:947    .text:00000398 __vector_23
                            *COM*:00000002 isrtimer
     /tmp/ccTYQV8G.s:994    .text:000003c6 __vector_36
     /tmp/ccTYQV8G.s:2850   .data:00000205 commandbyte
     /tmp/ccTYQV8G.s:2855   .data:00000206 crc_active
                            *COM*:00000001 crc
     /tmp/ccTYQV8G.s:2822   .bss:00000004 i2cerror
                            *COM*:00000002 a0
                            *COM*:00000002 a1
                            *COM*:00000002 a2
                            *COM*:00000002 a3
                            *COM*:00000002 a4
                            *COM*:00000002 a5
                            *COM*:00000002 a7
                            *COM*:00000002 rpm
                            *COM*:00000002 vcc
                            *COM*:00000002 temp
                            *COM*:00000002 a7avg
     /tmp/ccTYQV8G.s:2795   .bss:00000002 i2cbuffer
                            *COM*:00000001 twdrbuffer
     /tmp/ccTYQV8G.s:2883   .bss:00000009 displaychange
     /tmp/ccTYQV8G.s:2867   .data:00000207 display
     /tmp/ccTYQV8G.s:2816   .data:00000202 fanlevel
     /tmp/ccTYQV8G.s:2861   .bss:00000006 led_position
                            *COM*:000002fd led
                            *COM*:00000001 changeled
     /tmp/ccTYQV8G.s:2878   .bss:00000008 jumptobootloader
     /tmp/ccTYQV8G.s:2873   .bss:00000007 watchdog
     /tmp/ccTYQV8G.s:1969   .text:000009c2 setup
     /tmp/ccTYQV8G.s:2140   .text.startup:00000000 main
     /tmp/ccTYQV8G.s:2790   .bss:00000000 watchi2c
                            *COM*:00000002 a7max
                            *COM*:00000002 a7min
     /tmp/ccTYQV8G.s:2842   .bss:00000005 a7count
                            *COM*:00000001 count

UNDEFINED SYMBOLS
__divmodsi4
__brkval
__heap_start
__tablejump2__
__floatunsisf
__mulsf3
__fixunssfsi
__do_copy_data
__do_clear_bss
