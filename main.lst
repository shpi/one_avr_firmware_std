   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_crc8_ccitt_update:
  12               	.LFB4:
  13               		.file 1 "/usr/lib/avr/include/util/crc16.h"
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/lib/avr/include/util/crc16.h **** 
   7:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/lib/avr/include/util/crc16.h **** 
  10:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/lib/avr/include/util/crc16.h **** 
  13:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/lib/avr/include/util/crc16.h ****      distribution.
  17:/usr/lib/avr/include/util/crc16.h **** 
  18:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/lib/avr/include/util/crc16.h **** 
  22:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** /* $Id$ */
  35:/usr/lib/avr/include/util/crc16.h **** 
  36:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/lib/avr/include/util/crc16.h **** 
  41:/usr/lib/avr/include/util/crc16.h **** /** \file */
  42:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/lib/avr/include/util/crc16.h **** 
  45:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par References:
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     \par
  51:/usr/lib/avr/include/util/crc16.h **** 
  52:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     \par
  57:/usr/lib/avr/include/util/crc16.h **** 
  58:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/lib/avr/include/util/crc16.h **** 
  65:/usr/lib/avr/include/util/crc16.h ****     \code
  66:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/lib/avr/include/util/crc16.h **** 
  69:/usr/lib/avr/include/util/crc16.h ****     int
  70:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/lib/avr/include/util/crc16.h ****     {
  72:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/lib/avr/include/util/crc16.h **** 
  74:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/lib/avr/include/util/crc16.h **** 
  77:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/lib/avr/include/util/crc16.h ****     }
  79:/usr/lib/avr/include/util/crc16.h ****     \endcode
  80:/usr/lib/avr/include/util/crc16.h **** */
  81:/usr/lib/avr/include/util/crc16.h **** 
  82:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/lib/avr/include/util/crc16.h **** 
  85:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/lib/avr/include/util/crc16.h **** 
  92:/usr/lib/avr/include/util/crc16.h ****     \code
  93:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  94:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/lib/avr/include/util/crc16.h ****     {
  96:/usr/lib/avr/include/util/crc16.h **** 	int i;
  97:/usr/lib/avr/include/util/crc16.h **** 
  98:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/lib/avr/include/util/crc16.h **** 	{
 101:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/lib/avr/include/util/crc16.h **** 	    else
 104:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/lib/avr/include/util/crc16.h **** 	}
 106:/usr/lib/avr/include/util/crc16.h **** 
 107:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 108:/usr/lib/avr/include/util/crc16.h ****     }
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 111:/usr/lib/avr/include/util/crc16.h **** 
 112:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/lib/avr/include/util/crc16.h **** {
 115:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/lib/avr/include/util/crc16.h **** 
 118:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/lib/avr/include/util/crc16.h **** 	);
 146:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/lib/avr/include/util/crc16.h **** }
 148:/usr/lib/avr/include/util/crc16.h **** 
 149:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/lib/avr/include/util/crc16.h **** 
 152:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/lib/avr/include/util/crc16.h **** 
 159:/usr/lib/avr/include/util/crc16.h ****     \code
 160:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 161:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/lib/avr/include/util/crc16.h ****     {
 163:/usr/lib/avr/include/util/crc16.h ****         int i;
 164:/usr/lib/avr/include/util/crc16.h **** 
 165:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/lib/avr/include/util/crc16.h ****         {
 168:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/lib/avr/include/util/crc16.h ****             else
 171:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/lib/avr/include/util/crc16.h ****         }
 173:/usr/lib/avr/include/util/crc16.h **** 
 174:/usr/lib/avr/include/util/crc16.h ****         return crc;
 175:/usr/lib/avr/include/util/crc16.h ****     }
 176:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 177:/usr/lib/avr/include/util/crc16.h **** 
 178:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/lib/avr/include/util/crc16.h **** {
 181:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/lib/avr/include/util/crc16.h **** 
 186:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 187:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 188:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 189:/usr/lib/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 190:/usr/lib/avr/include/util/crc16.h **** 
 191:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 192:/usr/lib/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 193:/usr/lib/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 194:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 195:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 196:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 197:/usr/lib/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 198:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 199:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 200:/usr/lib/avr/include/util/crc16.h **** 
 201:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 202:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 203:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 204:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 205:/usr/lib/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 206:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 207:/usr/lib/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 208:/usr/lib/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 209:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 211:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 212:/usr/lib/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 213:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 214:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 215:/usr/lib/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 216:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 217:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 218:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 219:/usr/lib/avr/include/util/crc16.h ****     );
 220:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 221:/usr/lib/avr/include/util/crc16.h **** }
 222:/usr/lib/avr/include/util/crc16.h **** 
 223:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 224:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-CCITT calculation.
 225:/usr/lib/avr/include/util/crc16.h **** 
 226:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x8408)<br>
 227:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
 228:/usr/lib/avr/include/util/crc16.h **** 
 229:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by PPP and IrDA.
 230:/usr/lib/avr/include/util/crc16.h **** 
 231:/usr/lib/avr/include/util/crc16.h ****     See RFC1171 (PPP protocol) and IrDA IrLAP 1.1
 232:/usr/lib/avr/include/util/crc16.h **** 
 233:/usr/lib/avr/include/util/crc16.h ****     \note Although the CCITT polynomial is the same as that used by the Xmodem
 234:/usr/lib/avr/include/util/crc16.h ****     protocol, they are quite different. The difference is in how the bits are
 235:/usr/lib/avr/include/util/crc16.h ****     shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
 236:/usr/lib/avr/include/util/crc16.h ****     input first, while CCITT shifts the LSB of the CRC and the input first.
 237:/usr/lib/avr/include/util/crc16.h **** 
 238:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 239:/usr/lib/avr/include/util/crc16.h **** 
 240:/usr/lib/avr/include/util/crc16.h ****     \code
 241:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 242:/usr/lib/avr/include/util/crc16.h ****     crc_ccitt_update (uint16_t crc, uint8_t data)
 243:/usr/lib/avr/include/util/crc16.h ****     {
 244:/usr/lib/avr/include/util/crc16.h ****         data ^= lo8 (crc);
 245:/usr/lib/avr/include/util/crc16.h ****         data ^= data << 4;
 246:/usr/lib/avr/include/util/crc16.h **** 
 247:/usr/lib/avr/include/util/crc16.h ****         return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
 248:/usr/lib/avr/include/util/crc16.h ****                 ^ ((uint16_t)data << 3));
 249:/usr/lib/avr/include/util/crc16.h ****     }
 250:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 251:/usr/lib/avr/include/util/crc16.h **** 
 252:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 253:/usr/lib/avr/include/util/crc16.h **** _crc_ccitt_update (uint16_t __crc, uint8_t __data)
 254:/usr/lib/avr/include/util/crc16.h **** {
 255:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;
 256:/usr/lib/avr/include/util/crc16.h **** 
 257:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 258:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%1"          "\n\t"
 259:/usr/lib/avr/include/util/crc16.h **** 
 260:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%A0" "\n\t"
 261:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 262:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0xf0"        "\n\t"
 263:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__" "\n\t"
 264:/usr/lib/avr/include/util/crc16.h **** 
 265:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 266:/usr/lib/avr/include/util/crc16.h **** 
 267:/usr/lib/avr/include/util/crc16.h ****         "mov    %B0,%A0"         "\n\t"
 268:/usr/lib/avr/include/util/crc16.h **** 
 269:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 270:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0x0f"        "\n\t"
 271:/usr/lib/avr/include/util/crc16.h ****         "eor    __tmp_reg__,%A0" "\n\t"
 272:/usr/lib/avr/include/util/crc16.h **** 
 273:/usr/lib/avr/include/util/crc16.h ****         "lsr    %A0"             "\n\t"
 274:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t"
 275:/usr/lib/avr/include/util/crc16.h **** 
 276:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%B0"         "\n\t"
 277:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 278:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 279:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 280:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__"
 281:/usr/lib/avr/include/util/crc16.h **** 
 282:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret)
 283:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 284:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 285:/usr/lib/avr/include/util/crc16.h ****     );
 286:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 287:/usr/lib/avr/include/util/crc16.h **** }
 288:/usr/lib/avr/include/util/crc16.h **** 
 289:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 290:/usr/lib/avr/include/util/crc16.h ****     Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
 291:/usr/lib/avr/include/util/crc16.h **** 
 292:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
 293:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 294:/usr/lib/avr/include/util/crc16.h **** 
 295:/usr/lib/avr/include/util/crc16.h ****     See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 296:/usr/lib/avr/include/util/crc16.h **** 
 297:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 298:/usr/lib/avr/include/util/crc16.h **** 
 299:/usr/lib/avr/include/util/crc16.h ****     \code
 300:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 301:/usr/lib/avr/include/util/crc16.h ****     _crc_ibutton_update(uint8_t crc, uint8_t data)
 302:/usr/lib/avr/include/util/crc16.h ****     {
 303:/usr/lib/avr/include/util/crc16.h **** 	uint8_t i;
 304:/usr/lib/avr/include/util/crc16.h **** 
 305:/usr/lib/avr/include/util/crc16.h **** 	crc = crc ^ data;
 306:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; i++)
 307:/usr/lib/avr/include/util/crc16.h **** 	{
 308:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 0x01)
 309:/usr/lib/avr/include/util/crc16.h **** 	        crc = (crc >> 1) ^ 0x8C;
 310:/usr/lib/avr/include/util/crc16.h **** 	    else
 311:/usr/lib/avr/include/util/crc16.h **** 	        crc >>= 1;
 312:/usr/lib/avr/include/util/crc16.h **** 	}
 313:/usr/lib/avr/include/util/crc16.h **** 
 314:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 315:/usr/lib/avr/include/util/crc16.h ****     }
 316:/usr/lib/avr/include/util/crc16.h ****     \endcode
 317:/usr/lib/avr/include/util/crc16.h **** */
 318:/usr/lib/avr/include/util/crc16.h **** 
 319:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 320:/usr/lib/avr/include/util/crc16.h **** _crc_ibutton_update(uint8_t __crc, uint8_t __data)
 321:/usr/lib/avr/include/util/crc16.h **** {
 322:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __i, __pattern;
 323:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 324:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %4" "\n\t"
 325:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%1, 8" "\n\t"
 326:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%2, 0x8C" "\n\t"
 327:/usr/lib/avr/include/util/crc16.h **** 		"1:	lsr	%0" "\n\t"
 328:/usr/lib/avr/include/util/crc16.h **** 		"	brcc	2f" "\n\t"
 329:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %2" "\n\t"
 330:/usr/lib/avr/include/util/crc16.h **** 		"2:	dec	%1" "\n\t"
 331:/usr/lib/avr/include/util/crc16.h **** 		"	brne	1b" "\n\t"
 332:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
 333:/usr/lib/avr/include/util/crc16.h **** 		: "0" (__crc), "r" (__data));
 334:/usr/lib/avr/include/util/crc16.h **** 	return __crc;
 335:/usr/lib/avr/include/util/crc16.h **** }
 336:/usr/lib/avr/include/util/crc16.h **** 
 337:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 338:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-8-CCITT calculation.
 339:/usr/lib/avr/include/util/crc16.h **** 
 340:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
 341:/usr/lib/avr/include/util/crc16.h ****     
 342:/usr/lib/avr/include/util/crc16.h ****     For use with simple CRC-8<br>
 343:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 344:/usr/lib/avr/include/util/crc16.h ****     
 345:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ROHC<br>
 346:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 347:/usr/lib/avr/include/util/crc16.h ****     Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
 348:/usr/lib/avr/include/util/crc16.h ****     
 349:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ATM/ITU<br>
 350:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 351:/usr/lib/avr/include/util/crc16.h ****     Final XOR value: 0x55<br>
 352:/usr/lib/avr/include/util/crc16.h ****     Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
 353:/usr/lib/avr/include/util/crc16.h ****     
 354:/usr/lib/avr/include/util/crc16.h ****     The C equivalent has been originally written by Dave Hylands.
 355:/usr/lib/avr/include/util/crc16.h ****     Assembly code is based on _crc_ibutton_update optimization.
 356:/usr/lib/avr/include/util/crc16.h **** 
 357:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 358:/usr/lib/avr/include/util/crc16.h **** 
 359:/usr/lib/avr/include/util/crc16.h ****     \code
 360:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 361:/usr/lib/avr/include/util/crc16.h ****     _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
 362:/usr/lib/avr/include/util/crc16.h ****     {
 363:/usr/lib/avr/include/util/crc16.h ****         uint8_t   i;
 364:/usr/lib/avr/include/util/crc16.h ****         uint8_t   data;
 365:/usr/lib/avr/include/util/crc16.h **** 
 366:/usr/lib/avr/include/util/crc16.h ****         data = inCrc ^ inData;
 367:/usr/lib/avr/include/util/crc16.h **** 
 368:/usr/lib/avr/include/util/crc16.h ****         for ( i = 0; i < 8; i++ )
 369:/usr/lib/avr/include/util/crc16.h ****         {
 370:/usr/lib/avr/include/util/crc16.h ****             if (( data & 0x80 ) != 0 )
 371:/usr/lib/avr/include/util/crc16.h ****             {
 372:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 373:/usr/lib/avr/include/util/crc16.h ****                 data ^= 0x07;
 374:/usr/lib/avr/include/util/crc16.h ****             }
 375:/usr/lib/avr/include/util/crc16.h ****             else
 376:/usr/lib/avr/include/util/crc16.h ****             {
 377:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 378:/usr/lib/avr/include/util/crc16.h ****             }
 379:/usr/lib/avr/include/util/crc16.h ****         }
 380:/usr/lib/avr/include/util/crc16.h ****         return data;
 381:/usr/lib/avr/include/util/crc16.h ****     }
 382:/usr/lib/avr/include/util/crc16.h ****     \endcode
 383:/usr/lib/avr/include/util/crc16.h **** */
 384:/usr/lib/avr/include/util/crc16.h **** 
 385:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 386:/usr/lib/avr/include/util/crc16.h **** _crc8_ccitt_update(uint8_t __crc, uint8_t __data)
 387:/usr/lib/avr/include/util/crc16.h **** {
  14               		.loc 1 387 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 388:/usr/lib/avr/include/util/crc16.h ****     uint8_t __i, __pattern;
 389:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
  21               		.loc 1 389 0
  22               	/* #APP */
  23               	 ;  389 "/usr/lib/avr/include/util/crc16.h" 1
  24 0000 8627      		    eor    r24, r22
  25 0002 98E0      		    ldi    r25, 8
  26 0004 67E0      		    ldi    r22, 0x07
  27 0006 880F      		1:  lsl    r24
  28 0008 00F4      		    brcc   2f
  29 000a 8627      		    eor    r24, r22
  30 000c 9A95      		2:  dec    r25
  31 000e 01F4      		    brne   1b
  32               		
  33               	 ;  0 "" 2
  34               	.LVL1:
 390:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %4" "\n\t"
 391:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %1, 8" "\n\t"
 392:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %2, 0x07" "\n\t"
 393:/usr/lib/avr/include/util/crc16.h ****         "1:  lsl    %0" "\n\t"
 394:/usr/lib/avr/include/util/crc16.h ****         "    brcc   2f" "\n\t"
 395:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %2" "\n\t"
 396:/usr/lib/avr/include/util/crc16.h ****         "2:  dec    %1" "\n\t"
 397:/usr/lib/avr/include/util/crc16.h ****         "    brne   1b" "\n\t"
 398:/usr/lib/avr/include/util/crc16.h ****         : "=r" (__crc), "=d" (__i), "=d" (__pattern)
 399:/usr/lib/avr/include/util/crc16.h ****         : "0" (__crc), "r" (__data));
 400:/usr/lib/avr/include/util/crc16.h ****     return __crc;
 401:/usr/lib/avr/include/util/crc16.h **** }
  35               		.loc 1 401 0
  36               	/* #NOAPP */
  37 0010 0895      		ret
  38               		.cfi_endproc
  39               	.LFE4:
  41               	.global	ws2812_sendarray_mask
  43               	ws2812_sendarray_mask:
  44               	.LFB23:
  45               		.file 2 "light_ws2812.c"
   1:light_ws2812.c **** /*
   2:light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:light_ws2812.c **** *
   4:light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:light_ws2812.c **** *
   7:light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:light_ws2812.c **** *
   9:light_ws2812.c **** *
  10:light_ws2812.c **** * Jun 2019, modified for SHPI by Lutz Harder
  11:light_ws2812.c **** * License: GNU GPL v2+ (see License.txt)
  12:light_ws2812.c **** */
  13:light_ws2812.c **** 
  14:light_ws2812.c **** #include "light_ws2812.h"
  15:light_ws2812.c **** #include <avr/interrupt.h>
  16:light_ws2812.c **** #include <avr/io.h>
  17:light_ws2812.c **** #include <util/delay.h>
  18:light_ws2812.c ****  
  19:light_ws2812.c **** // Setleds for standard RGB 
  20:light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  21:light_ws2812.c **** {
  22:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  23:light_ws2812.c **** }
  24:light_ws2812.c **** 
  25:light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  26:light_ws2812.c **** {
  27:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  28:light_ws2812.c ****   _delay_us(ws2812_resettime);
  29:light_ws2812.c **** }
  30:light_ws2812.c **** 
  31:light_ws2812.c **** 
  32:light_ws2812.c **** 
  33:light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  34:light_ws2812.c **** {
  35:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  36:light_ws2812.c **** }
  37:light_ws2812.c **** 
  38:light_ws2812.c **** /*
  39:light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  40:light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  41:light_ws2812.c **** */
  42:light_ws2812.c **** 
  43:light_ws2812.c **** // Timing in ns
  44:light_ws2812.c **** #define w_zeropulse   350
  45:light_ws2812.c **** #define w_onepulse    900
  46:light_ws2812.c **** #define w_totalperiod 120
  47:light_ws2812.c **** 
  48:light_ws2812.c **** // Fixed cycles used by the inner loop
  49:light_ws2812.c **** #define w_fixedlow    2
  50:light_ws2812.c **** #define w_fixedhigh   4
  51:light_ws2812.c **** #define w_fixedtotal  8   
  52:light_ws2812.c **** 
  53:light_ws2812.c **** // Insert NOPs to match the timing, if possible
  54:light_ws2812.c **** #define w_zerocycles    (((F_CPU/1000)*w_zeropulse          )/1000000)
  55:light_ws2812.c **** #define w_onecycles     (((F_CPU/1000)*w_onepulse    +500000)/1000000)
  56:light_ws2812.c **** #define w_totalcycles   (((F_CPU/1000)*w_totalperiod +500000)/1000000)
  57:light_ws2812.c **** 
  58:light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  59:light_ws2812.c **** #define w1 (w_zerocycles-w_fixedlow)
  60:light_ws2812.c **** // w2   nops between fe low and fe high
  61:light_ws2812.c **** #define w2 (w_onecycles-w_fixedhigh-w1)
  62:light_ws2812.c **** // w3   nops to complete loop
  63:light_ws2812.c **** #define w3 (w_totalcycles-w_fixedtotal-w1-w2)
  64:light_ws2812.c **** 
  65:light_ws2812.c **** #if w1>0
  66:light_ws2812.c ****   #define w1_nops w1
  67:light_ws2812.c **** #else
  68:light_ws2812.c ****   #define w1_nops  0
  69:light_ws2812.c **** #endif
  70:light_ws2812.c **** 
  71:light_ws2812.c **** // The only critical timing parameter is the minimum pulse length of the "0"
  72:light_ws2812.c **** // Warn or throw error if this timing can not be met with current F_CPU settings.
  73:light_ws2812.c **** #define w_lowtime ((w1_nops+w_fixedlow)*1000000)/(F_CPU/1000)
  74:light_ws2812.c **** #if w_lowtime>550
  75:light_ws2812.c ****    #error "Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?"
  76:light_ws2812.c **** #elif w_lowtime>450
  77:light_ws2812.c ****    #warning "Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S)."
  78:light_ws2812.c ****    #warning "Please consider a higher clockspeed, if possible"
  79:light_ws2812.c **** #endif   
  80:light_ws2812.c **** 
  81:light_ws2812.c **** #if w2>0
  82:light_ws2812.c **** #define w2_nops w2
  83:light_ws2812.c **** #else
  84:light_ws2812.c **** #define w2_nops  0
  85:light_ws2812.c **** #endif
  86:light_ws2812.c **** 
  87:light_ws2812.c **** #if w3>0
  88:light_ws2812.c **** #define w3_nops w3
  89:light_ws2812.c **** #else
  90:light_ws2812.c **** #define w3_nops  0
  91:light_ws2812.c **** #endif
  92:light_ws2812.c **** 
  93:light_ws2812.c **** #define w_nop1  "nop      \n\t"
  94:light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
  95:light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
  96:light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
  97:light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
  98:light_ws2812.c **** 
  99:light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 100:light_ws2812.c **** {
  46               		.loc 2 100 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 101:light_ws2812.c ****   uint8_t curbyte,ctr,masklo;
 102:light_ws2812.c ****   uint8_t sreg_prev;
 103:light_ws2812.c ****   
 104:light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  53               		.loc 2 104 0
  54 0012 2AB1      		in r18,0xa
  55 0014 242B      		or r18,r20
  56 0016 2AB9      		out 0xa,r18
 105:light_ws2812.c ****   
 106:light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  57               		.loc 2 106 0
  58 0018 2BB1      		in r18,0xb
  59 001a 342F      		mov r19,r20
  60 001c 3095      		com r19
  61 001e 2323      		and r18,r19
  62               	.LVL3:
 107:light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  63               		.loc 2 107 0
  64 0020 3BB1      		in r19,0xb
  65 0022 432B      		or r20,r19
  66               	.LVL4:
 108:light_ws2812.c ****   
 109:light_ws2812.c ****   sreg_prev=SREG;
  67               		.loc 2 109 0
  68 0024 3FB7      		in r19,__SREG__
  69               	.LVL5:
 110:light_ws2812.c ****   cli();  
  70               		.loc 2 110 0
  71               	/* #APP */
  72               	 ;  110 "light_ws2812.c" 1
  73 0026 F894      		cli
  74               	 ;  0 "" 2
  75               	/* #NOAPP */
  76 0028 FC01      		movw r30,r24
  77 002a 680F      		add r22,r24
  78 002c 791F      		adc r23,r25
  79               	.LVL6:
  80               	.L3:
 111:light_ws2812.c **** 
 112:light_ws2812.c ****   while (datlen--) {
  81               		.loc 2 112 0
  82 002e E617      		cp r30,r22
  83 0030 F707      		cpc r31,r23
  84 0032 01F0      		breq .L6
  85               	.LVL7:
 113:light_ws2812.c ****     curbyte=*data++;
  86               		.loc 2 113 0
  87 0034 8191      		ld r24,Z+
  88               	.LVL8:
 114:light_ws2812.c ****     
 115:light_ws2812.c ****     asm volatile(
  89               		.loc 2 115 0
  90               	/* #APP */
  91               	 ;  115 "light_ws2812.c" 1
  92 0036 98E0      		       ldi   r25,8  
  93               		loop59:            
  94 0038 4BB9      		       out   11,r20 
  95 003a 0000      		nop      
  96 003c 00C0      		rjmp .+0 
  97 003e 87FF      		       sbrs  r24,7  
  98 0040 2BB9      		       out   11,r18 
  99 0042 880F      		       lsl   r24    
 100 0044 0000      		nop      
 101 0046 00C0      		rjmp .+0 
 102 0048 00C0      		rjmp .+0 
 103 004a 00C0      		rjmp .+0 
 104 004c 2BB9      		       out   11,r18 
 105 004e 00C0      		rjmp .+0 
 106 0050 00C0      		rjmp .+0 
 107 0052 00C0      		rjmp .+0 
 108 0054 00C0      		rjmp .+0 
 109 0056 00C0      		rjmp .+0 
 110 0058 00C0      		rjmp .+0 
 111 005a 00C0      		rjmp .+0 
 112 005c 00C0      		rjmp .+0 
 113 005e 9A95      		       dec   r25    
 114 0060 01F4      		       brne  loop59
 115               		
 116               	 ;  0 "" 2
 117               	.LVL9:
 118               	/* #NOAPP */
 119 0062 00C0      		rjmp .L3
 120               	.LVL10:
 121               	.L6:
 116:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 117:light_ws2812.c ****     "loop%=:            \n\t"
 118:light_ws2812.c ****     "       out   %2,%3 \n\t"    
 119:light_ws2812.c **** #if (w1_nops&1)
 120:light_ws2812.c **** w_nop1
 121:light_ws2812.c **** #endif
 122:light_ws2812.c **** #if (w1_nops&2)
 123:light_ws2812.c **** w_nop2
 124:light_ws2812.c **** #endif
 125:light_ws2812.c **** #if (w1_nops&4)
 126:light_ws2812.c **** w_nop4
 127:light_ws2812.c **** #endif
 128:light_ws2812.c **** #if (w1_nops&8)
 129:light_ws2812.c **** w_nop8
 130:light_ws2812.c **** #endif
 131:light_ws2812.c **** #if (w1_nops&16)
 132:light_ws2812.c **** w_nop16
 133:light_ws2812.c **** #endif
 134:light_ws2812.c ****     "       sbrs  %1,7  \n\t"   
 135:light_ws2812.c ****     "       out   %2,%4 \n\t"  
 136:light_ws2812.c ****     "       lsl   %1    \n\t"   
 137:light_ws2812.c **** #if (w2_nops&1)
 138:light_ws2812.c ****   w_nop1
 139:light_ws2812.c **** #endif
 140:light_ws2812.c **** #if (w2_nops&2)
 141:light_ws2812.c ****   w_nop2
 142:light_ws2812.c **** #endif
 143:light_ws2812.c **** #if (w2_nops&4)
 144:light_ws2812.c ****   w_nop4
 145:light_ws2812.c **** #endif
 146:light_ws2812.c **** #if (w2_nops&8)
 147:light_ws2812.c ****   w_nop8
 148:light_ws2812.c **** #endif
 149:light_ws2812.c **** #if (w2_nops&16)
 150:light_ws2812.c ****   w_nop16 
 151:light_ws2812.c **** #endif
 152:light_ws2812.c ****     "       out   %2,%4 \n\t"   
 153:light_ws2812.c **** #if (w3_nops&1)
 154:light_ws2812.c **** w_nop1
 155:light_ws2812.c **** #endif
 156:light_ws2812.c **** #if (w3_nops&2)
 157:light_ws2812.c **** w_nop2
 158:light_ws2812.c **** #endif
 159:light_ws2812.c **** #if (w3_nops&4)
 160:light_ws2812.c **** w_nop4
 161:light_ws2812.c **** #endif
 162:light_ws2812.c **** #if (w3_nops&8)
 163:light_ws2812.c **** w_nop8
 164:light_ws2812.c **** #endif
 165:light_ws2812.c **** #if (w3_nops&16)
 166:light_ws2812.c **** w_nop16
 167:light_ws2812.c **** #endif
 168:light_ws2812.c **** 
 169:light_ws2812.c ****     "       dec   %0    \n\t"   
 170:light_ws2812.c ****     "       brne  loop%=\n\t"   
 171:light_ws2812.c ****     :	"=&d" (ctr)
 172:light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 173:light_ws2812.c ****     );
 174:light_ws2812.c ****   }
 175:light_ws2812.c ****   
 176:light_ws2812.c ****   SREG=sreg_prev;
 122               		.loc 2 176 0
 123 0064 3FBF      		out __SREG__,r19
 124 0066 0895      		ret
 125               		.cfi_endproc
 126               	.LFE23:
 128               	.global	ws2812_setleds_pin
 130               	ws2812_setleds_pin:
 131               	.LFB21:
  26:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 132               		.loc 2 26 0
 133               		.cfi_startproc
 134               	.LVL11:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 139               		.loc 2 27 0
 140 0068 9B01      		movw r18,r22
 141 006a 220F      		lsl r18
 142 006c 331F      		rol r19
 143 006e 620F      		add r22,r18
 144 0070 731F      		adc r23,r19
 145               	.LVL12:
 146 0072 0E94 0000 		call ws2812_sendarray_mask
 147               	.LVL13:
 148               	.LBB45:
 149               	.LBB46:
 150               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 151               		.loc 3 276 0
 152 0076 8FEA      		ldi r24,lo8(1199)
 153 0078 94E0      		ldi r25,hi8(1199)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL14:
 159 0082 0895      		ret
 160               	.LBE46:
 161               	.LBE45:
 162               		.cfi_endproc
 163               	.LFE21:
 165               	.global	ws2812_setleds
 167               	ws2812_setleds:
 168               	.LFB20:
  21:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 169               		.loc 2 21 0
 170               		.cfi_startproc
 171               	.LVL15:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  22:light_ws2812.c **** }
 176               		.loc 2 22 0
 177 0084 40E2      		ldi r20,lo8(32)
 178 0086 0C94 0000 		jmp ws2812_setleds_pin
 179               	.LVL16:
 180               		.cfi_endproc
 181               	.LFE20:
 183               	.global	ws2812_sendarray
 185               	ws2812_sendarray:
 186               	.LFB22:
  34:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 187               		.loc 2 34 0
 188               		.cfi_startproc
 189               	.LVL17:
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 0 */
 193               	.L__stack_usage = 0
  35:light_ws2812.c **** }
 194               		.loc 2 35 0
 195 008a 40E2      		ldi r20,lo8(32)
 196 008c 0C94 0000 		jmp ws2812_sendarray_mask
 197               	.LVL18:
 198               		.cfi_endproc
 199               	.LFE22:
 201               	.global	writebl
 203               	writebl:
 204               	.LFB24:
 205               		.file 4 "main.c"
   1:main.c        **** /*
   2:main.c        **** *  SHPI.one Basic Firmware v1.2 BETA 
   3:main.c        **** *  
   4:main.c        **** * 
   5:main.c        **** *
   6:main.c        **** * Basic Firmware for ATmega32u4 slave,  no radio module support included
   7:main.c        **** *
   8:main.c        **** * Jul    15th, 2019  v 1.1b initial Version
   9:main.c        **** * October 4th, 2019  v1.2  Beta
  10:main.c        **** *    NEW: implemented CRC Check via CRC8  CCITT
  11:main.c        **** *
  12:main.c        **** *
  13:main.c        **** *   I2C Command Reference     (SLAVE ADDRESS 0x2A)
  14:main.c        **** *
  15:main.c        **** *   ACTIVE COMMANDS
  16:main.c        **** *
  17:main.c        **** *   0x87 set backlight level of LCD   0-31  // i2cset -y 2 0x2A 0x87 31 +CRC
  18:main.c        **** *OLD:  0x8C  set RGB value of LED              // i2cset -y 2 0x2A 0x8C 0xRR 0xGG 0xBB +CRC i      
  19:main.c        **** *   0x8D  set Relay 1                       // i2cset -y 2 0x2A 0x8D 0x00 +CRC                     
  20:main.c        **** *   0x8E  set Relay 2                       // i2cset -y 2 0x2A 0x8E 0x00 +CRC                    (
  21:main.c        **** *   0x8F  set Relay 3                       // i2cset -y 2 0x2A 0x8F 0x00 +CRC                    (
  22:main.c        **** *   0x90  set D13 / PC7                     // i2cset -y 2 0x2A 0x90 0x00 +CRC                    (
  23:main.c        **** *   0x91  set HWB / PE2                     // i2cset -y 2 0x2A 0x91 0x00 +CRC                    (
  24:main.c        **** *   0x92  set Buzzer / PB5                  // i2cset -y 2 0x2A 0x92 0x00 +CRC                    (
  25:main.c        **** *   0x93  set Vent power                    // i2cset -y 2 0x2A 0x93 0x00 +CRC                    (
  26:main.c        **** *   0x94  set R color
  27:main.c        **** *   0x95  set G color
  28:main.c        **** *   0x96  set B color 
  29:main.c        **** *
  30:main.c        **** *
  31:main.c        **** *  READOUT VALUES
  32:main.c        **** *
  33:main.c        **** *
  34:main.c        **** *   0x00  read A0                           // i2cset -y 2 0x2A 0x00                    
  35:main.c        **** *                                           // i2cget -y 2 0x2A         -> frst low byte
  36:main.c        **** *                                           // i2cget -y 2 0x2A         -> scnd high byte
  37:main.c        **** *
  38:main.c        **** *   0x01  read A1 
  39:main.c        **** *   0x02  read A2 
  40:main.c        **** *   0x03  read A3 
  41:main.c        **** *   0x04  read A4 
  42:main.c        **** *   0x05  read A5 
  43:main.c        **** *   0x06  read A7 
  44:main.c        **** *
  45:main.c        **** *   0x07  read actual backlight level       // i2cget -y 2 0x2A 0x07
  46:main.c        **** *                                             -> only one byte response
  47:main.c        **** *
  48:main.c        **** *
  49:main.c        **** *   0x08  read actual RPM von vent         // i2cset -y 2 0x2A 0x08
  50:main.c        **** *                                          // i2cget -y 2 0x2A         -> frst low byte
  51:main.c        **** *                                          // i2cget -y 2 0x2A         -> scnd high byte
  52:main.c        **** *
  53:main.c        **** *   0x09 read supply voltage of ATmega     // i2cset -y 2 0x2A 0x09                    
  54:main.c        **** *                                          // i2cget -y 2 0x2A         -> frst low byte
  55:main.c        **** *                                          // i2cget -y 2 0x2A         -> scnd high byte
  56:main.c        **** *
  57:main.c        **** *
  58:main.c        **** *
  59:main.c        **** *
  60:main.c        **** *   0x0A read internal ATmega temp         // i2cset -y 2 0x2A 0x0A                    
  61:main.c        **** *                                          // i2cget -y 2 0x2A         -> frst low byte
  62:main.c        **** *                                          // i2cget -y 2 0x2A         -> scnd high byte
  63:main.c        **** *
  64:main.c        **** *
  65:main.c        **** *   0x0B read free RAM ATmega              // i2cset -y 2 0x2A 0x0B                    
  66:main.c        **** *                                          // i2cget -y 2 0x2A         -> frst low byte
  67:main.c        **** *                                          // i2cget -y 2 0x2A         -> scnd high byte
  68:main.c        **** *
  69:main.c        **** *
  70:main.c        **** *   0x0C read RGB values from LED           // i2cset -y 2 0x2A 0x0C                    
  71:main.c        **** *                                          // i2cget -y 2 0x2A         -> red byte
  72:main.c        **** *                                          // i2cget -y 2 0x2A         -> green byte
  73:main.c        **** *                                          // i2cget -y 2 0x2A         -> blue byte
  74:main.c        **** *
  75:main.c        **** *
  76:main.c        **** *                                         
  77:main.c        **** *   0x0D  read relay 1                      // i2cget -y 2 0x2A 0x0D 
  78:main.c        **** *   0x0E  read relay 2                      // i2cget -y 2 0x2A 0x0E 
  79:main.c        **** *   0x0F  read relay 3                      // i2cget -y 2 0x2A 0x0F 
  80:main.c        **** *   0x10  read D13                         // i2cget -y 2 0x2A 0x10 
  81:main.c        **** *   0x11  read HWB                         // i2cget -y 2 0x2A 0x11 
  82:main.c        **** *   0x12  read Buzzer                      // i2cget -y 2 0x2A 0x12 
  83:main.c        **** *   0x13  read VENT PWM value              // i2cget -y 2 0x2A 0x13    
  84:main.c        **** *   0x14  read AVG A7 for AC currents 
  85:main.c        **** *
  86:main.c        **** *
  87:main.c        **** *
  88:main.c        **** *
  89:main.c        **** *
  90:main.c        **** * Author: Lutz Harder
  91:main.c        **** * License: GNU GPL
  92:main.c        **** */
  93:main.c        **** 
  94:main.c        **** #include <util/crc16.h>
  95:main.c        **** #include <avr/wdt.h>
  96:main.c        **** #include <avr/power.h>
  97:main.c        **** #include <avr/io.h>
  98:main.c        **** #include <stdlib.h>
  99:main.c        **** #define DELAY 100
 100:main.c        **** #define WAIT 120
 101:main.c        **** #include <util/delay.h>
 102:main.c        **** #include <avr/interrupt.h>
 103:main.c        **** #include <stdint.h>
 104:main.c        **** #include <util/twi.h>
 105:main.c        **** #define ws2812_resettime  300 
 106:main.c        **** #define ws2812_port D   
 107:main.c        **** #define ws2812_pin  5   
 108:main.c        **** #include "light_ws2812.c"
 109:main.c        **** #include "light_ws2812.h"
 110:main.c        **** struct cRGB led[1];
 111:main.c        **** #define I2C_ADDR 0x2A
 112:main.c        **** #define SDA_LINE  (PIND & (1<<PD1))
 113:main.c        **** 
 114:main.c        **** uint8_t commandbyte = 0xFF,twdrbuffer, buffer_address,a7count = 0,count,bllevel = 31,newbllevel = 3
 115:main.c        **** uint16_t a0,a1,a2,a3,a4,a5,a7,a7avg,a7max,a7min,vcc,temp,rpm,fanspin,isrtimer,i2cbuffer = 0;
 116:main.c        **** uint8_t fanlevel = 254;
 117:main.c        **** 
 118:main.c        **** 
 119:main.c        **** uint16_t commands[] = {
 120:main.c        **** 
 121:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x101, 0x008, 0x110,
 122:main.c        ****     0x021, 0x109, 0x030, 0x102, 0x031, 0x100, 0x040, 0x110,
 123:main.c        ****     0x041, 0x155, 0x042, 0x102, 0x043, 0x109, 0x044, 0x107,
 124:main.c        ****     0x050, 0x178, 0x051, 0x178, 0x052, 0x100, 0x053, 0x16d,
 125:main.c        ****     0x060, 0x107, 0x061, 0x100, 0x062, 0x108, 0x063, 0x100,
 126:main.c        ****     0x0a0, 0x100, 0x0a1, 0x107, 0x0a2, 0x10c, 0x0a3, 0x10b,
 127:main.c        ****     0x0a4, 0x103, 0x0a5, 0x107, 0x0a6, 0x106, 0x0a7, 0x104,
 128:main.c        ****     0x0a8, 0x108, 0x0a9, 0x10c, 0x0aa, 0x113, 0x0ab, 0x106,
 129:main.c        ****     0x0ac, 0x10d, 0x0ad, 0x119, 0x0ae, 0x110, 0x0af, 0x100,
 130:main.c        ****     0x0c0, 0x100, 0x0c1, 0x107, 0x0c2, 0x10c, 0x0c3, 0x10b,
 131:main.c        ****     0x0c4, 0x103, 0x0c5, 0x107, 0x0c6, 0x107, 0x0c7, 0x104,
 132:main.c        ****     0x0c8, 0x108, 0x0c9, 0x10c, 0x0ca, 0x113, 0x0cb, 0x106,
 133:main.c        ****     0x0cc, 0x10d, 0x0cd, 0x118, 0x0ce, 0x110, 0x0cf, 0x100,
 134:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x106, 0x000, 0x120,
 135:main.c        ****     0x001, 0x10a, 0x002, 0x100, 0x003, 0x100, 0x004, 0x101,
 136:main.c        ****     0x005, 0x101, 0x006, 0x198, 0x007, 0x106, 0x008, 0x101,
 137:main.c        ****     0x009, 0x180, 0x00a, 0x100, 0x00b, 0x100, 0x00c, 0x101,
 138:main.c        ****     0x00d, 0x101, 0x00e, 0x100, 0x00f, 0x100, 0x010, 0x1f0,
 139:main.c        ****     0x011, 0x1f4, 0x012, 0x101, 0x013, 0x100, 0x014, 0x100,
 140:main.c        ****     0x015, 0x1c0, 0x016, 0x108, 0x017, 0x100, 0x018, 0x100,
 141:main.c        ****     0x019, 0x100, 0x01a, 0x100, 0x01b, 0x100, 0x01c, 0x100,
 142:main.c        ****     0x01d, 0x100, 0x020, 0x101, 0x021, 0x123, 0x022, 0x145,
 143:main.c        ****     0x023, 0x167, 0x024, 0x101, 0x025, 0x123, 0x026, 0x145,
 144:main.c        ****     0x027, 0x167, 0x030, 0x111, 0x031, 0x111, 0x032, 0x100,
 145:main.c        ****     0x033, 0x1ee, 0x034, 0x1ff, 0x035, 0x1bb, 0x036, 0x1aa,
 146:main.c        ****     0x037, 0x1dd, 0x038, 0x1cc, 0x039, 0x166, 0x03a, 0x177,
 147:main.c        ****     0x03b, 0x122, 0x03c, 0x122, 0x03d, 0x122, 0x03e, 0x122,
 148:main.c        ****     0x03f, 0x122, 0x040, 0x122, 0x052, 0x110, 0x053, 0x110,
 149:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x107, 0x018, 0x11d,
 150:main.c        ****     0x017, 0x122, 0x002, 0x177, 0x026, 0x1b2, 0x0e1, 0x179,
 151:main.c        ****     0x0ff, 0x1ff, 0x198, 0x106, 0x104, 0x100, 0x03a, 0x160,
 152:main.c        ****     0x035, 0x100, 0x011, 0x100, 0xffff, 0x029, 0x100, 0xffff
 153:main.c        **** 
 154:main.c        **** };
 155:main.c        ****          
 156:main.c        ****         
 157:main.c        ****             
 158:main.c        **** 
 159:main.c        **** void writebl(uint8_t data) { // set single wire brightness  AL3050 
 206               		.loc 4 159 0
 207               		.cfi_startproc
 208               	.LVL19:
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213               		.loc 4 159 0
 214 0090 27E0      		ldi r18,lo8(7)
 215 0092 30E0      		ldi r19,0
 160:main.c        ****   uint8_t count = 8;
 161:main.c        ****   do {
 162:main.c        ****     PORTD &= ~_BV(PD4);
 163:main.c        ****     _delay_us(100);
 164:main.c        ****     if (!(data & (1 << (count - 1)))) {
 216               		.loc 4 164 0
 217 0094 90E0      		ldi r25,0
 218               	.LVL20:
 219               	.L13:
 162:main.c        ****     _delay_us(100);
 220               		.loc 4 162 0
 221 0096 5C98      		cbi 0xb,4
 222               	.LVL21:
 223               	.LBB47:
 224               	.LBB48:
 225               		.loc 3 276 0
 226 0098 EFE8      		ldi r30,lo8(399)
 227 009a F1E0      		ldi r31,hi8(399)
 228 009c 3197      	1:	sbiw r30,1
 229 009e 01F4      		brne 1b
 230 00a0 00C0      		rjmp .
 231 00a2 0000      		nop
 232               	.LVL22:
 233               	.LBE48:
 234               	.LBE47:
 235               		.loc 4 164 0
 236 00a4 AC01      		movw r20,r24
 237 00a6 022E      		mov r0,r18
 238 00a8 00C0      		rjmp 2f
 239               		1:
 240 00aa 5595      		asr r21
 241 00ac 4795      		ror r20
 242               		2:
 243 00ae 0A94      		dec r0
 244 00b0 02F4      		brpl 1b
 245 00b2 BA01      		movw r22,r20
 246 00b4 6170      		andi r22,1
 247 00b6 7727      		clr r23
 248 00b8 40FD      		sbrc r20,0
 249 00ba 00C0      		rjmp .L11
 250               	.LVL23:
 251               	.LBB49:
 252               	.LBB50:
 253               		.loc 3 276 0
 254 00bc EFE8      		ldi r30,lo8(399)
 255 00be F1E0      		ldi r31,hi8(399)
 256 00c0 3197      	1:	sbiw r30,1
 257 00c2 01F4      		brne 1b
 258 00c4 00C0      		rjmp .
 259 00c6 0000      		nop
 260               	.LVL24:
 261               	.L11:
 262               	.LBE50:
 263               	.LBE49:
 165:main.c        ****       _delay_us(100);
 166:main.c        ****     }
 167:main.c        ****     PORTD |= _BV(PD4);
 264               		.loc 4 167 0
 265 00c8 5C9A      		sbi 0xb,4
 266               	.LVL25:
 267               	.LBB51:
 268               	.LBB52:
 269               		.loc 3 276 0
 270 00ca EFE8      		ldi r30,lo8(399)
 271 00cc F1E0      		ldi r31,hi8(399)
 272 00ce 3197      	1:	sbiw r30,1
 273 00d0 01F4      		brne 1b
 274 00d2 00C0      		rjmp .
 275 00d4 0000      		nop
 276               	.LVL26:
 277               	.LBE52:
 278               	.LBE51:
 168:main.c        ****     _delay_us(100);
 169:main.c        ****     if ((data & (1 << (count - 1))) != 0) {
 279               		.loc 4 169 0
 280 00d6 672B      		or r22,r23
 281 00d8 01F0      		breq .L12
 282               	.LVL27:
 283               	.LBB53:
 284               	.LBB54:
 285               		.loc 3 276 0
 286 00da EFE8      		ldi r30,lo8(399)
 287 00dc F1E0      		ldi r31,hi8(399)
 288 00de 3197      	1:	sbiw r30,1
 289 00e0 01F4      		brne 1b
 290 00e2 00C0      		rjmp .
 291 00e4 0000      		nop
 292               	.LVL28:
 293               	.L12:
 294               	.LVL29:
 295               	.LBE54:
 296               	.LBE53:
 297 00e6 2150      		subi r18,1
 298 00e8 3109      		sbc r19,__zero_reg__
 299 00ea 00F4      		brcc .L13
 170:main.c        ****       _delay_us(100);
 171:main.c        ****     }
 172:main.c        ****     count--;
 173:main.c        ****   } while (count);
 174:main.c        **** 
 175:main.c        ****   PORTD &= ~_BV(PD4);
 300               		.loc 4 175 0
 301 00ec 5C98      		cbi 0xb,4
 302               	.LVL30:
 303               	.LBB55:
 304               	.LBB56:
 305               		.loc 3 276 0
 306 00ee 8FE8      		ldi r24,lo8(399)
 307 00f0 91E0      		ldi r25,hi8(399)
 308 00f2 0197      	1:	sbiw r24,1
 309 00f4 01F4      		brne 1b
 310               	.LVL31:
 311 00f6 00C0      		rjmp .
 312 00f8 0000      		nop
 313               	.LVL32:
 314               	.LBE56:
 315               	.LBE55:
 176:main.c        ****   _delay_us(100);
 177:main.c        ****   PORTD |= _BV(PD4);
 316               		.loc 4 177 0
 317 00fa 5C9A      		sbi 0xb,4
 318               	.LVL33:
 319               	.LBB57:
 320               	.LBB58:
 321               		.loc 3 276 0
 322 00fc EFE8      		ldi r30,lo8(399)
 323 00fe F1E0      		ldi r31,hi8(399)
 324 0100 3197      	1:	sbiw r30,1
 325 0102 01F4      		brne 1b
 326 0104 00C0      		rjmp .
 327 0106 0000      		nop
 328               	.LVL34:
 329 0108 0895      		ret
 330               	.LBE58:
 331               	.LBE57:
 332               		.cfi_endproc
 333               	.LFE24:
 335               	.global	initbl
 337               	initbl:
 338               	.LFB25:
 178:main.c        ****   _delay_us(100);
 179:main.c        **** }
 180:main.c        **** 
 181:main.c        **** void initbl() { // init AL3050 single wire dimming
 339               		.loc 4 181 0
 340               		.cfi_startproc
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
 182:main.c        ****   PORTD &= ~_BV(PD4);
 345               		.loc 4 182 0
 346 010a 5C98      		cbi 0xb,4
 347               	.LVL35:
 348               	.LBB59:
 349               	.LBB60:
 350               		.loc 3 276 0
 351 010c 8FED      		ldi r24,lo8(11999)
 352 010e 9EE2      		ldi r25,hi8(11999)
 353 0110 0197      	1:	sbiw r24,1
 354 0112 01F4      		brne 1b
 355 0114 00C0      		rjmp .
 356 0116 0000      		nop
 357               	.LVL36:
 358               	.LBE60:
 359               	.LBE59:
 183:main.c        ****   _delay_us(3000);
 184:main.c        ****   PORTD |= _BV(PD4);
 360               		.loc 4 184 0
 361 0118 5C9A      		sbi 0xb,4
 362               	.LVL37:
 363               	.LBB61:
 364               	.LBB62:
 365               		.loc 3 276 0
 366 011a 8FED      		ldi r24,lo8(479)
 367 011c 91E0      		ldi r25,hi8(479)
 368 011e 0197      	1:	sbiw r24,1
 369 0120 01F4      		brne 1b
 370 0122 00C0      		rjmp .
 371 0124 0000      		nop
 372               	.LVL38:
 373               	.LBE62:
 374               	.LBE61:
 185:main.c        ****   _delay_us(120);
 186:main.c        ****   PORTD &= ~_BV(PD4);
 375               		.loc 4 186 0
 376 0126 5C98      		cbi 0xb,4
 377               	.LVL39:
 378               	.LBB63:
 379               	.LBB64:
 380               		.loc 3 276 0
 381 0128 8FEC      		ldi r24,lo8(1999)
 382 012a 97E0      		ldi r25,hi8(1999)
 383 012c 0197      	1:	sbiw r24,1
 384 012e 01F4      		brne 1b
 385 0130 00C0      		rjmp .
 386 0132 0000      		nop
 387               	.LVL40:
 388               	.LBE64:
 389               	.LBE63:
 187:main.c        ****   _delay_us(500);
 188:main.c        ****   PORTD |= _BV(PD4);
 390               		.loc 4 188 0
 391 0134 5C9A      		sbi 0xb,4
 392               	.LVL41:
 393               	.LBB65:
 394               	.LBB66:
 395               		.loc 3 276 0
 396 0136 9AE1      		ldi r25,lo8(26)
 397 0138 9A95      	1:	dec r25
 398 013a 01F4      		brne 1b
 399 013c 00C0      		rjmp .
 400               	.LVL42:
 401 013e 0895      		ret
 402               	.LBE66:
 403               	.LBE65:
 404               		.cfi_endproc
 405               	.LFE25:
 407               	.global	write
 409               	write:
 410               	.LFB26:
 189:main.c        ****   _delay_us(5);
 190:main.c        **** }
 191:main.c        **** 
 192:main.c        **** void write(uint16_t data, uint8_t count) { //  write routine for LCD setup
 411               		.loc 4 192 0
 412               		.cfi_startproc
 413               	.LVL43:
 414               	/* prologue: function */
 415               	/* frame size = 0 */
 416               	/* stack size = 0 */
 417               	.L__stack_usage = 0
 418 0140 AC01      		movw r20,r24
 193:main.c        ****   PORTD &= ~_BV(PD4);
 419               		.loc 4 193 0
 420 0142 5C98      		cbi 0xb,4
 194:main.c        ****   do {
 195:main.c        ****     PORTB &= ~_BV(PB2);
 196:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 421               		.loc 4 196 0
 422 0144 E1E0      		ldi r30,lo8(1)
 423 0146 F0E0      		ldi r31,0
 424               	.LVL44:
 425               	.L21:
 195:main.c        ****     PORTB |= (((data & (1 << (count - 1))) != 0) << 2); // BITWISE AND -> PB2           
 426               		.loc 4 195 0
 427 0148 2A98      		cbi 0x5,2
 428               		.loc 4 196 0
 429 014a 95B1      		in r25,0x5
 430 014c 8FEF      		ldi r24,lo8(-1)
 431 014e 860F      		add r24,r22
 432 0150 9F01      		movw r18,r30
 433 0152 00C0      		rjmp 2f
 434               		1:
 435 0154 220F      		lsl r18
 436 0156 331F      		rol r19
 437               		2:
 438 0158 8A95      		dec r24
 439 015a 02F4      		brpl 1b
 440 015c 2423      		and r18,r20
 441 015e 3523      		and r19,r21
 442 0160 232B      		or r18,r19
 443 0162 01F4      		brne .L22
 444 0164 20E0      		ldi r18,0
 445 0166 00C0      		rjmp .L20
 446               	.L22:
 447 0168 24E0      		ldi r18,lo8(4)
 448               	.L20:
 449               		.loc 4 196 0 is_stmt 0 discriminator 4
 450 016a 922B      		or r25,r18
 451 016c 95B9      		out 0x5,r25
 197:main.c        ****     PORTB &= ~_BV(PB1);
 452               		.loc 4 197 0 is_stmt 1 discriminator 4
 453 016e 2998      		cbi 0x5,1
 454               	.LVL45:
 455               	.LBB67:
 456               	.LBB68:
 457               		.loc 3 276 0 discriminator 4
 458 0170 8FE8      		ldi r24,lo8(399)
 459 0172 91E0      		ldi r25,hi8(399)
 460 0174 0197      	1:	sbiw r24,1
 461 0176 01F4      		brne 1b
 462 0178 00C0      		rjmp .
 463 017a 0000      		nop
 464               	.LVL46:
 465               	.LBE68:
 466               	.LBE67:
 198:main.c        ****     _delay_us(DELAY);
 199:main.c        ****     PORTB |= _BV(PB1);
 467               		.loc 4 199 0 discriminator 4
 468 017c 299A      		sbi 0x5,1
 469               	.LVL47:
 470               	.LBB69:
 471               	.LBB70:
 472               		.loc 3 276 0 discriminator 4
 473 017e 8FE8      		ldi r24,lo8(399)
 474 0180 91E0      		ldi r25,hi8(399)
 475 0182 0197      	1:	sbiw r24,1
 476 0184 01F4      		brne 1b
 477 0186 00C0      		rjmp .
 478 0188 0000      		nop
 479               	.LVL48:
 480               	.LBE70:
 481               	.LBE69:
 200:main.c        ****     _delay_us(DELAY);
 201:main.c        ****     count--;
 482               		.loc 4 201 0 discriminator 4
 483 018a 6150      		subi r22,lo8(-(-1))
 484               	.LVL49:
 202:main.c        ****   } while (count);
 485               		.loc 4 202 0 discriminator 4
 486 018c 01F4      		brne .L21
 203:main.c        ****   PORTB &= ~_BV(PB2);
 487               		.loc 4 203 0
 488 018e 2A98      		cbi 0x5,2
 204:main.c        ****   PORTD |= _BV(PD4);
 489               		.loc 4 204 0
 490 0190 5C9A      		sbi 0xb,4
 491 0192 0895      		ret
 492               		.cfi_endproc
 493               	.LFE26:
 495               	.global	setup_lcd
 497               	setup_lcd:
 498               	.LFB27:
 205:main.c        **** }
 206:main.c        **** 
 207:main.c        **** void setup_lcd(void){
 499               		.loc 4 207 0
 500               		.cfi_startproc
 501 0194 CF93      		push r28
 502               	.LCFI0:
 503               		.cfi_def_cfa_offset 3
 504               		.cfi_offset 28, -2
 505 0196 DF93      		push r29
 506               	.LCFI1:
 507               		.cfi_def_cfa_offset 4
 508               		.cfi_offset 29, -3
 509               	/* prologue: function */
 510               	/* frame size = 0 */
 511               	/* stack size = 2 */
 512               	.L__stack_usage = 2
 513               	.LVL50:
 514 0198 C0E0      		ldi r28,lo8(commands)
 515 019a D0E0      		ldi r29,hi8(commands)
 516               	.LVL51:
 517               	.L27:
 518               	.LBB71:
 208:main.c        **** 
 209:main.c        ****    for(uint16_t x=0;x < 258; x++ )
 210:main.c        ****    {
 211:main.c        **** 
 212:main.c        ****    if (commands[x] == 0xffff) {_delay_ms(WAIT);continue;}
 519               		.loc 4 212 0
 520 019c 8991      		ld r24,Y+
 521 019e 9991      		ld r25,Y+
 522 01a0 8F3F      		cpi r24,-1
 523 01a2 2FEF      		ldi r18,-1
 524 01a4 9207      		cpc r25,r18
 525 01a6 01F4      		brne .L25
 526               	.LVL52:
 527               	.LBB72:
 528               	.LBB73:
 187:/usr/lib/avr/include/util/delay.h **** 
 529               		.loc 3 187 0
 530 01a8 8FEF      		ldi r24,lo8(383999)
 531 01aa 9BED      		ldi r25,hi8(383999)
 532 01ac 25E0      		ldi r18,hlo8(383999)
 533 01ae 8150      	1:	subi r24,1
 534 01b0 9040      		sbci r25,0
 535 01b2 2040      		sbci r18,0
 536 01b4 01F4      		brne 1b
 537 01b6 00C0      		rjmp .
 538 01b8 0000      		nop
 539               	.LVL53:
 540               	.LBE73:
 541               	.LBE72:
 542               		.loc 4 212 0
 543 01ba 00C0      		rjmp .L26
 544               	.L25:
 213:main.c        **** 
 214:main.c        ****     write(commands[x],9);}
 545               		.loc 4 214 0
 546 01bc 69E0      		ldi r22,lo8(9)
 547 01be 0E94 0000 		call write
 548               	.LVL54:
 549               	.L26:
 209:main.c        ****    {
 550               		.loc 4 209 0 discriminator 2
 551 01c2 80E0      		ldi r24,hi8(commands+516)
 552 01c4 C030      		cpi r28,lo8(commands+516)
 553 01c6 D807      		cpc r29,r24
 554 01c8 01F4      		brne .L27
 555               	/* epilogue start */
 556               	.LBE71:
 215:main.c        **** 
 216:main.c        **** }
 557               		.loc 4 216 0
 558 01ca DF91      		pop r29
 559 01cc CF91      		pop r28
 560 01ce 0895      		ret
 561               		.cfi_endproc
 562               	.LFE27:
 564               	.global	readAna
 566               	readAna:
 567               	.LFB28:
 217:main.c        **** 
 218:main.c        **** 
 219:main.c        **** uint16_t readAna(uint8_t channel) {
 568               		.loc 4 219 0
 569               		.cfi_startproc
 570               	.LVL55:
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 220:main.c        ****   uint8_t low, high;
 221:main.c        ****   ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 575               		.loc 4 221 0
 576 01d0 9091 7A00 		lds r25,122
 577 01d4 9760      		ori r25,lo8(7)
 578 01d6 9093 7A00 		sts 122,r25
 222:main.c        ****   ADCSRB = 0x40;
 579               		.loc 4 222 0
 580 01da 90E4      		ldi r25,lo8(64)
 581 01dc 9093 7B00 		sts 123,r25
 223:main.c        ****   ADMUX = ((0 << REFS1) | (1 << REFS0) | (0 << ADLAR));
 582               		.loc 4 223 0
 583 01e0 9093 7C00 		sts 124,r25
 224:main.c        **** 
 225:main.c        ****   if (channel >= 8) //
 584               		.loc 4 225 0
 585 01e4 8830      		cpi r24,lo8(8)
 586 01e6 00F0      		brlo .L30
 226:main.c        ****   {
 227:main.c        ****     channel -= 0x08; //ch - 8           
 587               		.loc 4 227 0
 588 01e8 8850      		subi r24,lo8(-(-8))
 589               	.LVL56:
 228:main.c        ****     ADCSRB |= (1 << MUX5); // set MUX5 on ADCSRB to read upper bit ADC8-ADC13
 590               		.loc 4 228 0
 591 01ea 9091 7B00 		lds r25,123
 592 01ee 9062      		ori r25,lo8(32)
 593 01f0 00C0      		rjmp .L34
 594               	.L30:
 229:main.c        ****   } else {
 230:main.c        ****     ADCSRB &= ~(1 << MUX5); // clear MUX 5 
 595               		.loc 4 230 0
 596 01f2 9091 7B00 		lds r25,123
 597 01f6 9F7D      		andi r25,lo8(-33)
 598               	.L34:
 599 01f8 9093 7B00 		sts 123,r25
 600               	.LVL57:
 231:main.c        ****   }
 232:main.c        ****   channel &= 0x07;
 233:main.c        ****   ADMUX |= channel; // selecting channel
 601               		.loc 4 233 0
 602 01fc 9091 7C00 		lds r25,124
 603 0200 8770      		andi r24,lo8(7)
 604               	.LVL58:
 605 0202 892B      		or r24,r25
 606               	.LVL59:
 607 0204 8093 7C00 		sts 124,r24
 234:main.c        **** 
 235:main.c        ****   ADCSRA |= _BV(ADEN);
 608               		.loc 4 235 0
 609 0208 8091 7A00 		lds r24,122
 610 020c 8068      		ori r24,lo8(-128)
 611 020e 8093 7A00 		sts 122,r24
 612               	.LVL60:
 613               	.LBB74:
 614               	.LBB75:
 187:/usr/lib/avr/include/util/delay.h **** 
 615               		.loc 3 187 0
 616 0212 8FE3      		ldi r24,lo8(7999)
 617 0214 9FE1      		ldi r25,hi8(7999)
 618 0216 0197      	1:	sbiw r24,1
 619 0218 01F4      		brne 1b
 620 021a 00C0      		rjmp .
 621 021c 0000      		nop
 622               	.LVL61:
 623               	.LBE75:
 624               	.LBE74:
 236:main.c        ****   _delay_ms(2);
 237:main.c        ****   ADCSRA |= (1 << ADSC);
 625               		.loc 4 237 0
 626 021e 8091 7A00 		lds r24,122
 627 0222 8064      		ori r24,lo8(64)
 628 0224 8093 7A00 		sts 122,r24
 629               	.L32:
 238:main.c        **** 
 239:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring 
 630               		.loc 4 239 0 discriminator 1
 631 0228 8091 7A00 		lds r24,122
 632 022c 86FD      		sbrc r24,6
 633 022e 00C0      		rjmp .L32
 240:main.c        ****   low = ADCL;
 634               		.loc 4 240 0
 635 0230 8091 7800 		lds r24,120
 636               	.LVL62:
 241:main.c        ****   high = ADCH;
 637               		.loc 4 241 0
 638 0234 2091 7900 		lds r18,121
 639               	.LVL63:
 242:main.c        ****   return (high << 8) | low;
 640               		.loc 4 242 0
 641 0238 90E0      		ldi r25,0
 243:main.c        **** 
 244:main.c        **** }
 642               		.loc 4 244 0
 643 023a 922B      		or r25,r18
 644 023c 0895      		ret
 645               		.cfi_endproc
 646               	.LFE28:
 648               	.global	readVcc
 650               	readVcc:
 651               	.LFB29:
 245:main.c        **** 
 246:main.c        **** uint16_t readVcc(void) {
 652               		.loc 4 246 0
 653               		.cfi_startproc
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 0 */
 657               	.L__stack_usage = 0
 247:main.c        ****   ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
 658               		.loc 4 247 0
 659 023e 8EE5      		ldi r24,lo8(94)
 660 0240 8093 7C00 		sts 124,r24
 248:main.c        ****   ADCSRA |= _BV(ADEN);
 661               		.loc 4 248 0
 662 0244 8091 7A00 		lds r24,122
 663 0248 8068      		ori r24,lo8(-128)
 664 024a 8093 7A00 		sts 122,r24
 249:main.c        ****   ADCSRB &= ~_BV(MUX5);
 665               		.loc 4 249 0
 666 024e 8091 7B00 		lds r24,123
 667 0252 8F7D      		andi r24,lo8(-33)
 668 0254 8093 7B00 		sts 123,r24
 669               	.LVL64:
 670               	.LBB76:
 671               	.LBB77:
 187:/usr/lib/avr/include/util/delay.h **** 
 672               		.loc 3 187 0
 673 0258 8FE3      		ldi r24,lo8(7999)
 674 025a 9FE1      		ldi r25,hi8(7999)
 675 025c 0197      	1:	sbiw r24,1
 676 025e 01F4      		brne 1b
 677 0260 00C0      		rjmp .
 678 0262 0000      		nop
 679               	.LVL65:
 680               	.LBE77:
 681               	.LBE76:
 250:main.c        ****   _delay_ms(2);
 251:main.c        ****   ADCSRA |= 1 << ADSC;
 682               		.loc 4 251 0
 683 0264 8091 7A00 		lds r24,122
 684 0268 8064      		ori r24,lo8(64)
 685 026a 8093 7A00 		sts 122,r24
 686               	.L36:
 252:main.c        ****   while ((ADCSRA & _BV(ADSC))); // measuring
 687               		.loc 4 252 0 discriminator 1
 688 026e 8091 7A00 		lds r24,122
 689 0272 86FD      		sbrc r24,6
 690 0274 00C0      		rjmp .L36
 253:main.c        ****   ADCSRA |= 1 << ADSC;
 691               		.loc 4 253 0
 692 0276 8091 7A00 		lds r24,122
 693 027a 8064      		ori r24,lo8(64)
 694 027c 8093 7A00 		sts 122,r24
 695               	.L37:
 254:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 696               		.loc 4 254 0 discriminator 1
 697 0280 8091 7A00 		lds r24,122
 698 0284 86FD      		sbrc r24,6
 699 0286 00C0      		rjmp .L37
 255:main.c        ****   return 1125300L / (ADCL | (ADCH<<8));
 700               		.loc 4 255 0
 701 0288 2091 7800 		lds r18,120
 702 028c 8091 7900 		lds r24,121
 703 0290 30E0      		ldi r19,0
 704 0292 382B      		or r19,r24
 705 0294 032E      		mov __tmp_reg__,r19
 706 0296 000C      		lsl r0
 707 0298 440B      		sbc r20,r20
 708 029a 550B      		sbc r21,r21
 709 029c 64EB      		ldi r22,lo8(-76)
 710 029e 7BE2      		ldi r23,lo8(43)
 711 02a0 81E1      		ldi r24,lo8(17)
 712 02a2 90E0      		ldi r25,0
 713 02a4 0E94 0000 		call __divmodsi4
 256:main.c        **** }
 714               		.loc 4 256 0
 715 02a8 C901      		movw r24,r18
 716 02aa 0895      		ret
 717               		.cfi_endproc
 718               	.LFE29:
 720               	.global	GetTemp
 722               	GetTemp:
 723               	.LFB30:
 257:main.c        **** 
 258:main.c        **** uint16_t GetTemp(void) {
 724               		.loc 4 258 0
 725               		.cfi_startproc
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 0 */
 729               	.L__stack_usage = 0
 259:main.c        **** 
 260:main.c        ****   ADMUX = _BV(REFS1) | _BV(REFS0) | 7; // Set internal V reference, temperature reading
 730               		.loc 4 260 0
 731 02ac 87EC      		ldi r24,lo8(-57)
 732 02ae 8093 7C00 		sts 124,r24
 261:main.c        ****   ADCSRB = 0x20; // ref  24.6
 733               		.loc 4 261 0
 734 02b2 80E2      		ldi r24,lo8(32)
 735 02b4 8093 7B00 		sts 123,r24
 262:main.c        ****   ADCSRA &= ~(_BV(ADATE) | _BV(ADIE)); // Clear auto trigger and interrupt enable
 736               		.loc 4 262 0
 737 02b8 8091 7A00 		lds r24,122
 738 02bc 877D      		andi r24,lo8(-41)
 739 02be 8093 7A00 		sts 122,r24
 263:main.c        ****   ADCSRA |= _BV(ADEN); // enable the ADC
 740               		.loc 4 263 0
 741 02c2 8091 7A00 		lds r24,122
 742 02c6 8068      		ori r24,lo8(-128)
 743 02c8 8093 7A00 		sts 122,r24
 744               	.LVL66:
 745               	.LBB78:
 746               	.LBB79:
 187:/usr/lib/avr/include/util/delay.h **** 
 747               		.loc 3 187 0
 748 02cc 8FE3      		ldi r24,lo8(7999)
 749 02ce 9FE1      		ldi r25,hi8(7999)
 750 02d0 0197      	1:	sbiw r24,1
 751 02d2 01F4      		brne 1b
 752 02d4 00C0      		rjmp .
 753 02d6 0000      		nop
 754               	.LVL67:
 755               	.LBE79:
 756               	.LBE78:
 264:main.c        ****   _delay_ms(2); // delay for voltages to become stable.
 265:main.c        **** 
 266:main.c        ****   ADCSRA |= _BV(ADSC); // measuring
 757               		.loc 4 266 0
 758 02d8 8091 7A00 		lds r24,122
 759 02dc 8064      		ori r24,lo8(64)
 760 02de 8093 7A00 		sts 122,r24
 761               	.L41:
 267:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 762               		.loc 4 267 0 discriminator 1
 763 02e2 8091 7A00 		lds r24,122
 764 02e6 86FD      		sbrc r24,6
 765 02e8 00C0      		rjmp .L41
 268:main.c        **** 
 269:main.c        ****   ADCSRA |= _BV(ADSC);
 766               		.loc 4 269 0
 767 02ea 8091 7A00 		lds r24,122
 768 02ee 8064      		ori r24,lo8(64)
 769 02f0 8093 7A00 		sts 122,r24
 770               	.L42:
 270:main.c        ****   while ((ADCSRA & _BV(ADSC)));
 771               		.loc 4 270 0 discriminator 1
 772 02f4 8091 7A00 		lds r24,122
 773 02f8 86FD      		sbrc r24,6
 774 02fa 00C0      		rjmp .L42
 271:main.c        **** 
 272:main.c        ****   return (ADCL | (ADCH << 8));
 775               		.loc 4 272 0
 776 02fc 8091 7800 		lds r24,120
 777 0300 2091 7900 		lds r18,121
 778 0304 90E0      		ldi r25,0
 273:main.c        **** }
 779               		.loc 4 273 0
 780 0306 922B      		or r25,r18
 781 0308 0895      		ret
 782               		.cfi_endproc
 783               	.LFE30:
 785               	.global	freeRam
 787               	freeRam:
 788               	.LFB31:
 274:main.c        **** 
 275:main.c        **** uint16_t freeRam(void) {
 789               		.loc 4 275 0
 790               		.cfi_startproc
 791 030a CF93      		push r28
 792               	.LCFI2:
 793               		.cfi_def_cfa_offset 3
 794               		.cfi_offset 28, -2
 795 030c DF93      		push r29
 796               	.LCFI3:
 797               		.cfi_def_cfa_offset 4
 798               		.cfi_offset 29, -3
 799 030e 00D0      		rcall .
 800               	.LCFI4:
 801               		.cfi_def_cfa_offset 6
 802 0310 CDB7      		in r28,__SP_L__
 803 0312 DEB7      		in r29,__SP_H__
 804               	.LCFI5:
 805               		.cfi_def_cfa_register 28
 806               	/* prologue: function */
 807               	/* frame size = 2 */
 808               	/* stack size = 4 */
 809               	.L__stack_usage = 4
 276:main.c        ****   extern char __heap_start, * __brkval;
 277:main.c        ****   int v;
 278:main.c        ****   return (uint16_t) & v - (__brkval == 0 ? (int) & __heap_start : (int) __brkval);
 810               		.loc 4 278 0
 811 0314 2091 0000 		lds r18,__brkval
 812 0318 3091 0000 		lds r19,__brkval+1
 813 031c 2115      		cp r18,__zero_reg__
 814 031e 3105      		cpc r19,__zero_reg__
 815 0320 01F4      		brne .L46
 816 0322 20E0      		ldi r18,lo8(__heap_start)
 817 0324 30E0      		ldi r19,hi8(__heap_start)
 818               	.L46:
 279:main.c        **** }
 819               		.loc 4 279 0 discriminator 4
 820 0326 CE01      		movw r24,r28
 821 0328 0196      		adiw r24,1
 822 032a 821B      		sub r24,r18
 823 032c 930B      		sbc r25,r19
 824               	/* epilogue start */
 825 032e 0F90      		pop __tmp_reg__
 826 0330 0F90      		pop __tmp_reg__
 827 0332 DF91      		pop r29
 828 0334 CF91      		pop r28
 829 0336 0895      		ret
 830               		.cfi_endproc
 831               	.LFE31:
 833               	.global	I2C_init
 835               	I2C_init:
 836               	.LFB32:
 280:main.c        **** 
 281:main.c        **** void I2C_init(uint8_t address) // setup ATmega as I2C slave
 282:main.c        **** {
 837               		.loc 4 282 0
 838               		.cfi_startproc
 839               	.LVL68:
 840               	/* prologue: function */
 841               	/* frame size = 0 */
 842               	/* stack size = 0 */
 843               	.L__stack_usage = 0
 283:main.c        ****   cli();
 844               		.loc 4 283 0
 845               	/* #APP */
 846               	 ;  283 "main.c" 1
 847 0338 F894      		cli
 848               	 ;  0 "" 2
 284:main.c        **** 
 285:main.c        ****   TWAR = (address << 1);
 849               		.loc 4 285 0
 850               	/* #NOAPP */
 851 033a 880F      		lsl r24
 852               	.LVL69:
 853 033c 8093 BA00 		sts 186,r24
 286:main.c        ****   TWCR = (1 << TWEN) | // TWI Interface enabled.
 854               		.loc 4 286 0
 855 0340 85EC      		ldi r24,lo8(-59)
 856 0342 8093 BC00 		sts 188,r24
 287:main.c        ****     (1 << TWIE) | (1 << TWINT) | // Enable TWI Interupt and clear the flag.
 288:main.c        ****     (1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) | // Prepare to ACK next time the Slave is addressed.
 289:main.c        ****     (0 << TWWC);
 290:main.c        **** 
 291:main.c        ****   buffer_address = 0xFF;
 857               		.loc 4 291 0
 858 0346 8FEF      		ldi r24,lo8(-1)
 859 0348 8093 0000 		sts buffer_address,r24
 860 034c 0895      		ret
 861               		.cfi_endproc
 862               	.LFE32:
 864               	.global	__vector_9
 866               	__vector_9:
 867               	.LFB33:
 292:main.c        **** 
 293:main.c        **** }
 294:main.c        **** 
 295:main.c        **** ISR(PCINT0_vect) {
 868               		.loc 4 295 0
 869               		.cfi_startproc
 870 034e 1F92      		push r1
 871               	.LCFI6:
 872               		.cfi_def_cfa_offset 3
 873               		.cfi_offset 1, -2
 874 0350 0F92      		push r0
 875               	.LCFI7:
 876               		.cfi_def_cfa_offset 4
 877               		.cfi_offset 0, -3
 878 0352 0FB6      		in r0,__SREG__
 879 0354 0F92      		push r0
 880 0356 1124      		clr __zero_reg__
 881 0358 8F93      		push r24
 882               	.LCFI8:
 883               		.cfi_def_cfa_offset 5
 884               		.cfi_offset 24, -4
 885 035a 9F93      		push r25
 886               	.LCFI9:
 887               		.cfi_def_cfa_offset 6
 888               		.cfi_offset 25, -5
 889               	/* prologue: Signal */
 890               	/* frame size = 0 */
 891               	/* stack size = 5 */
 892               	.L__stack_usage = 5
 296:main.c        ****   sei();
 893               		.loc 4 296 0
 894               	/* #APP */
 895               	 ;  296 "main.c" 1
 896 035c 7894      		sei
 897               	 ;  0 "" 2
 297:main.c        ****   if (bit_is_clear(PINB, PB4)) fanspin++;
 898               		.loc 4 297 0
 899               	/* #NOAPP */
 900 035e 1C99      		sbic 0x3,4
 901 0360 00C0      		rjmp .L49
 902               		.loc 4 297 0 is_stmt 0 discriminator 1
 903 0362 8091 0000 		lds r24,fanspin
 904 0366 9091 0000 		lds r25,fanspin+1
 905 036a 0196      		adiw r24,1
 906 036c 9093 0000 		sts fanspin+1,r25
 907 0370 8093 0000 		sts fanspin,r24
 908               	.L49:
 909               	/* epilogue start */
 298:main.c        **** } // counting VENT_RPM
 910               		.loc 4 298 0 is_stmt 1
 911 0374 9F91      		pop r25
 912 0376 8F91      		pop r24
 913 0378 0F90      		pop r0
 914 037a 0FBE      		out __SREG__,r0
 915 037c 0F90      		pop r0
 916 037e 1F90      		pop r1
 917 0380 1895      		reti
 918               		.cfi_endproc
 919               	.LFE33:
 921               	.global	__vector_23
 923               	__vector_23:
 924               	.LFB34:
 299:main.c        **** 
 300:main.c        **** ISR(TIMER0_OVF_vect) {
 925               		.loc 4 300 0
 926               		.cfi_startproc
 927 0382 1F92      		push r1
 928               	.LCFI10:
 929               		.cfi_def_cfa_offset 3
 930               		.cfi_offset 1, -2
 931 0384 0F92      		push r0
 932               	.LCFI11:
 933               		.cfi_def_cfa_offset 4
 934               		.cfi_offset 0, -3
 935 0386 0FB6      		in r0,__SREG__
 936 0388 0F92      		push r0
 937 038a 1124      		clr __zero_reg__
 938 038c 8F93      		push r24
 939               	.LCFI12:
 940               		.cfi_def_cfa_offset 5
 941               		.cfi_offset 24, -4
 942 038e 9F93      		push r25
 943               	.LCFI13:
 944               		.cfi_def_cfa_offset 6
 945               		.cfi_offset 25, -5
 946               	/* prologue: Signal */
 947               	/* frame size = 0 */
 948               	/* stack size = 5 */
 949               	.L__stack_usage = 5
 301:main.c        ****   isrtimer++;
 950               		.loc 4 301 0
 951 0390 8091 0000 		lds r24,isrtimer
 952 0394 9091 0000 		lds r25,isrtimer+1
 953 0398 0196      		adiw r24,1
 954 039a 9093 0000 		sts isrtimer+1,r25
 955 039e 8093 0000 		sts isrtimer,r24
 956               	/* epilogue start */
 302:main.c        **** } // reuse timer0 for counting VENT_RPM
 957               		.loc 4 302 0
 958 03a2 9F91      		pop r25
 959 03a4 8F91      		pop r24
 960 03a6 0F90      		pop r0
 961 03a8 0FBE      		out __SREG__,r0
 962 03aa 0F90      		pop r0
 963 03ac 1F90      		pop r1
 964 03ae 1895      		reti
 965               		.cfi_endproc
 966               	.LFE34:
 968               	.global	__vector_36
 970               	__vector_36:
 971               	.LFB35:
 303:main.c        **** 
 304:main.c        **** ISR(TWI_vect) {
 972               		.loc 4 304 0
 973               		.cfi_startproc
 974 03b0 1F92      		push r1
 975               	.LCFI14:
 976               		.cfi_def_cfa_offset 3
 977               		.cfi_offset 1, -2
 978 03b2 0F92      		push r0
 979               	.LCFI15:
 980               		.cfi_def_cfa_offset 4
 981               		.cfi_offset 0, -3
 982 03b4 0FB6      		in r0,__SREG__
 983 03b6 0F92      		push r0
 984 03b8 1124      		clr __zero_reg__
 985 03ba 2F93      		push r18
 986               	.LCFI16:
 987               		.cfi_def_cfa_offset 5
 988               		.cfi_offset 18, -4
 989 03bc 3F93      		push r19
 990               	.LCFI17:
 991               		.cfi_def_cfa_offset 6
 992               		.cfi_offset 19, -5
 993 03be 4F93      		push r20
 994               	.LCFI18:
 995               		.cfi_def_cfa_offset 7
 996               		.cfi_offset 20, -6
 997 03c0 5F93      		push r21
 998               	.LCFI19:
 999               		.cfi_def_cfa_offset 8
 1000               		.cfi_offset 21, -7
 1001 03c2 6F93      		push r22
 1002               	.LCFI20:
 1003               		.cfi_def_cfa_offset 9
 1004               		.cfi_offset 22, -8
 1005 03c4 7F93      		push r23
 1006               	.LCFI21:
 1007               		.cfi_def_cfa_offset 10
 1008               		.cfi_offset 23, -9
 1009 03c6 8F93      		push r24
 1010               	.LCFI22:
 1011               		.cfi_def_cfa_offset 11
 1012               		.cfi_offset 24, -10
 1013 03c8 9F93      		push r25
 1014               	.LCFI23:
 1015               		.cfi_def_cfa_offset 12
 1016               		.cfi_offset 25, -11
 1017 03ca AF93      		push r26
 1018               	.LCFI24:
 1019               		.cfi_def_cfa_offset 13
 1020               		.cfi_offset 26, -12
 1021 03cc BF93      		push r27
 1022               	.LCFI25:
 1023               		.cfi_def_cfa_offset 14
 1024               		.cfi_offset 27, -13
 1025 03ce EF93      		push r30
 1026               	.LCFI26:
 1027               		.cfi_def_cfa_offset 15
 1028               		.cfi_offset 30, -14
 1029 03d0 FF93      		push r31
 1030               	.LCFI27:
 1031               		.cfi_def_cfa_offset 16
 1032               		.cfi_offset 31, -15
 1033               	/* prologue: Signal */
 1034               	/* frame size = 0 */
 1035               	/* stack size = 15 */
 1036               	.L__stack_usage = 15
 305:main.c        **** 
 306:main.c        ****   switch (TW_STATUS) {
 1037               		.loc 4 306 0
 1038 03d2 8091 B900 		lds r24,185
 1039 03d6 887F      		andi r24,lo8(-8)
 1040 03d8 8038      		cpi r24,lo8(-128)
 1041 03da 01F0      		breq .L54
 1042 03dc 00F4      		brsh .L55
 1043 03de 8823      		tst r24
 1044 03e0 01F4      		brne .+2
 1045 03e2 00C0      		rjmp .L56
 1046 03e4 8036      		cpi r24,lo8(96)
 1047 03e6 01F0      		breq .+2
 1048 03e8 00C0      		rjmp .L53
 307:main.c        **** 
 308:main.c        ****   case TW_SR_SLA_ACK:
 309:main.c        **** 
 310:main.c        ****     TWCR = (1 << TWIE) | (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
 1049               		.loc 4 310 0
 1050 03ea 85EC      		ldi r24,lo8(-59)
 1051 03ec 8093 BC00 		sts 188,r24
 311:main.c        ****     buffer_address = 0xFF; // set buffer pos undefined
 1052               		.loc 4 311 0
 1053 03f0 8FEF      		ldi r24,lo8(-1)
 1054 03f2 8093 0000 		sts buffer_address,r24
 312:main.c        ****     break;
 1055               		.loc 4 312 0
 1056 03f6 00C0      		rjmp .L52
 1057               	.L55:
 306:main.c        **** 
 1058               		.loc 4 306 0
 1059 03f8 883A      		cpi r24,lo8(-88)
 1060 03fa 01F4      		brne .+2
 1061 03fc 00C0      		rjmp .L58
 1062 03fe 883B      		cpi r24,lo8(-72)
 1063 0400 01F4      		brne .+2
 1064 0402 00C0      		rjmp .L58
 1065 0404 00C0      		rjmp .L53
 1066               	.L54:
 313:main.c        ****    
 314:main.c        ****   case TW_SR_DATA_ACK: // received data from master
 315:main.c        ****     
 316:main.c        ****     if (buffer_address == 0xFF) {
 1067               		.loc 4 316 0
 1068 0406 8091 0000 		lds r24,buffer_address
 1069 040a 8F3F      		cpi r24,lo8(-1)
 1070 040c 01F0      		breq .+2
 1071 040e 00C0      		rjmp .L60
 317:main.c        **** 
 318:main.c        ****       commandbyte = TWDR;
 1072               		.loc 4 318 0
 1073 0410 6091 BB00 		lds r22,187
 1074 0414 6093 0000 		sts commandbyte,r22
 319:main.c        ****       crc = _crc8_ccitt_update(0, commandbyte);
 1075               		.loc 4 319 0
 1076 0418 80E0      		ldi r24,0
 1077 041a 0E94 0000 		call _crc8_ccitt_update
 1078               	.LVL70:
 1079 041e 8093 0000 		sts crc,r24
 320:main.c        ****       buffer_address = 0;
 1080               		.loc 4 320 0
 1081 0422 1092 0000 		sts buffer_address,__zero_reg__
 321:main.c        ****       i2cerror = 0;
 1082               		.loc 4 321 0
 1083 0426 1092 0000 		sts i2cerror,__zero_reg__
 322:main.c        **** 
 323:main.c        **** 
 324:main.c        ****       switch (commandbyte) {		 
 1084               		.loc 4 324 0
 1085 042a E091 0000 		lds r30,commandbyte
 1086 042e 8E2F      		mov r24,r30
 1087 0430 90E0      		ldi r25,0
 1088 0432 8531      		cpi r24,21
 1089 0434 9105      		cpc r25,__zero_reg__
 1090 0436 00F0      		brlo .+2
 1091 0438 00C0      		rjmp .L61
 1092 043a FC01      		movw r30,r24
 1093 043c E050      		subi r30,lo8(-(gs(.L63)))
 1094 043e F040      		sbci r31,hi8(-(gs(.L63)))
 1095 0440 0C94 0000 		jmp __tablejump2__
 1096               		.section	.progmem.gcc_sw_table,"a",@progbits
 1097               		.p2align	1
 1098               	.L63:
 1099 0000 0000      		.word gs(.L62)
 1100 0002 0000      		.word gs(.L64)
 1101 0004 0000      		.word gs(.L65)
 1102 0006 0000      		.word gs(.L66)
 1103 0008 0000      		.word gs(.L67)
 1104 000a 0000      		.word gs(.L68)
 1105 000c 0000      		.word gs(.L69)
 1106 000e 0000      		.word gs(.L61)
 1107 0010 0000      		.word gs(.L70)
 1108 0012 0000      		.word gs(.L71)
 1109 0014 0000      		.word gs(.L72)
 1110 0016 0000      		.word gs(.L73)
 1111 0018 0000      		.word gs(.L61)
 1112 001a 0000      		.word gs(.L61)
 1113 001c 0000      		.word gs(.L61)
 1114 001e 0000      		.word gs(.L61)
 1115 0020 0000      		.word gs(.L61)
 1116 0022 0000      		.word gs(.L61)
 1117 0024 0000      		.word gs(.L61)
 1118 0026 0000      		.word gs(.L61)
 1119 0028 0000      		.word gs(.L74)
 1120               		.text
 1121               	.L62:
 325:main.c        **** 
 326:main.c        **** 		  case 0x00: i2cbuffer = a0; break;
 1122               		.loc 4 326 0
 1123 0444 8091 0000 		lds r24,a0
 1124 0448 9091 0000 		lds r25,a0+1
 1125 044c 00C0      		rjmp .L178
 1126               	.L64:
 327:main.c        **** 		  case 0x01: i2cbuffer = a1; break;
 1127               		.loc 4 327 0
 1128 044e 8091 0000 		lds r24,a1
 1129 0452 9091 0000 		lds r25,a1+1
 1130 0456 00C0      		rjmp .L178
 1131               	.L65:
 328:main.c        **** 		  case 0x02: i2cbuffer = a2; break;
 1132               		.loc 4 328 0
 1133 0458 8091 0000 		lds r24,a2
 1134 045c 9091 0000 		lds r25,a2+1
 1135 0460 00C0      		rjmp .L178
 1136               	.L66:
 329:main.c        **** 		  case 0x03: i2cbuffer = a3; break;
 1137               		.loc 4 329 0
 1138 0462 8091 0000 		lds r24,a3
 1139 0466 9091 0000 		lds r25,a3+1
 1140 046a 00C0      		rjmp .L178
 1141               	.L67:
 330:main.c        **** 		  case 0x04: i2cbuffer = a4; break;
 1142               		.loc 4 330 0
 1143 046c 8091 0000 		lds r24,a4
 1144 0470 9091 0000 		lds r25,a4+1
 1145 0474 00C0      		rjmp .L178
 1146               	.L68:
 331:main.c        **** 		  case 0x05: i2cbuffer = a5; break;
 1147               		.loc 4 331 0
 1148 0476 8091 0000 		lds r24,a5
 1149 047a 9091 0000 		lds r25,a5+1
 1150 047e 00C0      		rjmp .L178
 1151               	.L69:
 332:main.c        **** 		  case 0x06: i2cbuffer = a7; break;
 1152               		.loc 4 332 0
 1153 0480 8091 0000 		lds r24,a7
 1154 0484 9091 0000 		lds r25,a7+1
 1155 0488 00C0      		rjmp .L178
 1156               	.L70:
 333:main.c        **** 		  case 0x08: i2cbuffer = rpm;break;
 1157               		.loc 4 333 0
 1158 048a 8091 0000 		lds r24,rpm
 1159 048e 9091 0000 		lds r25,rpm+1
 1160 0492 00C0      		rjmp .L178
 1161               	.L71:
 334:main.c        **** 		  case 0x09: i2cbuffer = vcc; break;
 1162               		.loc 4 334 0
 1163 0494 8091 0000 		lds r24,vcc
 1164 0498 9091 0000 		lds r25,vcc+1
 1165 049c 00C0      		rjmp .L178
 1166               	.L72:
 335:main.c        **** 		  case 0x0A: i2cbuffer = temp;break;
 1167               		.loc 4 335 0
 1168 049e 8091 0000 		lds r24,temp
 1169 04a2 9091 0000 		lds r25,temp+1
 1170 04a6 00C0      		rjmp .L178
 1171               	.L73:
 336:main.c        **** 		  case 0x0B: i2cbuffer = freeRam(); break;
 1172               		.loc 4 336 0
 1173 04a8 0E94 0000 		call freeRam
 1174               	.LVL71:
 1175 04ac 00C0      		rjmp .L178
 1176               	.L74:
 337:main.c        **** 		  case 0x14: i2cbuffer = a7avg; break;
 1177               		.loc 4 337 0
 1178 04ae 8091 0000 		lds r24,a7avg
 1179 04b2 9091 0000 		lds r25,a7avg+1
 1180               	.L178:
 1181 04b6 9093 0000 		sts i2cbuffer+1,r25
 1182 04ba 8093 0000 		sts i2cbuffer,r24
 1183 04be 00C0      		rjmp .L61
 1184               	.L60:
 338:main.c        **** 
 339:main.c        **** 
 340:main.c        **** 	    }
 341:main.c        ****       } 
 342:main.c        ****       else { 
 343:main.c        **** 
 344:main.c        ****       
 345:main.c        ****  
 346:main.c        ****       if (buffer_address == 0) {twdrbuffer = TWDR; crc = _crc8_ccitt_update(crc,TWDR);}
 1185               		.loc 4 346 0
 1186 04c0 8111      		cpse r24,__zero_reg__
 1187 04c2 00C0      		rjmp .L75
 1188               		.loc 4 346 0 is_stmt 0 discriminator 1
 1189 04c4 8091 BB00 		lds r24,187
 1190 04c8 8093 0000 		sts twdrbuffer,r24
 1191 04cc 6091 BB00 		lds r22,187
 1192 04d0 8091 0000 		lds r24,crc
 1193 04d4 0E94 0000 		call _crc8_ccitt_update
 1194               	.LVL72:
 1195 04d8 8093 0000 		sts crc,r24
 1196 04dc 00C0      		rjmp .L76
 1197               	.L75:
 347:main.c        **** 
 348:main.c        ****       else  if ((buffer_address == 1) & (TWDR == crc)) {
 1198               		.loc 4 348 0 is_stmt 1
 1199 04de 9091 BB00 		lds r25,187
 1200 04e2 2091 0000 		lds r18,crc
 1201 04e6 2913      		cpse r18,r25
 1202 04e8 00C0      		rjmp .L77
 1203 04ea 8130      		cpi r24,lo8(1)
 1204 04ec 01F0      		breq .+2
 1205 04ee 00C0      		rjmp .L77
 349:main.c        **** 
 350:main.c        ****            if (commandbyte == 0x87 ) {newbllevel = twdrbuffer;}
 1206               		.loc 4 350 0
 1207 04f0 8091 0000 		lds r24,commandbyte
 1208 04f4 8738      		cpi r24,lo8(-121)
 1209 04f6 01F4      		brne .L80
 1210               		.loc 4 350 0 is_stmt 0 discriminator 1
 1211 04f8 8091 0000 		lds r24,twdrbuffer
 1212 04fc 8093 0000 		sts newbllevel,r24
 1213 0500 00C0      		rjmp .L76
 1214               	.L80:
 351:main.c        ****       else if (commandbyte == 0x8D ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC6);} else {PORTC &= ~
 1215               		.loc 4 351 0 is_stmt 1
 1216 0502 8D38      		cpi r24,lo8(-115)
 1217 0504 01F4      		brne .L81
 1218               		.loc 4 351 0 is_stmt 0 discriminator 1
 1219 0506 8091 0000 		lds r24,twdrbuffer
 1220 050a 8F3F      		cpi r24,lo8(-1)
 1221 050c 01F4      		brne .L82
 1222               		.loc 4 351 0 discriminator 2
 1223 050e 469A      		sbi 0x8,6
 1224 0510 00C0      		rjmp .L76
 1225               	.L82:
 1226               		.loc 4 351 0 discriminator 3
 1227 0512 4698      		cbi 0x8,6
 1228 0514 00C0      		rjmp .L76
 1229               	.L81:
 352:main.c        ****       else if (commandbyte == 0x8E ) {if (twdrbuffer == 0xFF) {PORTD |= _BV(PD7);} else {PORTD &= ~
 1230               		.loc 4 352 0 is_stmt 1
 1231 0516 8E38      		cpi r24,lo8(-114)
 1232 0518 01F4      		brne .L83
 1233               		.loc 4 352 0 is_stmt 0 discriminator 1
 1234 051a 8091 0000 		lds r24,twdrbuffer
 1235 051e 8F3F      		cpi r24,lo8(-1)
 1236 0520 01F4      		brne .L84
 1237               		.loc 4 352 0 discriminator 2
 1238 0522 5F9A      		sbi 0xb,7
 1239 0524 00C0      		rjmp .L76
 1240               	.L84:
 1241               		.loc 4 352 0 discriminator 3
 1242 0526 5F98      		cbi 0xb,7
 1243 0528 00C0      		rjmp .L76
 1244               	.L83:
 353:main.c        ****       else if (commandbyte == 0x8F ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB6);} else {PORTB &= ~
 1245               		.loc 4 353 0 is_stmt 1
 1246 052a 8F38      		cpi r24,lo8(-113)
 1247 052c 01F4      		brne .L85
 1248               		.loc 4 353 0 is_stmt 0 discriminator 1
 1249 052e 8091 0000 		lds r24,twdrbuffer
 1250 0532 8F3F      		cpi r24,lo8(-1)
 1251 0534 01F4      		brne .L86
 1252               		.loc 4 353 0 discriminator 2
 1253 0536 2E9A      		sbi 0x5,6
 1254 0538 00C0      		rjmp .L76
 1255               	.L86:
 1256               		.loc 4 353 0 discriminator 3
 1257 053a 2E98      		cbi 0x5,6
 1258 053c 00C0      		rjmp .L76
 1259               	.L85:
 354:main.c        ****       else if (commandbyte == 0x90 ) {if (twdrbuffer == 0xFF) {PORTC |= _BV(PC7);} else {PORTC &= ~
 1260               		.loc 4 354 0 is_stmt 1
 1261 053e 8039      		cpi r24,lo8(-112)
 1262 0540 01F4      		brne .L87
 1263               		.loc 4 354 0 is_stmt 0 discriminator 1
 1264 0542 8091 0000 		lds r24,twdrbuffer
 1265 0546 8F3F      		cpi r24,lo8(-1)
 1266 0548 01F4      		brne .L88
 1267               		.loc 4 354 0 discriminator 2
 1268 054a 479A      		sbi 0x8,7
 1269 054c 00C0      		rjmp .L76
 1270               	.L88:
 1271               		.loc 4 354 0 discriminator 3
 1272 054e 4798      		cbi 0x8,7
 1273 0550 00C0      		rjmp .L76
 1274               	.L87:
 355:main.c        ****       else if (commandbyte == 0x91 ) {if (twdrbuffer == 0xFF) {PORTE |=  (1<<2);}  else {PORTE &= ~
 1275               		.loc 4 355 0 is_stmt 1
 1276 0552 8139      		cpi r24,lo8(-111)
 1277 0554 01F4      		brne .L89
 1278               		.loc 4 355 0 is_stmt 0 discriminator 1
 1279 0556 8091 0000 		lds r24,twdrbuffer
 1280 055a 8F3F      		cpi r24,lo8(-1)
 1281 055c 01F4      		brne .L90
 1282               		.loc 4 355 0 discriminator 2
 1283 055e 729A      		sbi 0xe,2
 1284 0560 00C0      		rjmp .L76
 1285               	.L90:
 1286               		.loc 4 355 0 discriminator 3
 1287 0562 7298      		cbi 0xe,2
 1288 0564 00C0      		rjmp .L76
 1289               	.L89:
 356:main.c        ****       else if (commandbyte == 0x92 ) {if (twdrbuffer == 0xFF) {PORTB |= _BV(PB5);} else if (twdrbuf
 1290               		.loc 4 356 0 is_stmt 1
 1291 0566 8239      		cpi r24,lo8(-110)
 1292 0568 01F4      		brne .L91
 1293               		.loc 4 356 0 is_stmt 0 discriminator 1
 1294 056a 8091 0000 		lds r24,twdrbuffer
 1295 056e 8F3F      		cpi r24,lo8(-1)
 1296 0570 01F4      		brne .L92
 1297               		.loc 4 356 0 discriminator 2
 1298 0572 2D9A      		sbi 0x5,5
 1299 0574 00C0      		rjmp .L76
 1300               	.L92:
 1301               		.loc 4 356 0 discriminator 3
 1302 0576 8130      		cpi r24,lo8(1)
 1303 0578 01F4      		brne .L93
 1304               		.loc 4 356 0 discriminator 4
 1305 057a 2D9A      		sbi 0x5,5
 1306 057c 82E0      		ldi r24,lo8(2)
 1307 057e 8093 0000 		sts twdrbuffer,r24
 1308 0582 00C0      		rjmp .L76
 1309               	.L93:
 1310               		.loc 4 356 0 discriminator 5
 1311 0584 2D98      		cbi 0x5,5
 1312 0586 1092 0000 		sts twdrbuffer,__zero_reg__
 1313 058a 00C0      		rjmp .L76
 1314               	.L91:
 357:main.c        ****       else if (commandbyte == 0x93 ) {OCR0A = twdrbuffer;fanlevel = twdrbuffer;}  //set Vent
 1315               		.loc 4 357 0 is_stmt 1
 1316 058c 8339      		cpi r24,lo8(-109)
 1317 058e 01F4      		brne .L94
 1318               		.loc 4 357 0 is_stmt 0 discriminator 1
 1319 0590 8091 0000 		lds r24,twdrbuffer
 1320 0594 87BD      		out 0x27,r24
 1321 0596 8091 0000 		lds r24,twdrbuffer
 1322 059a 8093 0000 		sts fanlevel,r24
 1323 059e 00C0      		rjmp .L76
 1324               	.L94:
 358:main.c        ****       else if (commandbyte == 0x94 ) {led[0].r = twdrbuffer;changeled = 1;}  //set r color
 1325               		.loc 4 358 0 is_stmt 1
 1326 05a0 8439      		cpi r24,lo8(-108)
 1327 05a2 01F4      		brne .L95
 1328               		.loc 4 358 0 is_stmt 0 discriminator 1
 1329 05a4 8091 0000 		lds r24,twdrbuffer
 1330 05a8 8093 0000 		sts led+1,r24
 1331 05ac 00C0      		rjmp .L177
 1332               	.L95:
 359:main.c        ****       else if (commandbyte == 0x95 ) {led[0].g = twdrbuffer;changeled = 1;}  //set g color
 1333               		.loc 4 359 0 is_stmt 1
 1334 05ae 8539      		cpi r24,lo8(-107)
 1335 05b0 01F4      		brne .L96
 1336               		.loc 4 359 0 is_stmt 0 discriminator 1
 1337 05b2 8091 0000 		lds r24,twdrbuffer
 1338 05b6 8093 0000 		sts led,r24
 1339 05ba 00C0      		rjmp .L177
 1340               	.L96:
 360:main.c        ****       else if (commandbyte == 0x96 ) {led[0].b = twdrbuffer;changeled = 1;}  //set b color
 1341               		.loc 4 360 0 is_stmt 1
 1342 05bc 8639      		cpi r24,lo8(-106)
 1343 05be 01F4      		brne .L77
 1344               		.loc 4 360 0 is_stmt 0 discriminator 1
 1345 05c0 8091 0000 		lds r24,twdrbuffer
 1346 05c4 8093 0000 		sts led+2,r24
 1347               	.L177:
 1348 05c8 81E0      		ldi r24,lo8(1)
 1349 05ca 8093 0000 		sts changeled,r24
 1350 05ce 00C0      		rjmp .L76
 1351               	.L77:
 361:main.c        **** 
 362:main.c        ****       else {i2cerror++;} 
 1352               		.loc 4 362 0 is_stmt 1
 1353 05d0 8091 0000 		lds r24,i2cerror
 1354 05d4 8F5F      		subi r24,lo8(-(1))
 1355 05d6 8093 0000 		sts i2cerror,r24
 1356               	.L76:
 363:main.c        ****       } 
 364:main.c        ****       else {i2cerror++;}
 365:main.c        **** 
 366:main.c        ****       buffer_address++;
 1357               		.loc 4 366 0
 1358 05da 8091 0000 		lds r24,buffer_address
 1359 05de 8F5F      		subi r24,lo8(-(1))
 1360 05e0 8093 0000 		sts buffer_address,r24
 1361               	.L61:
 367:main.c        **** 
 368:main.c        ****       }
 369:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1362               		.loc 4 369 0
 1363 05e4 85EC      		ldi r24,lo8(-59)
 1364 05e6 8093 BC00 		sts 188,r24
 370:main.c        ****       if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1365               		.loc 4 370 0
 1366 05ea 8091 0000 		lds r24,commandbyte
 1367 05ee 8239      		cpi r24,lo8(-110)
 1368 05f0 01F0      		breq .+2
 1369 05f2 00C0      		rjmp .L52
 1370 05f4 8091 0000 		lds r24,twdrbuffer
 1371 05f8 8230      		cpi r24,lo8(2)
 1372 05fa 01F0      		breq .+2
 1373 05fc 00C0      		rjmp .L52
 1374               	.LVL73:
 1375               	.LBB80:
 1376               	.LBB81:
 1377               		.loc 3 276 0
 1378 05fe 85E8      		ldi r24,lo8(-123)
 1379 0600 8A95      	1:	dec r24
 1380 0602 01F4      		brne 1b
 1381 0604 0000      		nop
 1382               	.LVL74:
 1383               	.LBE81:
 1384               	.LBE80:
 1385               		.loc 4 370 0
 1386 0606 2D98      		cbi 0x5,5
 1387 0608 00C0      		rjmp .L52
 1388               	.L58:
 1389               	.LVL75:
 1390               	.LBB82:
 1391               	.LBB83:
 1392               		.loc 3 276 0
 1393 060a 00C0      		rjmp .
 1394 060c 00C0      		rjmp .
 1395 060e 0000      		nop
 1396               	.LVL76:
 1397               	.LBE83:
 1398               	.LBE82:
 371:main.c        ****       break;
 372:main.c        **** 
 373:main.c        ****     case TW_ST_SLA_ACK: //  slave adressed
 374:main.c        ****     case TW_ST_DATA_ACK:
 375:main.c        ****       
 376:main.c        ****       _delay_us(0.3); 
 377:main.c        **** 
 378:main.c        **** 	     switch(commandbyte)  {		 
 1399               		.loc 4 378 0
 1400 0610 8091 0000 		lds r24,commandbyte
 1401 0614 8F30      		cpi r24,lo8(15)
 1402 0616 01F4      		brne .+2
 1403 0618 00C0      		rjmp .L100
 1404 061a 00F4      		brsh .L101
 1405 061c 9091 0000 		lds r25,buffer_address
 1406 0620 8C30      		cpi r24,lo8(12)
 1407 0622 00F4      		brsh .L102
 1408 0624 8830      		cpi r24,lo8(8)
 1409 0626 00F4      		brsh .L103
 1410 0628 8730      		cpi r24,lo8(7)
 1411 062a 00F0      		brlo .+2
 1412 062c 00C0      		rjmp .L174
 1413 062e 00C0      		rjmp .L103
 1414               	.L102:
 1415 0630 8D30      		cpi r24,lo8(13)
 1416 0632 01F4      		brne .+2
 1417 0634 00C0      		rjmp .L105
 1418 0636 00F0      		brlo .L175
 1419 0638 00C0      		rjmp .L192
 1420               	.L101:
 1421 063a 8331      		cpi r24,lo8(19)
 1422 063c 01F4      		brne .+2
 1423 063e 00C0      		rjmp .L108
 1424 0640 00F4      		brsh .L109
 1425 0642 9091 0000 		lds r25,buffer_address
 1426 0646 8131      		cpi r24,lo8(17)
 1427 0648 01F4      		brne .+2
 1428 064a 00C0      		rjmp .L110
 1429 064c 00F4      		brsh .+2
 1430 064e 00C0      		rjmp .L176
 1431 0650 00C0      		rjmp .L193
 1432               	.L109:
 1433 0652 8738      		cpi r24,lo8(-121)
 1434 0654 01F0      		breq .L113
 1435 0656 00F4      		brsh .L114
 1436 0658 8431      		cpi r24,lo8(20)
 1437 065a 01F0      		breq .L103
 1438 065c 00C0      		rjmp .L99
 1439               	.L114:
 1440 065e 8D58      		subi r24,lo8(-(115))
 1441 0660 8A30      		cpi r24,lo8(10)
 1442 0662 00F0      		brlo .+2
 1443 0664 00C0      		rjmp .L99
 1444               	.L113:
 379:main.c        **** 
 380:main.c        ****                  case 0x87:
 381:main.c        ****                  case 0x8D:
 382:main.c        ****                  case 0x8E:
 383:main.c        ****                  case 0x8F:
 384:main.c        ****                  case 0x90:
 385:main.c        ****                  case 0x91:
 386:main.c        ****                  case 0x92:
 387:main.c        ****                  case 0x93:
 388:main.c        ****                  case 0x94:
 389:main.c        ****                  case 0x95:
 390:main.c        ****                  case 0x96:  { TWDR = crc;  crc = 0xFF;} break;
 1445               		.loc 4 390 0
 1446 0666 8091 0000 		lds r24,crc
 1447 066a 8093 BB00 		sts 187,r24
 1448 066e 8FEF      		ldi r24,lo8(-1)
 1449 0670 00C0      		rjmp .L182
 1450               	.L103:
 391:main.c        ****                  case 0x00:
 392:main.c        ****                  case 0x01:
 393:main.c        ****                  case 0x02:
 394:main.c        ****                  case 0x03:
 395:main.c        ****                  case 0x04:
 396:main.c        ****                  case 0x05:
 397:main.c        ****                  case 0x06:
 398:main.c        ****                  case 0x08: 
 399:main.c        ****                  case 0x09: 
 400:main.c        ****                  case 0x0A: 
 401:main.c        ****                  case 0x0B: 
 402:main.c        ****                  case 0x14:      
 403:main.c        ****                                  if (buffer_address == 0) {TWDR = i2cbuffer & 0xFF; crc = _crc8_cci
 1451               		.loc 4 403 0
 1452 0672 8091 0000 		lds r24,buffer_address
 1453 0676 8111      		cpse r24,__zero_reg__
 1454 0678 00C0      		rjmp .L116
 1455               		.loc 4 403 0 is_stmt 0 discriminator 1
 1456 067a 8091 0000 		lds r24,i2cbuffer
 1457 067e 00C0      		rjmp .L180
 1458               	.L116:
 404:main.c        ****                             else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_cci
 1459               		.loc 4 404 0 is_stmt 1
 1460 0680 8130      		cpi r24,lo8(1)
 1461 0682 01F4      		brne .L117
 1462               		.loc 4 404 0 is_stmt 0 discriminator 1
 1463 0684 8091 0000 		lds r24,i2cbuffer+1
 1464 0688 00C0      		rjmp .L180
 1465               	.L117:
 405:main.c        ****                             else if (buffer_address == 2) {TWDR = crc;}
 1466               		.loc 4 405 0 is_stmt 1
 1467 068a 8230      		cpi r24,lo8(2)
 1468 068c 01F0      		breq .+2
 1469 068e 00C0      		rjmp .L150
 1470 0690 00C0      		rjmp .L185
 1471               	.L175:
 406:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 407:main.c        ****                             break; 
 408:main.c        ****                            
 409:main.c        ****                  case 0x0C:     
 410:main.c        ****                                 if (buffer_address == 0)  {TWDR = led[0].r; crc = _crc8_ccitt_updat
 1472               		.loc 4 410 0
 1473 0692 9111      		cpse r25,__zero_reg__
 1474 0694 00C0      		rjmp .L119
 1475               		.loc 4 410 0 is_stmt 0 discriminator 1
 1476 0696 8091 0000 		lds r24,led+1
 1477               	.L180:
 1478 069a 8093 BB00 		sts 187,r24
 1479               	.L183:
 1480 069e 6091 BB00 		lds r22,187
 1481 06a2 8091 0000 		lds r24,crc
 1482 06a6 0E94 0000 		call _crc8_ccitt_update
 1483               	.LVL77:
 1484               	.L182:
 1485 06aa 8093 0000 		sts crc,r24
 1486 06ae 00C0      		rjmp .L115
 1487               	.L119:
 411:main.c        ****                            else if (buffer_address == 1)  {TWDR = led[0].g; crc = _crc8_ccitt_updat
 1488               		.loc 4 411 0 is_stmt 1
 1489 06b0 9130      		cpi r25,lo8(1)
 1490 06b2 01F4      		brne .L120
 1491               		.loc 4 411 0 is_stmt 0 discriminator 1
 1492 06b4 8091 0000 		lds r24,led
 1493 06b8 00C0      		rjmp .L180
 1494               	.L120:
 412:main.c        ****                            else if (buffer_address == 2)  {TWDR = led[0].b; crc = _crc8_ccitt_updat
 1495               		.loc 4 412 0 is_stmt 1
 1496 06ba 9230      		cpi r25,lo8(2)
 1497 06bc 01F4      		brne .L121
 1498               		.loc 4 412 0 is_stmt 0 discriminator 1
 1499 06be 8091 0000 		lds r24,led+2
 1500 06c2 00C0      		rjmp .L180
 1501               	.L121:
 413:main.c        ****                            else if (buffer_address == 3)  {TWDR = crc;}
 1502               		.loc 4 413 0 is_stmt 1
 1503 06c4 9330      		cpi r25,lo8(3)
 1504 06c6 01F0      		breq .+2
 1505 06c8 00C0      		rjmp .L150
 1506 06ca 00C0      		rjmp .L185
 1507               	.L174:
 414:main.c        ****                            else                           {TWDR = 0xFF;  i2cerror++;}
 415:main.c        ****                            break; 
 416:main.c        **** 
 417:main.c        ****                  case 0x07:          
 418:main.c        ****                                      if (buffer_address == 0) {TWDR = bllevel; crc = _crc8_ccitt_up
 1508               		.loc 4 418 0
 1509 06cc 9111      		cpse r25,__zero_reg__
 1510 06ce 00C0      		rjmp .L145
 1511               		.loc 4 418 0 is_stmt 0 discriminator 1
 1512 06d0 8091 0000 		lds r24,bllevel
 1513 06d4 00C0      		rjmp .L180
 1514               	.L105:
 419:main.c        ****                                 else if (buffer_address == 1) {TWDR = crc;}
 420:main.c        ****                                 else                         {TWDR = 0xFF; i2cerror++;}
 421:main.c        ****                                 break;
 422:main.c        **** 
 423:main.c        **** 
 424:main.c        ****                  case 0x0D:      
 425:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC6)) {TWDR = 0xFF;}
 1515               		.loc 4 425 0 is_stmt 1
 1516 06d6 9111      		cpse r25,__zero_reg__
 1517 06d8 00C0      		rjmp .L145
 1518               		.loc 4 425 0 is_stmt 0 discriminator 1
 1519 06da 369B      		sbis 0x6,6
 1520 06dc 00C0      		rjmp .L146
 1521 06de 00C0      		rjmp .L191
 1522               	.L192:
 426:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 427:main.c        ****                             else {TWDR = 0xFF; i2cerror++;}
 428:main.c        ****                             break;
 429:main.c        **** 
 430:main.c        ****                  case 0x0E:     
 431:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PIND,PD7)) {TWDR = 0xFF;}
 1523               		.loc 4 431 0 is_stmt 1
 1524 06e0 9111      		cpse r25,__zero_reg__
 1525 06e2 00C0      		rjmp .L145
 1526               		.loc 4 431 0 is_stmt 0 discriminator 1
 1527 06e4 4F9B      		sbis 0x9,7
 1528 06e6 00C0      		rjmp .L146
 1529 06e8 00C0      		rjmp .L191
 1530               	.L100:
 432:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 433:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 434:main.c        ****                             break;
 435:main.c        **** 
 436:main.c        **** 
 437:main.c        ****                  case 0x0F:     
 438:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINB,PB6)) {TWDR = 0xFF;}
 1531               		.loc 4 438 0 is_stmt 1
 1532 06ea 8091 0000 		lds r24,buffer_address
 1533 06ee 8111      		cpse r24,__zero_reg__
 1534 06f0 00C0      		rjmp .L149
 1535               		.loc 4 438 0 is_stmt 0 discriminator 1
 1536 06f2 1E9B      		sbis 0x3,6
 1537 06f4 00C0      		rjmp .L146
 1538 06f6 00C0      		rjmp .L191
 1539               	.L176:
 439:main.c        ****                             else if (buffer_address == 1) { TWDR = crc;}
 440:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 441:main.c        ****                             break;
 442:main.c        **** 
 443:main.c        ****                  case 0x10:  
 444:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINC,PC7)) {TWDR = 0xFF;}
 1540               		.loc 4 444 0 is_stmt 1
 1541 06f8 9111      		cpse r25,__zero_reg__
 1542 06fa 00C0      		rjmp .L145
 1543               		.loc 4 444 0 is_stmt 0 discriminator 1
 1544 06fc 379B      		sbis 0x6,7
 1545 06fe 00C0      		rjmp .L146
 1546 0700 00C0      		rjmp .L191
 1547               	.L110:
 445:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 446:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 447:main.c        ****                             break;
 448:main.c        **** 
 449:main.c        **** 
 450:main.c        ****                  case 0x11:  
 451:main.c        ****                                  if (buffer_address == 0) {if (bit_is_set(PINE,PE2)) {TWDR = 0xFF;}
 1548               		.loc 4 451 0 is_stmt 1
 1549 0702 9111      		cpse r25,__zero_reg__
 1550 0704 00C0      		rjmp .L141
 1551               		.loc 4 451 0 is_stmt 0 discriminator 1
 1552 0706 629B      		sbis 0xc,2
 1553 0708 00C0      		rjmp .L146
 1554 070a 00C0      		rjmp .L191
 1555               	.L141:
 452:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1556               		.loc 4 452 0 is_stmt 1
 1557 070c 9130      		cpi r25,lo8(1)
 1558 070e 01F0      		breq .L185
 453:main.c        ****                             else                          {TWDR = 0xFF; buffer_address = 0xFE; i2ce
 1559               		.loc 4 453 0
 1560 0710 8FEF      		ldi r24,lo8(-1)
 1561 0712 8093 BB00 		sts 187,r24
 1562 0716 8EEF      		ldi r24,lo8(-2)
 1563 0718 8093 0000 		sts buffer_address,r24
 1564 071c 00C0      		rjmp .L181
 1565               	.L193:
 454:main.c        ****                             break;
 455:main.c        **** 
 456:main.c        **** 
 457:main.c        ****                  case 0x12:  
 458:main.c        ****                                  if (buffer_address == 0)  {if (bit_is_set(PINB,PB5)) {TWDR = 0xFF;
 1566               		.loc 4 458 0
 1567 071e 9111      		cpse r25,__zero_reg__
 1568 0720 00C0      		rjmp .L145
 1569               		.loc 4 458 0 is_stmt 0 discriminator 1
 1570 0722 1D9B      		sbis 0x3,5
 1571 0724 00C0      		rjmp .L146
 1572               	.L191:
 1573               		.loc 4 458 0 discriminator 2
 1574 0726 8FEF      		ldi r24,lo8(-1)
 1575 0728 00C0      		rjmp .L180
 1576               	.L146:
 1577               		.loc 4 458 0 discriminator 3
 1578 072a 1092 BB00 		sts 187,__zero_reg__
 1579 072e 00C0      		rjmp .L183
 1580               	.L145:
 459:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1581               		.loc 4 459 0 is_stmt 1
 1582 0730 9130      		cpi r25,lo8(1)
 1583 0732 01F4      		brne .L150
 1584 0734 00C0      		rjmp .L185
 1585               	.L108:
 460:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 461:main.c        ****                             break;
 462:main.c        **** 
 463:main.c        **** 
 464:main.c        ****                  case 0x13:  
 465:main.c        ****                                  if (buffer_address == 0) {TWDR = OCR0A; crc = _crc8_ccitt_update(c
 1586               		.loc 4 465 0
 1587 0736 8091 0000 		lds r24,buffer_address
 1588 073a 8111      		cpse r24,__zero_reg__
 1589 073c 00C0      		rjmp .L149
 1590               		.loc 4 465 0 is_stmt 0 discriminator 1
 1591 073e 87B5      		in r24,0x27
 1592 0740 00C0      		rjmp .L180
 1593               	.L149:
 466:main.c        ****                             else if (buffer_address == 1) {TWDR = crc;}
 1594               		.loc 4 466 0 is_stmt 1
 1595 0742 8130      		cpi r24,lo8(1)
 1596 0744 01F4      		brne .L150
 1597               	.L185:
 1598               		.loc 4 466 0 is_stmt 0 discriminator 1
 1599 0746 8091 0000 		lds r24,crc
 1600 074a 00C0      		rjmp .L179
 1601               	.L150:
 467:main.c        ****                             else                          {TWDR = 0xFF; i2cerror++;}
 1602               		.loc 4 467 0 is_stmt 1
 1603 074c 8FEF      		ldi r24,lo8(-1)
 1604 074e 8093 BB00 		sts 187,r24
 1605               	.L181:
 1606 0752 8091 0000 		lds r24,i2cerror
 1607 0756 8F5F      		subi r24,lo8(-(1))
 1608 0758 8093 0000 		sts i2cerror,r24
 1609 075c 00C0      		rjmp .L115
 1610               	.L99:
 468:main.c        ****                             break;
 469:main.c        **** 
 470:main.c        **** 
 471:main.c        ****                  default: TWDR = 0xFF; 
 1611               		.loc 4 471 0
 1612 075e 8FEF      		ldi r24,lo8(-1)
 1613               	.L179:
 1614 0760 8093 BB00 		sts 187,r24
 1615               	.L115:
 472:main.c        **** 
 473:main.c        **** 		 }	 
 474:main.c        **** 
 475:main.c        **** 
 476:main.c        **** 
 477:main.c        ****       
 478:main.c        ****       buffer_address++;
 1616               		.loc 4 478 0
 1617 0764 8091 0000 		lds r24,buffer_address
 1618 0768 8F5F      		subi r24,lo8(-(1))
 1619 076a 8093 0000 		sts buffer_address,r24
 1620 076e 00C0      		rjmp .L53
 1621               	.L56:
 479:main.c        ****       TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);        
 480:main.c        ****       break;                                 
 481:main.c        ****    
 482:main.c        ****     case TW_BUS_ERROR:   
 483:main.c        ****      TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1622               		.loc 4 483 0
 1623 0770 85ED      		ldi r24,lo8(-43)
 1624 0772 00C0      		rjmp .L184
 1625               	.L53:
 484:main.c        ****      break;
 485:main.c        **** 
 486:main.c        **** 
 487:main.c        ****     //case TW_SR_STOP:  TWCR |= (1<<TWINT)|(1<<TWEA)|(1<<TWEN);  break;
 488:main.c        **** 
 489:main.c        ****     default:         
 490:main.c        ****       TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)| (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|  (0<<TWWC);   
 1626               		.loc 4 490 0
 1627 0774 85EC      		ldi r24,lo8(-59)
 1628               	.L184:
 1629 0776 8093 BC00 		sts 188,r24
 1630               	.L52:
 1631               	/* epilogue start */
 491:main.c        ****                                                                                                    
 492:main.c        ****       
 493:main.c        ****   }
 494:main.c        **** 
 495:main.c        **** 
 496:main.c        **** 
 497:main.c        **** }
 1632               		.loc 4 497 0
 1633 077a FF91      		pop r31
 1634 077c EF91      		pop r30
 1635 077e BF91      		pop r27
 1636 0780 AF91      		pop r26
 1637 0782 9F91      		pop r25
 1638 0784 8F91      		pop r24
 1639 0786 7F91      		pop r23
 1640 0788 6F91      		pop r22
 1641 078a 5F91      		pop r21
 1642 078c 4F91      		pop r20
 1643 078e 3F91      		pop r19
 1644 0790 2F91      		pop r18
 1645 0792 0F90      		pop r0
 1646 0794 0FBE      		out __SREG__,r0
 1647 0796 0F90      		pop r0
 1648 0798 1F90      		pop r1
 1649 079a 1895      		reti
 1650               		.cfi_endproc
 1651               	.LFE35:
 1653               	.global	setup
 1655               	setup:
 1656               	.LFB36:
 498:main.c        **** 
 499:main.c        **** 
 500:main.c        **** void setup(void)
 501:main.c        **** {
 1657               		.loc 4 501 0
 1658               		.cfi_startproc
 1659 079c CF93      		push r28
 1660               	.LCFI28:
 1661               		.cfi_def_cfa_offset 3
 1662               		.cfi_offset 28, -2
 1663 079e DF93      		push r29
 1664               	.LCFI29:
 1665               		.cfi_def_cfa_offset 4
 1666               		.cfi_offset 29, -3
 1667               	/* prologue: function */
 1668               	/* frame size = 0 */
 1669               	/* stack size = 2 */
 1670               	.L__stack_usage = 2
 502:main.c        ****    DDRF = 0b00000000;
 1671               		.loc 4 502 0
 1672 07a0 10BA      		out 0x10,__zero_reg__
 503:main.c        ****    DDRD = 0b11111000;
 1673               		.loc 4 503 0
 1674 07a2 88EF      		ldi r24,lo8(-8)
 1675 07a4 8AB9      		out 0xa,r24
 504:main.c        ****    PORTD= 0b00000000;
 1676               		.loc 4 504 0
 1677 07a6 1BB8      		out 0xb,__zero_reg__
 505:main.c        ****    DDRE = 0b00000000; 
 1678               		.loc 4 505 0
 1679 07a8 1DB8      		out 0xd,__zero_reg__
 506:main.c        ****    DDRE |= (1<<2);   // be carefull with hwb, check if its connected to GND via 10k (prototypes!)
 1680               		.loc 4 506 0
 1681 07aa 6A9A      		sbi 0xd,2
 507:main.c        ****    DDRB = 0b11100110;
 1682               		.loc 4 507 0
 1683 07ac 86EE      		ldi r24,lo8(-26)
 1684 07ae 84B9      		out 0x4,r24
 508:main.c        ****    DDRC = 0b11000000;
 1685               		.loc 4 508 0
 1686 07b0 80EC      		ldi r24,lo8(-64)
 1687 07b2 87B9      		out 0x7,r24
 509:main.c        ****    OCR0A = 0;           //    start value for FAN  0 / 255  (-> p-channel so inverted)       0x00 i
 1688               		.loc 4 509 0
 1689 07b4 17BC      		out 0x27,__zero_reg__
 510:main.c        ****    TCCR0B  =  0b00000001;
 1690               		.loc 4 510 0
 1691 07b6 81E0      		ldi r24,lo8(1)
 1692 07b8 85BD      		out 0x25,r24
 511:main.c        ****    TCCR0A  =  0b10000011;            // 8bit  62khz
 1693               		.loc 4 511 0
 1694 07ba 83E8      		ldi r24,lo8(-125)
 1695 07bc 84BD      		out 0x24,r24
 512:main.c        ****    TIMSK0 |= (1 << TOIE0);            // init interrupt for timer0 overflow
 1696               		.loc 4 512 0
 1697 07be EEE6      		ldi r30,lo8(110)
 1698 07c0 F0E0      		ldi r31,0
 1699 07c2 8081      		ld r24,Z
 1700 07c4 8160      		ori r24,lo8(1)
 1701 07c6 8083      		st Z,r24
 1702               	.LVL78:
 1703               	.LBB84:
 1704               	.LBB85:
 1705               		.file 5 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/power.h **** 
   5:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/power.h **** 
   8:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/avr/power.h ****      distribution.
  14:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/lib/avr/include/avr/power.h **** 
  18:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/lib/avr/include/avr/power.h **** 
  30:/usr/lib/avr/include/avr/power.h **** /* $Id$ */
  31:/usr/lib/avr/include/avr/power.h **** 
  32:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/lib/avr/include/avr/power.h **** 
  35:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** 
  39:/usr/lib/avr/include/avr/power.h **** /** \file */
  40:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  41:/usr/lib/avr/include/avr/power.h **** 
  42:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  43:/usr/lib/avr/include/avr/power.h **** 
  44:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  45:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  46:/usr/lib/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  47:/usr/lib/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  48:/usr/lib/avr/include/avr/power.h **** Register (CLKPR).
  49:/usr/lib/avr/include/avr/power.h **** 
  50:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  51:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  52:/usr/lib/avr/include/avr/power.h **** 
  53:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  54:/usr/lib/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  55:/usr/lib/avr/include/avr/power.h **** power reduction macros are not available..
  56:/usr/lib/avr/include/avr/power.h **** 
  57:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  58:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  59:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  60:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  61:/usr/lib/avr/include/avr/power.h **** 
  62:/usr/lib/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  63:/usr/lib/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  64:/usr/lib/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  65:/usr/lib/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  66:/usr/lib/avr/include/avr/power.h **** the clock below 131.072 kHz.
  67:/usr/lib/avr/include/avr/power.h **** 
  68:/usr/lib/avr/include/avr/power.h **** */
  69:/usr/lib/avr/include/avr/power.h **** 
  70:/usr/lib/avr/include/avr/power.h **** 
  71:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  72:/usr/lib/avr/include/avr/power.h **** 
  73:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  74:/usr/lib/avr/include/avr/power.h **** <small>
  75:/usr/lib/avr/include/avr/power.h **** <center>
  76:/usr/lib/avr/include/avr/power.h **** <table border="3">
  77:/usr/lib/avr/include/avr/power.h ****   <tr>
  78:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  79:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  80:/usr/lib/avr/include/avr/power.h ****   </tr>
  81:/usr/lib/avr/include/avr/power.h **** 
  82:/usr/lib/avr/include/avr/power.h ****   <tr>
  83:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  84:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  85:/usr/lib/avr/include/avr/power.h ****   </tr>
  86:/usr/lib/avr/include/avr/power.h **** 
  87:/usr/lib/avr/include/avr/power.h ****   <tr>
  88:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  89:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  90:/usr/lib/avr/include/avr/power.h ****   </tr>
  91:/usr/lib/avr/include/avr/power.h **** 
  92:/usr/lib/avr/include/avr/power.h ****   <tr>
  93:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  94:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  95:/usr/lib/avr/include/avr/power.h ****   </tr>
  96:/usr/lib/avr/include/avr/power.h **** 
  97:/usr/lib/avr/include/avr/power.h ****   <tr>
  98:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  99:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
 100:/usr/lib/avr/include/avr/power.h ****   </tr>
 101:/usr/lib/avr/include/avr/power.h **** 
 102:/usr/lib/avr/include/avr/power.h ****   <tr>
 103:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 104:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 105:/usr/lib/avr/include/avr/power.h ****   </tr>
 106:/usr/lib/avr/include/avr/power.h **** 
 107:/usr/lib/avr/include/avr/power.h ****   <tr>
 108:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 109:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 110:/usr/lib/avr/include/avr/power.h ****   </tr>
 111:/usr/lib/avr/include/avr/power.h **** 
 112:/usr/lib/avr/include/avr/power.h ****   <tr>
 113:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 114:/usr/lib/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 115:/usr/lib/avr/include/avr/power.h ****   </tr>
 116:/usr/lib/avr/include/avr/power.h **** 
 117:/usr/lib/avr/include/avr/power.h ****   <tr>
 118:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 119:/usr/lib/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 120:/usr/lib/avr/include/avr/power.h ****   </tr>
 121:/usr/lib/avr/include/avr/power.h **** 
 122:/usr/lib/avr/include/avr/power.h ****   <tr>
 123:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 124:/usr/lib/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 125:/usr/lib/avr/include/avr/power.h ****   </tr>
 126:/usr/lib/avr/include/avr/power.h **** 
 127:/usr/lib/avr/include/avr/power.h ****   <tr>
 128:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 129:/usr/lib/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 130:/usr/lib/avr/include/avr/power.h ****   </tr>
 131:/usr/lib/avr/include/avr/power.h **** 
 132:/usr/lib/avr/include/avr/power.h ****    <tr>
 133:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 134:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 135:/usr/lib/avr/include/avr/power.h ****   </tr>
 136:/usr/lib/avr/include/avr/power.h **** 
 137:/usr/lib/avr/include/avr/power.h ****   <tr>
 138:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 139:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 140:/usr/lib/avr/include/avr/power.h ****   </tr>
 141:/usr/lib/avr/include/avr/power.h **** 
 142:/usr/lib/avr/include/avr/power.h ****   <tr>
 143:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 144:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 145:/usr/lib/avr/include/avr/power.h ****   </tr>
 146:/usr/lib/avr/include/avr/power.h **** 
 147:/usr/lib/avr/include/avr/power.h ****   <tr>
 148:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 149:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 150:/usr/lib/avr/include/avr/power.h ****   </tr>
 151:/usr/lib/avr/include/avr/power.h ****   
 152:/usr/lib/avr/include/avr/power.h ****   <tr>
 153:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 154:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 155:/usr/lib/avr/include/avr/power.h ****   </tr>
 156:/usr/lib/avr/include/avr/power.h **** 
 157:/usr/lib/avr/include/avr/power.h ****   <tr>
 158:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 159:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 160:/usr/lib/avr/include/avr/power.h ****   </tr>
 161:/usr/lib/avr/include/avr/power.h **** 
 162:/usr/lib/avr/include/avr/power.h ****   <tr>
 163:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 164:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 165:/usr/lib/avr/include/avr/power.h ****   </tr>
 166:/usr/lib/avr/include/avr/power.h **** 
 167:/usr/lib/avr/include/avr/power.h ****   <tr>
 168:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 169:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 170:/usr/lib/avr/include/avr/power.h ****   </tr>
 171:/usr/lib/avr/include/avr/power.h **** 
 172:/usr/lib/avr/include/avr/power.h ****   <tr>
 173:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 174:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 175:/usr/lib/avr/include/avr/power.h ****   </tr>
 176:/usr/lib/avr/include/avr/power.h **** 
 177:/usr/lib/avr/include/avr/power.h ****   <tr>
 178:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 179:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 180:/usr/lib/avr/include/avr/power.h ****   </tr>
 181:/usr/lib/avr/include/avr/power.h **** 
 182:/usr/lib/avr/include/avr/power.h ****   <tr>
 183:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 184:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 185:/usr/lib/avr/include/avr/power.h ****   </tr>
 186:/usr/lib/avr/include/avr/power.h **** 
 187:/usr/lib/avr/include/avr/power.h ****   <tr>
 188:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 189:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 190:/usr/lib/avr/include/avr/power.h ****   </tr>
 191:/usr/lib/avr/include/avr/power.h **** 
 192:/usr/lib/avr/include/avr/power.h ****   <tr>
 193:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 194:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 195:/usr/lib/avr/include/avr/power.h ****   </tr>
 196:/usr/lib/avr/include/avr/power.h **** 
 197:/usr/lib/avr/include/avr/power.h ****   <tr>
 198:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 199:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 200:/usr/lib/avr/include/avr/power.h ****   </tr>
 201:/usr/lib/avr/include/avr/power.h **** 
 202:/usr/lib/avr/include/avr/power.h ****   <tr>
 203:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 204:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 205:/usr/lib/avr/include/avr/power.h ****   </tr>
 206:/usr/lib/avr/include/avr/power.h **** 
 207:/usr/lib/avr/include/avr/power.h ****   <tr>
 208:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 209:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 210:/usr/lib/avr/include/avr/power.h ****   </tr>
 211:/usr/lib/avr/include/avr/power.h **** 
 212:/usr/lib/avr/include/avr/power.h ****   <tr>
 213:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 214:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 215:/usr/lib/avr/include/avr/power.h ****   </tr>
 216:/usr/lib/avr/include/avr/power.h **** 
 217:/usr/lib/avr/include/avr/power.h ****   <tr>
 218:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 219:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 220:/usr/lib/avr/include/avr/power.h ****   </tr>
 221:/usr/lib/avr/include/avr/power.h **** 
 222:/usr/lib/avr/include/avr/power.h ****   <tr>
 223:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 224:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 225:/usr/lib/avr/include/avr/power.h ****   </tr>
 226:/usr/lib/avr/include/avr/power.h **** 
 227:/usr/lib/avr/include/avr/power.h ****   <tr>
 228:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 229:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 230:/usr/lib/avr/include/avr/power.h ****   </tr>
 231:/usr/lib/avr/include/avr/power.h **** 
 232:/usr/lib/avr/include/avr/power.h ****   <tr>
 233:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 234:/usr/lib/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 235:/usr/lib/avr/include/avr/power.h ****   </tr>
 236:/usr/lib/avr/include/avr/power.h **** 
 237:/usr/lib/avr/include/avr/power.h ****   <tr>
 238:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 239:/usr/lib/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 240:/usr/lib/avr/include/avr/power.h ****   </tr>
 241:/usr/lib/avr/include/avr/power.h **** 
 242:/usr/lib/avr/include/avr/power.h ****   <tr>
 243:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 244:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 245:/usr/lib/avr/include/avr/power.h ****   </tr>
 246:/usr/lib/avr/include/avr/power.h **** 
 247:/usr/lib/avr/include/avr/power.h ****   <tr>
 248:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 249:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 250:/usr/lib/avr/include/avr/power.h ****   </tr>
 251:/usr/lib/avr/include/avr/power.h **** 
 252:/usr/lib/avr/include/avr/power.h ****   <tr>
 253:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 254:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 255:/usr/lib/avr/include/avr/power.h ****   </tr>
 256:/usr/lib/avr/include/avr/power.h **** 
 257:/usr/lib/avr/include/avr/power.h ****   <tr>
 258:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 259:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 260:/usr/lib/avr/include/avr/power.h ****   </tr>
 261:/usr/lib/avr/include/avr/power.h **** 
 262:/usr/lib/avr/include/avr/power.h ****   <tr>
 263:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 264:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 265:/usr/lib/avr/include/avr/power.h ****   </tr>
 266:/usr/lib/avr/include/avr/power.h **** 
 267:/usr/lib/avr/include/avr/power.h ****   <tr>
 268:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 269:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 270:/usr/lib/avr/include/avr/power.h ****   </tr>
 271:/usr/lib/avr/include/avr/power.h **** 
 272:/usr/lib/avr/include/avr/power.h ****   <tr>
 273:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 274:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 275:/usr/lib/avr/include/avr/power.h ****   </tr>
 276:/usr/lib/avr/include/avr/power.h **** 
 277:/usr/lib/avr/include/avr/power.h ****   <tr>
 278:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 279:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 280:/usr/lib/avr/include/avr/power.h ****   </tr>
 281:/usr/lib/avr/include/avr/power.h **** 
 282:/usr/lib/avr/include/avr/power.h ****   <tr>
 283:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 284:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 285:/usr/lib/avr/include/avr/power.h ****   </tr>
 286:/usr/lib/avr/include/avr/power.h **** 
 287:/usr/lib/avr/include/avr/power.h ****   <tr>
 288:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 289:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 290:/usr/lib/avr/include/avr/power.h ****   </tr>
 291:/usr/lib/avr/include/avr/power.h **** 
 292:/usr/lib/avr/include/avr/power.h ****   <tr>
 293:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 294:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 295:/usr/lib/avr/include/avr/power.h ****   </tr>
 296:/usr/lib/avr/include/avr/power.h **** 
 297:/usr/lib/avr/include/avr/power.h ****   <tr>
 298:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 299:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 300:/usr/lib/avr/include/avr/power.h ****   </tr>
 301:/usr/lib/avr/include/avr/power.h **** 
 302:/usr/lib/avr/include/avr/power.h ****   <tr>
 303:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 304:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 305:/usr/lib/avr/include/avr/power.h ****   </tr>
 306:/usr/lib/avr/include/avr/power.h **** 
 307:/usr/lib/avr/include/avr/power.h ****   <tr>
 308:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 309:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 310:/usr/lib/avr/include/avr/power.h ****   </tr>
 311:/usr/lib/avr/include/avr/power.h **** 
 312:/usr/lib/avr/include/avr/power.h ****   <tr>
 313:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 314:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 315:/usr/lib/avr/include/avr/power.h ****   </tr>
 316:/usr/lib/avr/include/avr/power.h **** 
 317:/usr/lib/avr/include/avr/power.h ****   <tr>
 318:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 319:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 320:/usr/lib/avr/include/avr/power.h ****   </tr>
 321:/usr/lib/avr/include/avr/power.h **** 
 322:/usr/lib/avr/include/avr/power.h ****   <tr>
 323:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 324:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 325:/usr/lib/avr/include/avr/power.h ****   </tr>
 326:/usr/lib/avr/include/avr/power.h **** 
 327:/usr/lib/avr/include/avr/power.h ****   <tr>
 328:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 329:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 330:/usr/lib/avr/include/avr/power.h ****   </tr>
 331:/usr/lib/avr/include/avr/power.h **** 
 332:/usr/lib/avr/include/avr/power.h ****   <tr>
 333:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 334:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 335:/usr/lib/avr/include/avr/power.h ****   </tr>
 336:/usr/lib/avr/include/avr/power.h **** 
 337:/usr/lib/avr/include/avr/power.h ****   <tr>
 338:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 339:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 340:/usr/lib/avr/include/avr/power.h ****   </tr>
 341:/usr/lib/avr/include/avr/power.h **** 
 342:/usr/lib/avr/include/avr/power.h ****   <tr>
 343:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 344:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 345:/usr/lib/avr/include/avr/power.h ****   </tr>
 346:/usr/lib/avr/include/avr/power.h **** 
 347:/usr/lib/avr/include/avr/power.h ****   <tr>
 348:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 349:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 350:/usr/lib/avr/include/avr/power.h ****   </tr>
 351:/usr/lib/avr/include/avr/power.h **** 
 352:/usr/lib/avr/include/avr/power.h ****   <tr>
 353:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 354:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 355:/usr/lib/avr/include/avr/power.h ****   </tr>
 356:/usr/lib/avr/include/avr/power.h **** 
 357:/usr/lib/avr/include/avr/power.h ****   <tr>
 358:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 359:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 360:/usr/lib/avr/include/avr/power.h ****   </tr>
 361:/usr/lib/avr/include/avr/power.h **** 
 362:/usr/lib/avr/include/avr/power.h ****   <tr>
 363:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 364:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 365:/usr/lib/avr/include/avr/power.h ****   </tr>
 366:/usr/lib/avr/include/avr/power.h **** 
 367:/usr/lib/avr/include/avr/power.h ****   <tr>
 368:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 369:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 370:/usr/lib/avr/include/avr/power.h ****   </tr>
 371:/usr/lib/avr/include/avr/power.h **** 
 372:/usr/lib/avr/include/avr/power.h ****   <tr>
 373:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 374:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 375:/usr/lib/avr/include/avr/power.h ****   </tr>
 376:/usr/lib/avr/include/avr/power.h **** 
 377:/usr/lib/avr/include/avr/power.h ****   <tr>
 378:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 379:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 380:/usr/lib/avr/include/avr/power.h ****   </tr>
 381:/usr/lib/avr/include/avr/power.h **** 
 382:/usr/lib/avr/include/avr/power.h ****   <tr>
 383:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 384:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 385:/usr/lib/avr/include/avr/power.h ****   </tr>
 386:/usr/lib/avr/include/avr/power.h **** 
 387:/usr/lib/avr/include/avr/power.h ****   <tr>
 388:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 389:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 390:/usr/lib/avr/include/avr/power.h ****   </tr>
 391:/usr/lib/avr/include/avr/power.h **** 
 392:/usr/lib/avr/include/avr/power.h ****   <tr>
 393:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 394:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 395:/usr/lib/avr/include/avr/power.h ****   </tr>
 396:/usr/lib/avr/include/avr/power.h **** 
 397:/usr/lib/avr/include/avr/power.h ****   <tr>
 398:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 399:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 400:/usr/lib/avr/include/avr/power.h ****   </tr>
 401:/usr/lib/avr/include/avr/power.h **** 
 402:/usr/lib/avr/include/avr/power.h ****   <tr>
 403:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 404:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 405:/usr/lib/avr/include/avr/power.h ****   </tr>
 406:/usr/lib/avr/include/avr/power.h **** 
 407:/usr/lib/avr/include/avr/power.h ****   <tr>
 408:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 409:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 410:/usr/lib/avr/include/avr/power.h ****   </tr>
 411:/usr/lib/avr/include/avr/power.h **** 
 412:/usr/lib/avr/include/avr/power.h ****   <tr>
 413:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 414:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 415:/usr/lib/avr/include/avr/power.h ****   </tr>
 416:/usr/lib/avr/include/avr/power.h **** 
 417:/usr/lib/avr/include/avr/power.h ****   <tr>
 418:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 419:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 420:/usr/lib/avr/include/avr/power.h ****   </tr>
 421:/usr/lib/avr/include/avr/power.h **** 
 422:/usr/lib/avr/include/avr/power.h ****   <tr>
 423:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 424:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 425:/usr/lib/avr/include/avr/power.h ****   </tr>
 426:/usr/lib/avr/include/avr/power.h **** 
 427:/usr/lib/avr/include/avr/power.h ****   <tr>
 428:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 429:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 430:/usr/lib/avr/include/avr/power.h ****   </tr>
 431:/usr/lib/avr/include/avr/power.h **** 
 432:/usr/lib/avr/include/avr/power.h ****   <tr>
 433:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 434:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 435:/usr/lib/avr/include/avr/power.h ****   </tr>
 436:/usr/lib/avr/include/avr/power.h **** 
 437:/usr/lib/avr/include/avr/power.h ****   <tr>
 438:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 439:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 440:/usr/lib/avr/include/avr/power.h ****   </tr>
 441:/usr/lib/avr/include/avr/power.h **** 
 442:/usr/lib/avr/include/avr/power.h ****   <tr>
 443:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 444:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 445:/usr/lib/avr/include/avr/power.h ****   </tr>
 446:/usr/lib/avr/include/avr/power.h **** 
 447:/usr/lib/avr/include/avr/power.h ****   <tr>
 448:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 449:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 450:/usr/lib/avr/include/avr/power.h ****   </tr>
 451:/usr/lib/avr/include/avr/power.h **** 
 452:/usr/lib/avr/include/avr/power.h ****   <tr>
 453:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 454:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 455:/usr/lib/avr/include/avr/power.h ****   </tr>
 456:/usr/lib/avr/include/avr/power.h **** 
 457:/usr/lib/avr/include/avr/power.h ****   <tr>
 458:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 459:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 460:/usr/lib/avr/include/avr/power.h ****   </tr>
 461:/usr/lib/avr/include/avr/power.h **** 
 462:/usr/lib/avr/include/avr/power.h ****   <tr>
 463:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 464:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 465:/usr/lib/avr/include/avr/power.h ****   </tr>
 466:/usr/lib/avr/include/avr/power.h **** 
 467:/usr/lib/avr/include/avr/power.h ****   <tr>
 468:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 469:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 470:/usr/lib/avr/include/avr/power.h ****   </tr>
 471:/usr/lib/avr/include/avr/power.h **** 
 472:/usr/lib/avr/include/avr/power.h ****   <tr>
 473:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 474:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 475:/usr/lib/avr/include/avr/power.h ****   </tr>
 476:/usr/lib/avr/include/avr/power.h **** 
 477:/usr/lib/avr/include/avr/power.h ****   <tr>
 478:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 479:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 480:/usr/lib/avr/include/avr/power.h ****   </tr>
 481:/usr/lib/avr/include/avr/power.h **** 
 482:/usr/lib/avr/include/avr/power.h ****   <tr>
 483:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 484:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 485:/usr/lib/avr/include/avr/power.h ****   </tr>
 486:/usr/lib/avr/include/avr/power.h **** 
 487:/usr/lib/avr/include/avr/power.h ****   <tr>
 488:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 489:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 490:/usr/lib/avr/include/avr/power.h ****   </tr>
 491:/usr/lib/avr/include/avr/power.h **** 
 492:/usr/lib/avr/include/avr/power.h ****   <tr>
 493:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 494:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 495:/usr/lib/avr/include/avr/power.h ****   </tr>
 496:/usr/lib/avr/include/avr/power.h **** 
 497:/usr/lib/avr/include/avr/power.h ****   <tr>
 498:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 499:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 500:/usr/lib/avr/include/avr/power.h ****   </tr>
 501:/usr/lib/avr/include/avr/power.h **** 
 502:/usr/lib/avr/include/avr/power.h ****   <tr>
 503:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 504:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 505:/usr/lib/avr/include/avr/power.h ****   </tr>
 506:/usr/lib/avr/include/avr/power.h **** 
 507:/usr/lib/avr/include/avr/power.h ****   <tr>
 508:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 509:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 510:/usr/lib/avr/include/avr/power.h ****   </tr>
 511:/usr/lib/avr/include/avr/power.h **** 
 512:/usr/lib/avr/include/avr/power.h ****   <tr>
 513:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 514:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 515:/usr/lib/avr/include/avr/power.h ****   </tr>
 516:/usr/lib/avr/include/avr/power.h **** 
 517:/usr/lib/avr/include/avr/power.h ****   <tr>
 518:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 519:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 520:/usr/lib/avr/include/avr/power.h ****   </tr>
 521:/usr/lib/avr/include/avr/power.h **** 
 522:/usr/lib/avr/include/avr/power.h ****   <tr>
 523:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 524:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 525:/usr/lib/avr/include/avr/power.h ****   </tr>
 526:/usr/lib/avr/include/avr/power.h **** 
 527:/usr/lib/avr/include/avr/power.h ****   <tr>
 528:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 529:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 530:/usr/lib/avr/include/avr/power.h ****   </tr>
 531:/usr/lib/avr/include/avr/power.h **** 
 532:/usr/lib/avr/include/avr/power.h ****   <tr>
 533:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 534:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 535:/usr/lib/avr/include/avr/power.h ****   </tr>
 536:/usr/lib/avr/include/avr/power.h **** 
 537:/usr/lib/avr/include/avr/power.h ****   <tr>
 538:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 539:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 540:/usr/lib/avr/include/avr/power.h ****   </tr>
 541:/usr/lib/avr/include/avr/power.h **** </table>
 542:/usr/lib/avr/include/avr/power.h **** </center>
 543:/usr/lib/avr/include/avr/power.h **** </small>
 544:/usr/lib/avr/include/avr/power.h **** 
 545:/usr/lib/avr/include/avr/power.h **** @} */
 546:/usr/lib/avr/include/avr/power.h **** 
 547:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 548:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 549:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 550:/usr/lib/avr/include/avr/power.h **** #endif
 551:/usr/lib/avr/include/avr/power.h **** 
 552:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 553:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 554:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 555:/usr/lib/avr/include/avr/power.h **** #endif
 556:/usr/lib/avr/include/avr/power.h **** 
 557:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 558:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 559:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 560:/usr/lib/avr/include/avr/power.h **** #endif
 561:/usr/lib/avr/include/avr/power.h **** 
 562:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 563:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 564:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 565:/usr/lib/avr/include/avr/power.h **** #endif
 566:/usr/lib/avr/include/avr/power.h **** 
 567:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 568:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 569:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 570:/usr/lib/avr/include/avr/power.h **** #endif
 571:/usr/lib/avr/include/avr/power.h **** 
 572:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 573:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 574:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 575:/usr/lib/avr/include/avr/power.h **** #endif
 576:/usr/lib/avr/include/avr/power.h **** 
 577:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 578:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 579:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 580:/usr/lib/avr/include/avr/power.h **** #endif
 581:/usr/lib/avr/include/avr/power.h **** 
 582:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 583:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 584:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 585:/usr/lib/avr/include/avr/power.h **** #endif
 586:/usr/lib/avr/include/avr/power.h **** 
 587:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSCR)
 588:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 589:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 590:/usr/lib/avr/include/avr/power.h **** #endif
 591:/usr/lib/avr/include/avr/power.h **** 
 592:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 593:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 594:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 595:/usr/lib/avr/include/avr/power.h **** #endif
 596:/usr/lib/avr/include/avr/power.h **** 
 597:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 598:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 599:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 600:/usr/lib/avr/include/avr/power.h **** #endif
 601:/usr/lib/avr/include/avr/power.h **** 
 602:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 603:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 604:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 605:/usr/lib/avr/include/avr/power.h **** #endif
 606:/usr/lib/avr/include/avr/power.h **** 
 607:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 609:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 610:/usr/lib/avr/include/avr/power.h **** #endif
 611:/usr/lib/avr/include/avr/power.h **** 
 612:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 613:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 614:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 615:/usr/lib/avr/include/avr/power.h **** #endif
 616:/usr/lib/avr/include/avr/power.h **** 
 617:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 618:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 619:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 620:/usr/lib/avr/include/avr/power.h **** #endif
 621:/usr/lib/avr/include/avr/power.h **** 
 622:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 625:/usr/lib/avr/include/avr/power.h **** #endif
 626:/usr/lib/avr/include/avr/power.h **** 
 627:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 628:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 629:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 630:/usr/lib/avr/include/avr/power.h **** #endif
 631:/usr/lib/avr/include/avr/power.h **** 
 632:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 633:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 634:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 635:/usr/lib/avr/include/avr/power.h **** #endif
 636:/usr/lib/avr/include/avr/power.h **** 
 637:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 638:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 639:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 640:/usr/lib/avr/include/avr/power.h **** #endif
 641:/usr/lib/avr/include/avr/power.h **** 
 642:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCO)
 643:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 644:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 645:/usr/lib/avr/include/avr/power.h **** #endif
 646:/usr/lib/avr/include/avr/power.h **** 
 647:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 648:/usr/lib/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 649:/usr/lib/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 650:/usr/lib/avr/include/avr/power.h **** #endif
 651:/usr/lib/avr/include/avr/power.h **** 
 652:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 653:/usr/lib/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 654:/usr/lib/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 655:/usr/lib/avr/include/avr/power.h **** #endif
 656:/usr/lib/avr/include/avr/power.h **** 
 657:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 658:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 659:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 660:/usr/lib/avr/include/avr/power.h **** #endif
 661:/usr/lib/avr/include/avr/power.h **** 
 662:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 663:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))
 664:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))
 665:/usr/lib/avr/include/avr/power.h **** #endif
 666:/usr/lib/avr/include/avr/power.h **** 
 667:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFRS)
 668:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_enable()             (PRR0 &= (uint8_t)~(1 << PRLFRS))
 669:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_disable()            (PRR0 |= (uint8_t)(1 << PRLFRS))
 670:/usr/lib/avr/include/avr/power.h **** #endif
 671:/usr/lib/avr/include/avr/power.h **** 
 672:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 673:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 674:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 675:/usr/lib/avr/include/avr/power.h **** #endif
 676:/usr/lib/avr/include/avr/power.h **** 
 677:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 678:/usr/lib/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 679:/usr/lib/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 680:/usr/lib/avr/include/avr/power.h **** #endif
 681:/usr/lib/avr/include/avr/power.h **** 
 682:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 683:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 684:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 685:/usr/lib/avr/include/avr/power.h **** #endif
 686:/usr/lib/avr/include/avr/power.h **** 
 687:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 688:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 689:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 690:/usr/lib/avr/include/avr/power.h **** #endif
 691:/usr/lib/avr/include/avr/power.h **** 
 692:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 693:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 694:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 695:/usr/lib/avr/include/avr/power.h **** #endif
 696:/usr/lib/avr/include/avr/power.h **** 
 697:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 698:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 699:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 700:/usr/lib/avr/include/avr/power.h **** #endif
 701:/usr/lib/avr/include/avr/power.h **** 
 702:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 704:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 705:/usr/lib/avr/include/avr/power.h **** #endif
 706:/usr/lib/avr/include/avr/power.h **** 
 707:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 709:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 710:/usr/lib/avr/include/avr/power.h **** #endif
 711:/usr/lib/avr/include/avr/power.h **** 
 712:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 713:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 714:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 715:/usr/lib/avr/include/avr/power.h **** #endif
 716:/usr/lib/avr/include/avr/power.h **** 
 717:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 718:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 719:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 720:/usr/lib/avr/include/avr/power.h **** #endif
 721:/usr/lib/avr/include/avr/power.h **** 
 722:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 723:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 724:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 725:/usr/lib/avr/include/avr/power.h **** #endif
 726:/usr/lib/avr/include/avr/power.h **** 
 727:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 728:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 729:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 730:/usr/lib/avr/include/avr/power.h **** #endif
 731:/usr/lib/avr/include/avr/power.h **** 
 732:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 733:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 734:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 735:/usr/lib/avr/include/avr/power.h **** #endif
 736:/usr/lib/avr/include/avr/power.h **** 
 737:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI1)
 738:/usr/lib/avr/include/avr/power.h **** #define power_twi1_enable()             (PRR0 &= (uint8_t)~(1 << PRTWI1))
 739:/usr/lib/avr/include/avr/power.h **** #define power_twi1_disable()            (PRR0 |= (uint8_t)(1 << PRTWI1))
 740:/usr/lib/avr/include/avr/power.h **** #endif
 741:/usr/lib/avr/include/avr/power.h **** 
 742:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 743:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 744:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 745:/usr/lib/avr/include/avr/power.h **** #endif
 746:/usr/lib/avr/include/avr/power.h **** 
 747:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 748:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 749:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 750:/usr/lib/avr/include/avr/power.h **** #endif
 751:/usr/lib/avr/include/avr/power.h **** 
 752:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 753:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 754:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 755:/usr/lib/avr/include/avr/power.h **** #endif
 756:/usr/lib/avr/include/avr/power.h **** 
 757:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 758:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 759:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 760:/usr/lib/avr/include/avr/power.h **** #endif
 761:/usr/lib/avr/include/avr/power.h **** 
 762:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 763:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 764:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 765:/usr/lib/avr/include/avr/power.h **** #endif
 766:/usr/lib/avr/include/avr/power.h **** 
 767:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 768:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 769:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 770:/usr/lib/avr/include/avr/power.h **** #endif
 771:/usr/lib/avr/include/avr/power.h **** 
 772:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 773:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 774:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 775:/usr/lib/avr/include/avr/power.h **** #endif
 776:/usr/lib/avr/include/avr/power.h **** 
 777:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 778:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 779:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 780:/usr/lib/avr/include/avr/power.h **** #endif
 781:/usr/lib/avr/include/avr/power.h **** 
 782:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 783:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 784:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 785:/usr/lib/avr/include/avr/power.h **** #endif
 786:/usr/lib/avr/include/avr/power.h **** 
 787:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 788:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 789:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 790:/usr/lib/avr/include/avr/power.h **** #endif
 791:/usr/lib/avr/include/avr/power.h **** 
 792:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFPH)
 793:/usr/lib/avr/include/avr/power.h **** #define power_lfph_enable()             (PRR1 &= (uint8_t)~(1 << PRLFPH))
 794:/usr/lib/avr/include/avr/power.h **** #define power_lfph_disable()            (PRR1 |= (uint8_t)(1 << PRLFPH))
 795:/usr/lib/avr/include/avr/power.h **** #endif
 796:/usr/lib/avr/include/avr/power.h **** 
 797:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 798:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 799:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 800:/usr/lib/avr/include/avr/power.h **** #endif
 801:/usr/lib/avr/include/avr/power.h **** 
 802:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFTP)
 803:/usr/lib/avr/include/avr/power.h **** #define power_lftp_enable()             (PRR1 &= (uint8_t)~(1 << PRLFTP))
 804:/usr/lib/avr/include/avr/power.h **** #define power_lftp_disable()            (PRR1 |= (uint8_t)(1 << PRLFTP))
 805:/usr/lib/avr/include/avr/power.h **** #endif
 806:/usr/lib/avr/include/avr/power.h **** 
 807:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 808:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 809:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 810:/usr/lib/avr/include/avr/power.h **** #endif
 811:/usr/lib/avr/include/avr/power.h **** 
 812:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSPI)
 813:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR1 &= (uint8_t)~(1 << PRSPI))
 814:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR1 |= (uint8_t)(1 << PRSPI))
 815:/usr/lib/avr/include/avr/power.h **** #endif
 816:/usr/lib/avr/include/avr/power.h **** 
 817:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 818:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 819:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 820:/usr/lib/avr/include/avr/power.h **** #endif
 821:/usr/lib/avr/include/avr/power.h **** 
 822:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 824:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 825:/usr/lib/avr/include/avr/power.h **** #endif
 826:/usr/lib/avr/include/avr/power.h **** 
 827:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 828:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 829:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 830:/usr/lib/avr/include/avr/power.h **** #endif
 831:/usr/lib/avr/include/avr/power.h **** 
 832:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 833:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 834:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 835:/usr/lib/avr/include/avr/power.h **** #endif
 836:/usr/lib/avr/include/avr/power.h **** 
 837:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 838:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 839:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 840:/usr/lib/avr/include/avr/power.h **** #endif
 841:/usr/lib/avr/include/avr/power.h **** 
 842:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 843:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 844:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 845:/usr/lib/avr/include/avr/power.h **** #endif
 846:/usr/lib/avr/include/avr/power.h **** 
 847:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 848:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 849:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 850:/usr/lib/avr/include/avr/power.h **** #endif
 851:/usr/lib/avr/include/avr/power.h **** 
 852:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 853:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 854:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 855:/usr/lib/avr/include/avr/power.h **** #endif
 856:/usr/lib/avr/include/avr/power.h **** 
 857:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 858:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 859:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 860:/usr/lib/avr/include/avr/power.h **** #endif
 861:/usr/lib/avr/include/avr/power.h **** 
 862:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 863:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 864:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 865:/usr/lib/avr/include/avr/power.h **** #endif
 866:/usr/lib/avr/include/avr/power.h **** 
 867:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 868:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 869:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 870:/usr/lib/avr/include/avr/power.h **** #endif
 871:/usr/lib/avr/include/avr/power.h **** 
 872:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART3)
 873:/usr/lib/avr/include/avr/power.h **** #define power_usart3_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART3))
 874:/usr/lib/avr/include/avr/power.h **** #define power_usart3_disable()          (PRR1 |= (uint8_t)(1 << PRUSART3))
 875:/usr/lib/avr/include/avr/power.h **** #endif
 876:/usr/lib/avr/include/avr/power.h **** 
 877:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 878:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 879:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 880:/usr/lib/avr/include/avr/power.h **** #endif
 881:/usr/lib/avr/include/avr/power.h **** 
 882:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 883:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 884:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 885:/usr/lib/avr/include/avr/power.h **** #endif
 886:/usr/lib/avr/include/avr/power.h **** 
 887:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 888:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 889:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 890:/usr/lib/avr/include/avr/power.h **** #endif
 891:/usr/lib/avr/include/avr/power.h **** 
 892:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 893:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 894:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 895:/usr/lib/avr/include/avr/power.h **** #endif
 896:/usr/lib/avr/include/avr/power.h **** 
 897:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 898:/usr/lib/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 899:/usr/lib/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 900:/usr/lib/avr/include/avr/power.h **** #endif
 901:/usr/lib/avr/include/avr/power.h **** 
 902:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 903:/usr/lib/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 904:/usr/lib/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 905:/usr/lib/avr/include/avr/power.h **** #endif
 906:/usr/lib/avr/include/avr/power.h **** 
 907:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 908:/usr/lib/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 909:/usr/lib/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 910:/usr/lib/avr/include/avr/power.h **** #endif
 911:/usr/lib/avr/include/avr/power.h **** 
 912:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 913:/usr/lib/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 914:/usr/lib/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 915:/usr/lib/avr/include/avr/power.h **** #endif
 916:/usr/lib/avr/include/avr/power.h **** 
 917:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 918:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 919:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 920:/usr/lib/avr/include/avr/power.h **** #endif
 921:/usr/lib/avr/include/avr/power.h **** 
 922:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 923:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 924:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 925:/usr/lib/avr/include/avr/power.h **** #endif
 926:/usr/lib/avr/include/avr/power.h **** 
 927:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSPI2)
 928:/usr/lib/avr/include/avr/power.h **** #define power_spi2_enable()             (PRR2 &= (uint8_t)~(1 << PRSPI2))
 929:/usr/lib/avr/include/avr/power.h **** #define power_spi2_disable()            (PRR2 |= (uint8_t)(1 << PRSPI2))
 930:/usr/lib/avr/include/avr/power.h **** #endif
 931:/usr/lib/avr/include/avr/power.h **** 
 932:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 933:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 934:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 935:/usr/lib/avr/include/avr/power.h **** #endif
 936:/usr/lib/avr/include/avr/power.h **** 
 937:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 938:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 939:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 940:/usr/lib/avr/include/avr/power.h **** #endif
 941:/usr/lib/avr/include/avr/power.h **** 
 942:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTWI2)
 943:/usr/lib/avr/include/avr/power.h **** #define power_twi2_enable()             (PRR2 &= (uint8_t)~(1 << PRTWI2))
 944:/usr/lib/avr/include/avr/power.h **** #define power_twi2_disable()            (PRR2 |= (uint8_t)(1 << PRTWI2))
 945:/usr/lib/avr/include/avr/power.h **** #endif
 946:/usr/lib/avr/include/avr/power.h **** 
 947:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 948:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 949:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 950:/usr/lib/avr/include/avr/power.h **** #endif
 951:/usr/lib/avr/include/avr/power.h **** 
 952:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 953:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 954:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 955:/usr/lib/avr/include/avr/power.h **** #endif
 956:/usr/lib/avr/include/avr/power.h **** 
 957:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 958:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 959:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 960:/usr/lib/avr/include/avr/power.h **** #endif
 961:/usr/lib/avr/include/avr/power.h **** 
 962:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 963:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 964:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 965:/usr/lib/avr/include/avr/power.h **** #endif
 966:/usr/lib/avr/include/avr/power.h **** 
 967:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 968:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 969:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 970:/usr/lib/avr/include/avr/power.h **** #endif
 971:/usr/lib/avr/include/avr/power.h **** 
 972:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 973:/usr/lib/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 974:/usr/lib/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 975:/usr/lib/avr/include/avr/power.h **** #endif
 976:/usr/lib/avr/include/avr/power.h **** 
 977:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 978:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 979:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 980:/usr/lib/avr/include/avr/power.h **** #endif
 981:/usr/lib/avr/include/avr/power.h **** 
 982:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 983:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 984:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 985:/usr/lib/avr/include/avr/power.h **** #endif
 986:/usr/lib/avr/include/avr/power.h **** 
 987:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 988:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 989:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 990:/usr/lib/avr/include/avr/power.h **** #endif
 991:/usr/lib/avr/include/avr/power.h **** 
 992:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 993:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 994:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 995:/usr/lib/avr/include/avr/power.h **** #endif
 996:/usr/lib/avr/include/avr/power.h **** 
 997:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 998:/usr/lib/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 999:/usr/lib/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
1000:/usr/lib/avr/include/avr/power.h **** #endif
1001:/usr/lib/avr/include/avr/power.h **** 
1002:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
1003:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
1004:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
1005:/usr/lib/avr/include/avr/power.h **** #endif
1006:/usr/lib/avr/include/avr/power.h **** 
1007:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
1008:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
1009:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
1010:/usr/lib/avr/include/avr/power.h **** #endif
1011:/usr/lib/avr/include/avr/power.h **** 
1012:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
1013:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
1014:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
1015:/usr/lib/avr/include/avr/power.h **** #endif
1016:/usr/lib/avr/include/avr/power.h **** 
1017:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
1018:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
1019:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
1020:/usr/lib/avr/include/avr/power.h **** #endif
1021:/usr/lib/avr/include/avr/power.h **** 
1022:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
1023:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
1024:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
1025:/usr/lib/avr/include/avr/power.h **** #endif
1026:/usr/lib/avr/include/avr/power.h **** 
1027:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
1028:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
1029:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
1030:/usr/lib/avr/include/avr/power.h **** #endif
1031:/usr/lib/avr/include/avr/power.h **** 
1032:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
1033:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
1034:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
1035:/usr/lib/avr/include/avr/power.h **** #endif
1036:/usr/lib/avr/include/avr/power.h **** 
1037:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
1038:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
1039:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
1040:/usr/lib/avr/include/avr/power.h **** #endif
1041:/usr/lib/avr/include/avr/power.h **** 
1042:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1043:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1044:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1045:/usr/lib/avr/include/avr/power.h **** #endif
1046:/usr/lib/avr/include/avr/power.h **** 
1047:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1048:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1049:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1050:/usr/lib/avr/include/avr/power.h **** #endif
1051:/usr/lib/avr/include/avr/power.h **** 
1052:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1053:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1054:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1055:/usr/lib/avr/include/avr/power.h **** #endif
1056:/usr/lib/avr/include/avr/power.h **** 
1057:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1058:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1059:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1060:/usr/lib/avr/include/avr/power.h **** #endif
1061:/usr/lib/avr/include/avr/power.h **** 
1062:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1063:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1064:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1065:/usr/lib/avr/include/avr/power.h **** #endif
1066:/usr/lib/avr/include/avr/power.h **** 
1067:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1068:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1069:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1070:/usr/lib/avr/include/avr/power.h **** #endif
1071:/usr/lib/avr/include/avr/power.h **** 
1072:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1073:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1074:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1075:/usr/lib/avr/include/avr/power.h **** #endif
1076:/usr/lib/avr/include/avr/power.h **** 
1077:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1078:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1079:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1080:/usr/lib/avr/include/avr/power.h **** #endif
1081:/usr/lib/avr/include/avr/power.h **** 
1082:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1083:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1084:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1085:/usr/lib/avr/include/avr/power.h **** #endif
1086:/usr/lib/avr/include/avr/power.h **** 
1087:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1088:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1089:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1090:/usr/lib/avr/include/avr/power.h **** #endif
1091:/usr/lib/avr/include/avr/power.h **** 
1092:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1093:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1094:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1095:/usr/lib/avr/include/avr/power.h **** #endif
1096:/usr/lib/avr/include/avr/power.h **** 
1097:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1098:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1099:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1100:/usr/lib/avr/include/avr/power.h **** #endif
1101:/usr/lib/avr/include/avr/power.h **** 
1102:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1103:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1104:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1105:/usr/lib/avr/include/avr/power.h **** #endif
1106:/usr/lib/avr/include/avr/power.h **** 
1107:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1108:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1109:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1110:/usr/lib/avr/include/avr/power.h **** #endif
1111:/usr/lib/avr/include/avr/power.h **** 
1112:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1113:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1114:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1115:/usr/lib/avr/include/avr/power.h **** #endif
1116:/usr/lib/avr/include/avr/power.h **** 
1117:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1118:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1119:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1120:/usr/lib/avr/include/avr/power.h **** #endif
1121:/usr/lib/avr/include/avr/power.h **** 
1122:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1123:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1124:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1125:/usr/lib/avr/include/avr/power.h **** #endif
1126:/usr/lib/avr/include/avr/power.h **** 
1127:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1128:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1129:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1130:/usr/lib/avr/include/avr/power.h **** #endif
1131:/usr/lib/avr/include/avr/power.h **** 
1132:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1133:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1134:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1135:/usr/lib/avr/include/avr/power.h **** #endif
1136:/usr/lib/avr/include/avr/power.h **** 
1137:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1138:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1139:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1140:/usr/lib/avr/include/avr/power.h **** #endif
1141:/usr/lib/avr/include/avr/power.h **** 
1142:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1143:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1144:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1145:/usr/lib/avr/include/avr/power.h **** #endif
1146:/usr/lib/avr/include/avr/power.h **** 
1147:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1148:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1149:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1150:/usr/lib/avr/include/avr/power.h **** #endif
1151:/usr/lib/avr/include/avr/power.h **** 
1152:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1153:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1154:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1155:/usr/lib/avr/include/avr/power.h **** #endif
1156:/usr/lib/avr/include/avr/power.h **** 
1157:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1158:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1159:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1160:/usr/lib/avr/include/avr/power.h **** #endif
1161:/usr/lib/avr/include/avr/power.h **** 
1162:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1163:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1164:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1165:/usr/lib/avr/include/avr/power.h **** #endif
1166:/usr/lib/avr/include/avr/power.h **** 
1167:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1168:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1169:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1170:/usr/lib/avr/include/avr/power.h **** #endif
1171:/usr/lib/avr/include/avr/power.h **** 
1172:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1173:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1174:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1175:/usr/lib/avr/include/avr/power.h **** #endif
1176:/usr/lib/avr/include/avr/power.h **** 
1177:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1178:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1179:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1180:/usr/lib/avr/include/avr/power.h **** #endif
1181:/usr/lib/avr/include/avr/power.h **** 
1182:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1183:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1184:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1185:/usr/lib/avr/include/avr/power.h **** #endif
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** static __inline void
1188:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1189:/usr/lib/avr/include/avr/power.h **** __power_all_enable()
1190:/usr/lib/avr/include/avr/power.h **** {
1191:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1192:/usr/lib/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1193:/usr/lib/avr/include/avr/power.h **** #endif
1194:/usr/lib/avr/include/avr/power.h **** 
1195:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1196:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1197:/usr/lib/avr/include/avr/power.h **** #endif
1198:/usr/lib/avr/include/avr/power.h **** 
1199:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1200:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1201:/usr/lib/avr/include/avr/power.h **** #endif
1202:/usr/lib/avr/include/avr/power.h **** 
1203:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1204:/usr/lib/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1205:/usr/lib/avr/include/avr/power.h **** #endif
1206:/usr/lib/avr/include/avr/power.h **** 
1207:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1208:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1209:/usr/lib/avr/include/avr/power.h **** #endif
1210:/usr/lib/avr/include/avr/power.h **** 
1211:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1212:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1213:/usr/lib/avr/include/avr/power.h **** #endif
1214:/usr/lib/avr/include/avr/power.h **** 
1215:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1216:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1217:/usr/lib/avr/include/avr/power.h **** #endif
1218:/usr/lib/avr/include/avr/power.h **** 
1219:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1220:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1221:/usr/lib/avr/include/avr/power.h **** #endif
1222:/usr/lib/avr/include/avr/power.h **** 
1223:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1224:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1225:/usr/lib/avr/include/avr/power.h **** #endif
1226:/usr/lib/avr/include/avr/power.h **** 
1227:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1228:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1229:/usr/lib/avr/include/avr/power.h **** #endif
1230:/usr/lib/avr/include/avr/power.h **** 
1231:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1232:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1233:/usr/lib/avr/include/avr/power.h **** #endif
1234:/usr/lib/avr/include/avr/power.h **** }
1235:/usr/lib/avr/include/avr/power.h **** 
1236:/usr/lib/avr/include/avr/power.h **** static __inline void
1237:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1238:/usr/lib/avr/include/avr/power.h **** __power_all_disable()
1239:/usr/lib/avr/include/avr/power.h **** {
1240:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1241:/usr/lib/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1242:/usr/lib/avr/include/avr/power.h **** #endif
1243:/usr/lib/avr/include/avr/power.h **** 
1244:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1245:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1246:/usr/lib/avr/include/avr/power.h **** #endif
1247:/usr/lib/avr/include/avr/power.h **** 
1248:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1249:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1250:/usr/lib/avr/include/avr/power.h **** #endif
1251:/usr/lib/avr/include/avr/power.h **** 
1252:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1253:/usr/lib/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1254:/usr/lib/avr/include/avr/power.h **** #endif
1255:/usr/lib/avr/include/avr/power.h **** 
1256:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1257:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1258:/usr/lib/avr/include/avr/power.h **** #endif
1259:/usr/lib/avr/include/avr/power.h **** 
1260:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1261:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1262:/usr/lib/avr/include/avr/power.h **** #endif
1263:/usr/lib/avr/include/avr/power.h **** 
1264:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1265:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1266:/usr/lib/avr/include/avr/power.h **** #endif
1267:/usr/lib/avr/include/avr/power.h **** 
1268:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1269:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1270:/usr/lib/avr/include/avr/power.h **** #endif
1271:/usr/lib/avr/include/avr/power.h **** 
1272:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1273:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1274:/usr/lib/avr/include/avr/power.h **** #endif
1275:/usr/lib/avr/include/avr/power.h **** 
1276:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1277:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1278:/usr/lib/avr/include/avr/power.h **** #endif
1279:/usr/lib/avr/include/avr/power.h **** 
1280:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1281:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1282:/usr/lib/avr/include/avr/power.h **** #endif
1283:/usr/lib/avr/include/avr/power.h **** }
1284:/usr/lib/avr/include/avr/power.h **** 
1285:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1286:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_enable
1287:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1288:/usr/lib/avr/include/avr/power.h **** #endif
1289:/usr/lib/avr/include/avr/power.h **** 
1290:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_disable
1291:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1292:/usr/lib/avr/include/avr/power.h **** #endif
1293:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1294:/usr/lib/avr/include/avr/power.h **** 
1295:/usr/lib/avr/include/avr/power.h **** 
1296:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1297:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1298:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1299:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1300:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1301:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1302:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1303:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1304:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1305:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1310:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1311:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1312:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1313:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1314:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1315:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1316:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1317:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA6617C__) \
1318:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA664251__) \
1319:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1320:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1321:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1323:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1324:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1325:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1326:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1327:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1328:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1329:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1330:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1331:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1332:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1333:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1334:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1335:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1336:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1337:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1338:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PB__) \
1339:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1340:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1341:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1342:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1343:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16M1__) \
1344:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1345:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325P__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250P__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1372:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1373:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1374:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1375:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1376:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1377:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1378:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1379:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PB__) \
1380:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1381:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1382:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1383:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1384:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1385:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1386:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1387:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1388:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1389:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1390:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1391:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1392:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1393:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1394:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1395:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__) \
1396:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1397:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1398:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1399:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PB__) \
1400:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1401:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1402:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1403:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1404:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1405:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1406:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1407:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1408:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1409:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1410:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1411:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__) \
1412:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__) \
1413:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1414:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1415:/usr/lib/avr/include/avr/power.h **** 
1416:/usr/lib/avr/include/avr/power.h **** 
1417:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1418:/usr/lib/avr/include/avr/power.h **** 
1419:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1420:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1421:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low.
1422:/usr/lib/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1423:/usr/lib/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1424:/usr/lib/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1425:/usr/lib/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1426:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1427:/usr/lib/avr/include/avr/power.h **** 
1428:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1429:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1430:/usr/lib/avr/include/avr/power.h **** macros are not available.
1431:/usr/lib/avr/include/avr/power.h **** */
1432:/usr/lib/avr/include/avr/power.h **** 
1433:/usr/lib/avr/include/avr/power.h **** 
1434:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1435:/usr/lib/avr/include/avr/power.h **** \code 
1436:/usr/lib/avr/include/avr/power.h **** typedef enum
1437:/usr/lib/avr/include/avr/power.h **** {
1438:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1439:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1440:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1441:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1442:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1443:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1444:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1445:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1446:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1447:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1448:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1449:/usr/lib/avr/include/avr/power.h **** \endcode
1450:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1451:/usr/lib/avr/include/avr/power.h **** System Clock Prescale Register.
1452:/usr/lib/avr/include/avr/power.h **** 
1453:/usr/lib/avr/include/avr/power.h **** \code
1454:/usr/lib/avr/include/avr/power.h **** typedef enum
1455:/usr/lib/avr/include/avr/power.h **** {
1456:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 1,
1457:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 2,
1458:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 4,
1459:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 8,
1460:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 16,
1461:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 32,
1462:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 64,
1463:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 128
1464:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1465:/usr/lib/avr/include/avr/power.h **** \endcode
1466:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1467:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1468:/usr/lib/avr/include/avr/power.h **** 
1469:/usr/lib/avr/include/avr/power.h **** */
1470:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1471:/usr/lib/avr/include/avr/power.h **** typedef enum
1472:/usr/lib/avr/include/avr/power.h **** {
1473:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1474:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1475:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1476:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1477:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1478:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1479:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1480:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1481:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1482:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1483:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1484:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1485:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1486:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1487:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1488:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__)
1489:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1490:/usr/lib/avr/include/avr/power.h **** #endif
1491:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1492:/usr/lib/avr/include/avr/power.h **** 
1493:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1494:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1495:/usr/lib/avr/include/avr/power.h **** 
1496:/usr/lib/avr/include/avr/power.h **** /**
1497:/usr/lib/avr/include/avr/power.h ****    \ingroup avr_power
1498:/usr/lib/avr/include/avr/power.h ****    \fn clock_prescale_set(clock_div_t x)
1499:/usr/lib/avr/include/avr/power.h **** 
1500:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1501:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1502:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1503:/usr/lib/avr/include/avr/power.h **** 
1504:/usr/lib/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1505:/usr/lib/avr/include/avr/power.h **** 
1506:/usr/lib/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1507:/usr/lib/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1508:/usr/lib/avr/include/avr/power.h **** */
1509:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1510:/usr/lib/avr/include/avr/power.h **** {
1511:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1512:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 1706               		.loc 5 1512 0
 1707 07c8 90E0      		ldi r25,0
 1708 07ca 80E8      		ldi r24,lo8(-128)
 1709               	/* #APP */
 1710               	 ;  1512 "/usr/lib/avr/include/avr/power.h" 1
 1711 07cc 0FB6      		in __tmp_reg__,__SREG__
 1712 07ce F894      		cli
 1713 07d0 8093 6100 		sts 97, r24
 1714 07d4 9093 6100 		sts 97, r25
 1715 07d8 0FBE      		out __SREG__, __tmp_reg__
 1716               	 ;  0 "" 2
 1717               	.LVL79:
 1718               	/* #NOAPP */
 1719               	.LBE85:
 1720               	.LBE84:
 513:main.c        ****    clock_prescale_set(clock_div_1);
 514:main.c        ****    I2C_init(I2C_ADDR);
 1721               		.loc 4 514 0
 1722 07da 8AE2      		ldi r24,lo8(42)
 1723 07dc 0E94 0000 		call I2C_init
 1724               	.LVL80:
 515:main.c        ****    PCICR |= _BV(PCIE0);              // enable pin change interrupt for PB0 (rpm)
 1725               		.loc 4 515 0
 1726 07e0 E8E6      		ldi r30,lo8(104)
 1727 07e2 F0E0      		ldi r31,0
 1728 07e4 8081      		ld r24,Z
 1729 07e6 8160      		ori r24,lo8(1)
 1730 07e8 8083      		st Z,r24
 516:main.c        ****    PCMSK0 |= (1 << PCINT4);
 1731               		.loc 4 516 0
 1732 07ea EBE6      		ldi r30,lo8(107)
 1733 07ec F0E0      		ldi r31,0
 1734 07ee 8081      		ld r24,Z
 1735 07f0 8061      		ori r24,lo8(16)
 1736 07f2 8083      		st Z,r24
 517:main.c        ****    sei();
 1737               		.loc 4 517 0
 1738               	/* #APP */
 1739               	 ;  517 "main.c" 1
 1740 07f4 7894      		sei
 1741               	 ;  0 "" 2
 518:main.c        ****    led[0].r = 255;
 1742               		.loc 4 518 0
 1743               	/* #NOAPP */
 1744 07f6 C0E0      		ldi r28,lo8(led)
 1745 07f8 D0E0      		ldi r29,hi8(led)
 1746 07fa 8FEF      		ldi r24,lo8(-1)
 1747 07fc 8983      		std Y+1,r24
 519:main.c        ****    led[0].g = 255;
 1748               		.loc 4 519 0
 1749 07fe 8883      		st Y,r24
 520:main.c        ****    led[0].b = 255;
 1750               		.loc 4 520 0
 1751 0800 8A83      		std Y+2,r24
 521:main.c        ****    ws2812_setleds(led,1);
 1752               		.loc 4 521 0
 1753 0802 61E0      		ldi r22,lo8(1)
 1754 0804 70E0      		ldi r23,0
 1755 0806 CE01      		movw r24,r28
 1756 0808 0E94 0000 		call ws2812_setleds
 1757               	.LVL81:
 522:main.c        ****    setup_lcd();
 1758               		.loc 4 522 0
 1759 080c 0E94 0000 		call setup_lcd
 1760               	.LVL82:
 523:main.c        ****    initbl();
 1761               		.loc 4 523 0
 1762 0810 0E94 0000 		call initbl
 1763               	.LVL83:
 524:main.c        ****    led[0].r = 0;
 1764               		.loc 4 524 0
 1765 0814 1982      		std Y+1,__zero_reg__
 525:main.c        ****    led[0].g = 0;
 1766               		.loc 4 525 0
 1767 0816 1882      		st Y,__zero_reg__
 526:main.c        ****    led[0].b = 0;
 1768               		.loc 4 526 0
 1769 0818 1A82      		std Y+2,__zero_reg__
 527:main.c        ****    ws2812_setleds(led,1);
 1770               		.loc 4 527 0
 1771 081a 61E0      		ldi r22,lo8(1)
 1772 081c 70E0      		ldi r23,0
 1773 081e CE01      		movw r24,r28
 1774 0820 0E94 0000 		call ws2812_setleds
 1775               	.LVL84:
 528:main.c        ****    OCR0A = 210;
 1776               		.loc 4 528 0
 1777 0824 82ED      		ldi r24,lo8(-46)
 1778 0826 87BD      		out 0x27,r24
 1779               	.LVL85:
 1780               	.LBB86:
 1781               	.LBB87:
 1782               		.file 6 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 1783               		.loc 6 473 0
 1784 0828 99E2      		ldi r25,lo8(41)
 1785 082a 88E1      		ldi r24,lo8(24)
 1786               	/* #APP */
 1787               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 1788 082c 0FB6      		in __tmp_reg__,__SREG__
 1789 082e F894      		cli
 1790 0830 A895      		wdr
 1791 0832 8093 6000 		sts 96, r24
 1792 0836 0FBE      		out __SREG__,__tmp_reg__
 1793 0838 9093 6000 		sts 96, r25
 1794               	 	
 1795               	 ;  0 "" 2
 1796               	.LVL86:
 1797               	/* #NOAPP */
 1798               	.LBE87:
 1799               	.LBE86:
 529:main.c        ****    wdt_enable(WDTO_8S);
 530:main.c        ****    bllevel = 0;
 1800               		.loc 4 530 0
 1801 083c 1092 0000 		sts bllevel,__zero_reg__
 531:main.c        ****    newbllevel = 31;
 1802               		.loc 4 531 0
 1803 0840 8FE1      		ldi r24,lo8(31)
 1804 0842 8093 0000 		sts newbllevel,r24
 1805               	/* epilogue start */
 532:main.c        **** }
 1806               		.loc 4 532 0
 1807 0846 DF91      		pop r29
 1808 0848 CF91      		pop r28
 1809 084a 0895      		ret
 1810               		.cfi_endproc
 1811               	.LFE36:
 1813               	.global	__floatunsisf
 1814               	.global	__mulsf3
 1815               	.global	__fixunssfsi
 1816               		.section	.text.startup,"ax",@progbits
 1817               	.global	main
 1819               	main:
 1820               	.LFB37:
 533:main.c        **** 
 534:main.c        **** 
 535:main.c        **** int main(void)
 536:main.c        **** {
 1821               		.loc 4 536 0
 1822               		.cfi_startproc
 1823               	/* prologue: function */
 1824               	/* frame size = 0 */
 1825               	/* stack size = 0 */
 1826               	.L__stack_usage = 0
 1827               	.LVL87:
 537:main.c        ****   uint8_t adcselect = 0;
 538:main.c        ****   setup();
 1828               		.loc 4 538 0
 1829 0000 0E94 0000 		call setup
 1830               	.LVL88:
 537:main.c        ****   uint8_t adcselect = 0;
 1831               		.loc 4 537 0
 1832 0004 10E0      		ldi r17,0
 539:main.c        **** 
 540:main.c        ****   while(1) {  
 541:main.c        **** 
 542:main.c        ****   if (!SDA_LINE) {i2cerror++;}
 543:main.c        ****   
 544:main.c        ****   if (i2cerror > 50) {
 545:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 1833               		.loc 4 545 0
 1834 0006 01ED      		ldi r16,lo8(-47)
 546:main.c        ****   I2C_init(I2C_ADDR); 
 547:main.c        ****   i2cerror = 0;
 548:main.c        ****   sei();
 549:main.c        ****   }                    
 550:main.c        **** 
 551:main.c        ****   wdt_reset();	
 552:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 64khz
 553:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 1835               		.loc 4 553 0
 1836 0008 3EE1      		ldi r19,lo8(30)
 1837 000a F32E      		mov r15,r19
 554:main.c        ****   fanspin = 0;
 555:main.c        ****   isrtimer = 0;
 556:main.c        ****   if (fanlevel == 254) { //fan minimal auto
 557:main.c        ****   if (rpm > 1950) {OCR0A++;}
 558:main.c        ****   if (rpm < 1800) {OCR0A--;}
 559:main.c        ****   }
 560:main.c        ****   }
 561:main.c        **** 
 562:main.c        ****   if (changeled)  {
 563:main.c        ****       ws2812_setleds(led,1);
 564:main.c        ****       changeled = 0;
 565:main.c        ****                      }
 566:main.c        **** 
 567:main.c        ****   if (0 <= newbllevel && newbllevel < 32) {
 568:main.c        ****   if (newbllevel < bllevel) {                // smooth backlight level change in steps
 569:main.c        **** 
 570:main.c        ****       bllevel--;
 571:main.c        ****       writebl(0b01011000);   writebl(0b00011111 & bllevel);
 572:main.c        **** 	  }
 573:main.c        **** 
 574:main.c        ****      if (newbllevel > bllevel) {
 575:main.c        **** 
 576:main.c        **** 	  bllevel++;
 577:main.c        **** 	   writebl(0b01011000);   writebl(0b00011111 & bllevel);
 578:main.c        **** 
 579:main.c        **** 	  }}
 580:main.c        **** 
 581:main.c        ****   if (adcselect < 10) {adcselect++;} else {adcselect = 0;}
 582:main.c        ****   
 583:main.c        ****   switch(adcselect)
 584:main.c        ****   {
 585:main.c        ****    case 0: a0 = readAna(7);  break;
 586:main.c        ****    case 1: a1 = readAna(6);  break;
 587:main.c        ****    case 2: a2 = readAna(5);  break;
 588:main.c        ****    case 4: a3 = readAna(4);  break; 
 589:main.c        ****    case 5: a4 = readAna(1);  break; 
 590:main.c        ****    case 7: a5 = readAna(0);  break;
 591:main.c        ****    case 8: vcc = readVcc();  break;
 592:main.c        ****    case 10: temp = GetTemp();   break;
 593:main.c        **** 
 594:main.c        ****  
 595:main.c        ****    default: {a7 = readAna(9);  //read A7 more frequently 
 596:main.c        ****            if (a7 > a7max) a7max = a7;
 597:main.c        ****            if (a7 < a7min) a7min = a7;
 598:main.c        ****            a7count++;
 599:main.c        ****            if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max
 1838               		.loc 4 599 0
 1839 000c C0E0      		ldi r28,0
 1840 000e D4E0      		ldi r29,lo8(4)
 1841               	.LVL89:
 1842               	.L196:
 542:main.c        ****   
 1843               		.loc 4 542 0
 1844 0010 4999      		sbic 0x9,1
 1845 0012 00C0      		rjmp .L197
 542:main.c        ****   
 1846               		.loc 4 542 0 is_stmt 0 discriminator 1
 1847 0014 8091 0000 		lds r24,i2cerror
 1848 0018 8F5F      		subi r24,lo8(-(1))
 1849 001a 8093 0000 		sts i2cerror,r24
 1850               	.L197:
 544:main.c        ****   TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN); 
 1851               		.loc 4 544 0 is_stmt 1
 1852 001e 8091 0000 		lds r24,i2cerror
 1853 0022 8333      		cpi r24,lo8(51)
 1854 0024 00F0      		brlo .L198
 545:main.c        ****   I2C_init(I2C_ADDR); 
 1855               		.loc 4 545 0
 1856 0026 0093 BC00 		sts 188,r16
 546:main.c        ****   i2cerror = 0;
 1857               		.loc 4 546 0
 1858 002a 8AE2      		ldi r24,lo8(42)
 1859 002c 0E94 0000 		call I2C_init
 1860               	.LVL90:
 547:main.c        ****   sei();
 1861               		.loc 4 547 0
 1862 0030 1092 0000 		sts i2cerror,__zero_reg__
 548:main.c        ****   }                    
 1863               		.loc 4 548 0
 1864               	/* #APP */
 1865               	 ;  548 "main.c" 1
 1866 0034 7894      		sei
 1867               	 ;  0 "" 2
 1868               	/* #NOAPP */
 1869               	.L198:
 551:main.c        ****   if (isrtimer > 31250)   // routine for calculate fan speed - timer is 64khz
 1870               		.loc 4 551 0
 1871               	/* #APP */
 1872               	 ;  551 "main.c" 1
 1873 0036 A895      		wdr
 1874               	 ;  0 "" 2
 552:main.c        ****   {rpm = fanspin * 30;    // 2 signals each turn        
 1875               		.loc 4 552 0
 1876               	/* #NOAPP */
 1877 0038 8091 0000 		lds r24,isrtimer
 1878 003c 9091 0000 		lds r25,isrtimer+1
 1879 0040 8331      		cpi r24,19
 1880 0042 9A47      		sbci r25,122
 1881 0044 00F0      		brlo .L200
 553:main.c        ****   fanspin = 0;
 1882               		.loc 4 553 0
 1883 0046 2091 0000 		lds r18,fanspin
 1884 004a 3091 0000 		lds r19,fanspin+1
 1885 004e F29E      		mul r15,r18
 1886 0050 C001      		movw r24,r0
 1887 0052 F39E      		mul r15,r19
 1888 0054 900D      		add r25,r0
 1889 0056 1124      		clr __zero_reg__
 1890 0058 9093 0000 		sts rpm+1,r25
 1891 005c 8093 0000 		sts rpm,r24
 554:main.c        ****   isrtimer = 0;
 1892               		.loc 4 554 0
 1893 0060 1092 0000 		sts fanspin+1,__zero_reg__
 1894 0064 1092 0000 		sts fanspin,__zero_reg__
 555:main.c        ****   if (fanlevel == 254) { //fan minimal auto
 1895               		.loc 4 555 0
 1896 0068 1092 0000 		sts isrtimer+1,__zero_reg__
 1897 006c 1092 0000 		sts isrtimer,__zero_reg__
 556:main.c        ****   if (rpm > 1950) {OCR0A++;}
 1898               		.loc 4 556 0
 1899 0070 2091 0000 		lds r18,fanlevel
 1900 0074 2E3F      		cpi r18,lo8(-2)
 1901 0076 01F4      		brne .L200
 557:main.c        ****   if (rpm < 1800) {OCR0A--;}
 1902               		.loc 4 557 0
 1903 0078 8F39      		cpi r24,-97
 1904 007a 9740      		sbci r25,7
 1905 007c 00F0      		brlo .L202
 557:main.c        ****   if (rpm < 1800) {OCR0A--;}
 1906               		.loc 4 557 0 is_stmt 0 discriminator 1
 1907 007e 87B5      		in r24,0x27
 1908 0080 8F5F      		subi r24,lo8(-(1))
 1909 0082 87BD      		out 0x27,r24
 1910               	.L202:
 558:main.c        ****   }
 1911               		.loc 4 558 0 is_stmt 1
 1912 0084 8091 0000 		lds r24,rpm
 1913 0088 9091 0000 		lds r25,rpm+1
 1914 008c 8830      		cpi r24,8
 1915 008e 9740      		sbci r25,7
 1916 0090 00F4      		brsh .L200
 558:main.c        ****   }
 1917               		.loc 4 558 0 is_stmt 0 discriminator 1
 1918 0092 87B5      		in r24,0x27
 1919 0094 8150      		subi r24,lo8(-(-1))
 1920 0096 87BD      		out 0x27,r24
 1921               	.L200:
 562:main.c        ****       ws2812_setleds(led,1);
 1922               		.loc 4 562 0 is_stmt 1
 1923 0098 8091 0000 		lds r24,changeled
 1924 009c 8823      		tst r24
 1925 009e 01F0      		breq .L203
 563:main.c        ****       changeled = 0;
 1926               		.loc 4 563 0
 1927 00a0 61E0      		ldi r22,lo8(1)
 1928 00a2 70E0      		ldi r23,0
 1929 00a4 80E0      		ldi r24,lo8(led)
 1930 00a6 90E0      		ldi r25,hi8(led)
 1931 00a8 0E94 0000 		call ws2812_setleds
 1932               	.LVL91:
 564:main.c        ****                      }
 1933               		.loc 4 564 0
 1934 00ac 1092 0000 		sts changeled,__zero_reg__
 1935               	.L203:
 567:main.c        ****   if (newbllevel < bllevel) {                // smooth backlight level change in steps
 1936               		.loc 4 567 0
 1937 00b0 9091 0000 		lds r25,newbllevel
 1938 00b4 9032      		cpi r25,lo8(32)
 1939 00b6 00F4      		brsh .L205
 568:main.c        **** 
 1940               		.loc 4 568 0
 1941 00b8 8091 0000 		lds r24,bllevel
 1942 00bc 9817      		cp r25,r24
 1943 00be 00F4      		brsh .L206
 570:main.c        ****       writebl(0b01011000);   writebl(0b00011111 & bllevel);
 1944               		.loc 4 570 0
 1945 00c0 8150      		subi r24,lo8(-(-1))
 1946 00c2 8093 0000 		sts bllevel,r24
 571:main.c        **** 	  }
 1947               		.loc 4 571 0
 1948 00c6 88E5      		ldi r24,lo8(88)
 1949 00c8 0E94 0000 		call writebl
 1950               	.LVL92:
 1951 00cc 8091 0000 		lds r24,bllevel
 1952 00d0 8F71      		andi r24,lo8(31)
 1953 00d2 0E94 0000 		call writebl
 1954               	.LVL93:
 1955               	.L206:
 574:main.c        **** 
 1956               		.loc 4 574 0
 1957 00d6 8091 0000 		lds r24,bllevel
 1958 00da 9091 0000 		lds r25,newbllevel
 1959 00de 8917      		cp r24,r25
 1960 00e0 00F4      		brsh .L205
 576:main.c        **** 	   writebl(0b01011000);   writebl(0b00011111 & bllevel);
 1961               		.loc 4 576 0
 1962 00e2 8F5F      		subi r24,lo8(-(1))
 1963 00e4 8093 0000 		sts bllevel,r24
 577:main.c        **** 
 1964               		.loc 4 577 0
 1965 00e8 88E5      		ldi r24,lo8(88)
 1966 00ea 0E94 0000 		call writebl
 1967               	.LVL94:
 1968 00ee 8091 0000 		lds r24,bllevel
 1969 00f2 8F71      		andi r24,lo8(31)
 1970 00f4 0E94 0000 		call writebl
 1971               	.LVL95:
 1972               	.L205:
 581:main.c        ****   
 1973               		.loc 4 581 0
 1974 00f8 1A30      		cpi r17,lo8(10)
 1975 00fa 00F4      		brsh .L208
 581:main.c        ****   
 1976               		.loc 4 581 0 is_stmt 0 discriminator 1
 1977 00fc 1F5F      		subi r17,lo8(-(1))
 1978               	.LVL96:
 583:main.c        ****   {
 1979               		.loc 4 583 0 is_stmt 1 discriminator 1
 1980 00fe 812F      		mov r24,r17
 1981 0100 90E0      		ldi r25,0
 1982 0102 FC01      		movw r30,r24
 1983 0104 3197      		sbiw r30,1
 1984 0106 EA30      		cpi r30,10
 1985 0108 F105      		cpc r31,__zero_reg__
 1986 010a 00F0      		brlo .+2
 1987 010c 00C0      		rjmp .L209
 1988 010e E050      		subi r30,lo8(-(gs(.L211)))
 1989 0110 F040      		sbci r31,hi8(-(gs(.L211)))
 1990 0112 0C94 0000 		jmp __tablejump2__
 1991               		.section	.progmem.gcc_sw_table,"a",@progbits
 1992               		.p2align	1
 1993               	.L211:
 1994 002a 0000      		.word gs(.L210)
 1995 002c 0000      		.word gs(.L212)
 1996 002e 0000      		.word gs(.L209)
 1997 0030 0000      		.word gs(.L213)
 1998 0032 0000      		.word gs(.L214)
 1999 0034 0000      		.word gs(.L209)
 2000 0036 0000      		.word gs(.L215)
 2001 0038 0000      		.word gs(.L216)
 2002 003a 0000      		.word gs(.L209)
 2003 003c 0000      		.word gs(.L217)
 2004               		.section	.text.startup
 2005               	.L208:
 2006               	.LVL97:
 585:main.c        ****    case 1: a1 = readAna(6);  break;
 2007               		.loc 4 585 0
 2008 0116 87E0      		ldi r24,lo8(7)
 2009 0118 0E94 0000 		call readAna
 2010               	.LVL98:
 2011 011c 9093 0000 		sts a0+1,r25
 2012 0120 8093 0000 		sts a0,r24
 2013 0124 10E0      		ldi r17,0
 2014 0126 00C0      		rjmp .L196
 2015               	.LVL99:
 2016               	.L210:
 586:main.c        ****    case 2: a2 = readAna(5);  break;
 2017               		.loc 4 586 0
 2018 0128 86E0      		ldi r24,lo8(6)
 2019 012a 0E94 0000 		call readAna
 2020               	.LVL100:
 2021 012e 9093 0000 		sts a1+1,r25
 2022 0132 8093 0000 		sts a1,r24
 2023 0136 00C0      		rjmp .L196
 2024               	.L212:
 587:main.c        ****    case 4: a3 = readAna(4);  break; 
 2025               		.loc 4 587 0
 2026 0138 85E0      		ldi r24,lo8(5)
 2027 013a 0E94 0000 		call readAna
 2028               	.LVL101:
 2029 013e 9093 0000 		sts a2+1,r25
 2030 0142 8093 0000 		sts a2,r24
 2031 0146 00C0      		rjmp .L196
 2032               	.L213:
 588:main.c        ****    case 5: a4 = readAna(1);  break; 
 2033               		.loc 4 588 0
 2034 0148 84E0      		ldi r24,lo8(4)
 2035 014a 0E94 0000 		call readAna
 2036               	.LVL102:
 2037 014e 9093 0000 		sts a3+1,r25
 2038 0152 8093 0000 		sts a3,r24
 2039 0156 00C0      		rjmp .L196
 2040               	.L214:
 589:main.c        ****    case 7: a5 = readAna(0);  break;
 2041               		.loc 4 589 0
 2042 0158 81E0      		ldi r24,lo8(1)
 2043 015a 0E94 0000 		call readAna
 2044               	.LVL103:
 2045 015e 9093 0000 		sts a4+1,r25
 2046 0162 8093 0000 		sts a4,r24
 2047 0166 00C0      		rjmp .L196
 2048               	.L215:
 590:main.c        ****    case 8: vcc = readVcc();  break;
 2049               		.loc 4 590 0
 2050 0168 80E0      		ldi r24,0
 2051 016a 0E94 0000 		call readAna
 2052               	.LVL104:
 2053 016e 9093 0000 		sts a5+1,r25
 2054 0172 8093 0000 		sts a5,r24
 2055 0176 00C0      		rjmp .L196
 2056               	.L216:
 591:main.c        ****    case 10: temp = GetTemp();   break;
 2057               		.loc 4 591 0
 2058 0178 0E94 0000 		call readVcc
 2059               	.LVL105:
 2060 017c 9093 0000 		sts vcc+1,r25
 2061 0180 8093 0000 		sts vcc,r24
 2062 0184 00C0      		rjmp .L196
 2063               	.L217:
 592:main.c        **** 
 2064               		.loc 4 592 0
 2065 0186 0E94 0000 		call GetTemp
 2066               	.LVL106:
 2067 018a 9093 0000 		sts temp+1,r25
 2068 018e 8093 0000 		sts temp,r24
 2069 0192 00C0      		rjmp .L196
 2070               	.L209:
 595:main.c        ****            if (a7 > a7max) a7max = a7;
 2071               		.loc 4 595 0
 2072 0194 89E0      		ldi r24,lo8(9)
 2073 0196 0E94 0000 		call readAna
 2074               	.LVL107:
 2075 019a 9093 0000 		sts a7+1,r25
 2076 019e 8093 0000 		sts a7,r24
 596:main.c        ****            if (a7 < a7min) a7min = a7;
 2077               		.loc 4 596 0
 2078 01a2 2091 0000 		lds r18,a7max
 2079 01a6 3091 0000 		lds r19,a7max+1
 2080 01aa 2817      		cp r18,r24
 2081 01ac 3907      		cpc r19,r25
 2082 01ae 00F4      		brsh .L219
 596:main.c        ****            if (a7 < a7min) a7min = a7;
 2083               		.loc 4 596 0 is_stmt 0 discriminator 1
 2084 01b0 9093 0000 		sts a7max+1,r25
 2085 01b4 8093 0000 		sts a7max,r24
 2086               	.L219:
 597:main.c        ****            a7count++;
 2087               		.loc 4 597 0 is_stmt 1
 2088 01b8 2091 0000 		lds r18,a7min
 2089 01bc 3091 0000 		lds r19,a7min+1
 2090 01c0 8217      		cp r24,r18
 2091 01c2 9307      		cpc r25,r19
 2092 01c4 00F4      		brsh .L220
 597:main.c        ****            a7count++;
 2093               		.loc 4 597 0 is_stmt 0 discriminator 1
 2094 01c6 9093 0000 		sts a7min+1,r25
 2095 01ca 8093 0000 		sts a7min,r24
 2096               	.L220:
 598:main.c        ****            if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max
 2097               		.loc 4 598 0 is_stmt 1
 2098 01ce 8091 0000 		lds r24,a7count
 2099 01d2 8F5F      		subi r24,lo8(-(1))
 2100 01d4 8093 0000 		sts a7count,r24
 2101               		.loc 4 599 0
 2102 01d8 8D33      		cpi r24,lo8(61)
 2103 01da 00F4      		brsh .+2
 2104 01dc 00C0      		rjmp .L196
 2105               		.loc 4 599 0 is_stmt 0 discriminator 1
 2106 01de 6091 0000 		lds r22,a7max
 2107 01e2 7091 0000 		lds r23,a7max+1
 2108 01e6 8091 0000 		lds r24,a7min
 2109 01ea 9091 0000 		lds r25,a7min+1
 2110 01ee 860F      		add r24,r22
 2111 01f0 971F      		adc r25,r23
 2112 01f2 9695      		lsr r25
 2113 01f4 8795      		ror r24
 2114 01f6 681B      		sub r22,r24
 2115 01f8 790B      		sbc r23,r25
 2116 01fa 80E0      		ldi r24,0
 2117 01fc 90E0      		ldi r25,0
 2118 01fe 0E94 0000 		call __floatunsisf
 2119               	.LVL108:
 2120 0202 24EF      		ldi r18,lo8(-12)
 2121 0204 3DEF      		ldi r19,lo8(-3)
 2122 0206 44E3      		ldi r20,lo8(52)
 2123 0208 5FE3      		ldi r21,lo8(63)
 2124 020a 0E94 0000 		call __mulsf3
 2125               	.LVL109:
 2126 020e 0E94 0000 		call __fixunssfsi
 2127               	.LVL110:
 2128 0212 7093 0000 		sts a7avg+1,r23
 2129 0216 6093 0000 		sts a7avg,r22
 2130 021a D093 0000 		sts a7min+1,r29
 2131 021e C093 0000 		sts a7min,r28
 2132 0222 1092 0000 		sts a7max+1,__zero_reg__
 2133 0226 1092 0000 		sts a7max,__zero_reg__
 2134 022a 1092 0000 		sts a7count,__zero_reg__
 2135 022e 00C0      		rjmp .L196
 2136               		.cfi_endproc
 2137               	.LFE37:
 2139               	.global	commands
 2140               		.data
 2143               	commands:
 2144 0000 FF00      		.word	255
 2145 0002 FF01      		.word	511
 2146 0004 9801      		.word	408
 2147 0006 0601      		.word	262
 2148 0008 0401      		.word	260
 2149 000a 0101      		.word	257
 2150 000c 0800      		.word	8
 2151 000e 1001      		.word	272
 2152 0010 2100      		.word	33
 2153 0012 0901      		.word	265
 2154 0014 3000      		.word	48
 2155 0016 0201      		.word	258
 2156 0018 3100      		.word	49
 2157 001a 0001      		.word	256
 2158 001c 4000      		.word	64
 2159 001e 1001      		.word	272
 2160 0020 4100      		.word	65
 2161 0022 5501      		.word	341
 2162 0024 4200      		.word	66
 2163 0026 0201      		.word	258
 2164 0028 4300      		.word	67
 2165 002a 0901      		.word	265
 2166 002c 4400      		.word	68
 2167 002e 0701      		.word	263
 2168 0030 5000      		.word	80
 2169 0032 7801      		.word	376
 2170 0034 5100      		.word	81
 2171 0036 7801      		.word	376
 2172 0038 5200      		.word	82
 2173 003a 0001      		.word	256
 2174 003c 5300      		.word	83
 2175 003e 6D01      		.word	365
 2176 0040 6000      		.word	96
 2177 0042 0701      		.word	263
 2178 0044 6100      		.word	97
 2179 0046 0001      		.word	256
 2180 0048 6200      		.word	98
 2181 004a 0801      		.word	264
 2182 004c 6300      		.word	99
 2183 004e 0001      		.word	256
 2184 0050 A000      		.word	160
 2185 0052 0001      		.word	256
 2186 0054 A100      		.word	161
 2187 0056 0701      		.word	263
 2188 0058 A200      		.word	162
 2189 005a 0C01      		.word	268
 2190 005c A300      		.word	163
 2191 005e 0B01      		.word	267
 2192 0060 A400      		.word	164
 2193 0062 0301      		.word	259
 2194 0064 A500      		.word	165
 2195 0066 0701      		.word	263
 2196 0068 A600      		.word	166
 2197 006a 0601      		.word	262
 2198 006c A700      		.word	167
 2199 006e 0401      		.word	260
 2200 0070 A800      		.word	168
 2201 0072 0801      		.word	264
 2202 0074 A900      		.word	169
 2203 0076 0C01      		.word	268
 2204 0078 AA00      		.word	170
 2205 007a 1301      		.word	275
 2206 007c AB00      		.word	171
 2207 007e 0601      		.word	262
 2208 0080 AC00      		.word	172
 2209 0082 0D01      		.word	269
 2210 0084 AD00      		.word	173
 2211 0086 1901      		.word	281
 2212 0088 AE00      		.word	174
 2213 008a 1001      		.word	272
 2214 008c AF00      		.word	175
 2215 008e 0001      		.word	256
 2216 0090 C000      		.word	192
 2217 0092 0001      		.word	256
 2218 0094 C100      		.word	193
 2219 0096 0701      		.word	263
 2220 0098 C200      		.word	194
 2221 009a 0C01      		.word	268
 2222 009c C300      		.word	195
 2223 009e 0B01      		.word	267
 2224 00a0 C400      		.word	196
 2225 00a2 0301      		.word	259
 2226 00a4 C500      		.word	197
 2227 00a6 0701      		.word	263
 2228 00a8 C600      		.word	198
 2229 00aa 0701      		.word	263
 2230 00ac C700      		.word	199
 2231 00ae 0401      		.word	260
 2232 00b0 C800      		.word	200
 2233 00b2 0801      		.word	264
 2234 00b4 C900      		.word	201
 2235 00b6 0C01      		.word	268
 2236 00b8 CA00      		.word	202
 2237 00ba 1301      		.word	275
 2238 00bc CB00      		.word	203
 2239 00be 0601      		.word	262
 2240 00c0 CC00      		.word	204
 2241 00c2 0D01      		.word	269
 2242 00c4 CD00      		.word	205
 2243 00c6 1801      		.word	280
 2244 00c8 CE00      		.word	206
 2245 00ca 1001      		.word	272
 2246 00cc CF00      		.word	207
 2247 00ce 0001      		.word	256
 2248 00d0 FF00      		.word	255
 2249 00d2 FF01      		.word	511
 2250 00d4 9801      		.word	408
 2251 00d6 0601      		.word	262
 2252 00d8 0401      		.word	260
 2253 00da 0601      		.word	262
 2254 00dc 0000      		.word	0
 2255 00de 2001      		.word	288
 2256 00e0 0100      		.word	1
 2257 00e2 0A01      		.word	266
 2258 00e4 0200      		.word	2
 2259 00e6 0001      		.word	256
 2260 00e8 0300      		.word	3
 2261 00ea 0001      		.word	256
 2262 00ec 0400      		.word	4
 2263 00ee 0101      		.word	257
 2264 00f0 0500      		.word	5
 2265 00f2 0101      		.word	257
 2266 00f4 0600      		.word	6
 2267 00f6 9801      		.word	408
 2268 00f8 0700      		.word	7
 2269 00fa 0601      		.word	262
 2270 00fc 0800      		.word	8
 2271 00fe 0101      		.word	257
 2272 0100 0900      		.word	9
 2273 0102 8001      		.word	384
 2274 0104 0A00      		.word	10
 2275 0106 0001      		.word	256
 2276 0108 0B00      		.word	11
 2277 010a 0001      		.word	256
 2278 010c 0C00      		.word	12
 2279 010e 0101      		.word	257
 2280 0110 0D00      		.word	13
 2281 0112 0101      		.word	257
 2282 0114 0E00      		.word	14
 2283 0116 0001      		.word	256
 2284 0118 0F00      		.word	15
 2285 011a 0001      		.word	256
 2286 011c 1000      		.word	16
 2287 011e F001      		.word	496
 2288 0120 1100      		.word	17
 2289 0122 F401      		.word	500
 2290 0124 1200      		.word	18
 2291 0126 0101      		.word	257
 2292 0128 1300      		.word	19
 2293 012a 0001      		.word	256
 2294 012c 1400      		.word	20
 2295 012e 0001      		.word	256
 2296 0130 1500      		.word	21
 2297 0132 C001      		.word	448
 2298 0134 1600      		.word	22
 2299 0136 0801      		.word	264
 2300 0138 1700      		.word	23
 2301 013a 0001      		.word	256
 2302 013c 1800      		.word	24
 2303 013e 0001      		.word	256
 2304 0140 1900      		.word	25
 2305 0142 0001      		.word	256
 2306 0144 1A00      		.word	26
 2307 0146 0001      		.word	256
 2308 0148 1B00      		.word	27
 2309 014a 0001      		.word	256
 2310 014c 1C00      		.word	28
 2311 014e 0001      		.word	256
 2312 0150 1D00      		.word	29
 2313 0152 0001      		.word	256
 2314 0154 2000      		.word	32
 2315 0156 0101      		.word	257
 2316 0158 2100      		.word	33
 2317 015a 2301      		.word	291
 2318 015c 2200      		.word	34
 2319 015e 4501      		.word	325
 2320 0160 2300      		.word	35
 2321 0162 6701      		.word	359
 2322 0164 2400      		.word	36
 2323 0166 0101      		.word	257
 2324 0168 2500      		.word	37
 2325 016a 2301      		.word	291
 2326 016c 2600      		.word	38
 2327 016e 4501      		.word	325
 2328 0170 2700      		.word	39
 2329 0172 6701      		.word	359
 2330 0174 3000      		.word	48
 2331 0176 1101      		.word	273
 2332 0178 3100      		.word	49
 2333 017a 1101      		.word	273
 2334 017c 3200      		.word	50
 2335 017e 0001      		.word	256
 2336 0180 3300      		.word	51
 2337 0182 EE01      		.word	494
 2338 0184 3400      		.word	52
 2339 0186 FF01      		.word	511
 2340 0188 3500      		.word	53
 2341 018a BB01      		.word	443
 2342 018c 3600      		.word	54
 2343 018e AA01      		.word	426
 2344 0190 3700      		.word	55
 2345 0192 DD01      		.word	477
 2346 0194 3800      		.word	56
 2347 0196 CC01      		.word	460
 2348 0198 3900      		.word	57
 2349 019a 6601      		.word	358
 2350 019c 3A00      		.word	58
 2351 019e 7701      		.word	375
 2352 01a0 3B00      		.word	59
 2353 01a2 2201      		.word	290
 2354 01a4 3C00      		.word	60
 2355 01a6 2201      		.word	290
 2356 01a8 3D00      		.word	61
 2357 01aa 2201      		.word	290
 2358 01ac 3E00      		.word	62
 2359 01ae 2201      		.word	290
 2360 01b0 3F00      		.word	63
 2361 01b2 2201      		.word	290
 2362 01b4 4000      		.word	64
 2363 01b6 2201      		.word	290
 2364 01b8 5200      		.word	82
 2365 01ba 1001      		.word	272
 2366 01bc 5300      		.word	83
 2367 01be 1001      		.word	272
 2368 01c0 FF00      		.word	255
 2369 01c2 FF01      		.word	511
 2370 01c4 9801      		.word	408
 2371 01c6 0601      		.word	262
 2372 01c8 0401      		.word	260
 2373 01ca 0701      		.word	263
 2374 01cc 1800      		.word	24
 2375 01ce 1D01      		.word	285
 2376 01d0 1700      		.word	23
 2377 01d2 2201      		.word	290
 2378 01d4 0200      		.word	2
 2379 01d6 7701      		.word	375
 2380 01d8 2600      		.word	38
 2381 01da B201      		.word	434
 2382 01dc E100      		.word	225
 2383 01de 7901      		.word	377
 2384 01e0 FF00      		.word	255
 2385 01e2 FF01      		.word	511
 2386 01e4 9801      		.word	408
 2387 01e6 0601      		.word	262
 2388 01e8 0401      		.word	260
 2389 01ea 0001      		.word	256
 2390 01ec 3A00      		.word	58
 2391 01ee 6001      		.word	352
 2392 01f0 3500      		.word	53
 2393 01f2 0001      		.word	256
 2394 01f4 1100      		.word	17
 2395 01f6 0001      		.word	256
 2396 01f8 FFFF      		.word	-1
 2397 01fa 2900      		.word	41
 2398 01fc 0001      		.word	256
 2399 01fe FFFF      		.word	-1
 2400               	.global	fanlevel
 2403               	fanlevel:
 2404 0200 FE        		.byte	-2
 2405               	.global	i2cbuffer
 2406               		.section .bss
 2409               	i2cbuffer:
 2410 0000 0000      		.zero	2
 2411               		.comm	isrtimer,2,1
 2412               		.comm	fanspin,2,1
 2413               		.comm	rpm,2,1
 2414               		.comm	temp,2,1
 2415               		.comm	vcc,2,1
 2416               		.comm	a7min,2,1
 2417               		.comm	a7max,2,1
 2418               		.comm	a7avg,2,1
 2419               		.comm	a7,2,1
 2420               		.comm	a5,2,1
 2421               		.comm	a4,2,1
 2422               		.comm	a3,2,1
 2423               		.comm	a2,2,1
 2424               		.comm	a1,2,1
 2425               		.comm	a0,2,1
 2426               	.global	i2cerror
 2429               	i2cerror:
 2430 0002 00        		.zero	1
 2431               		.comm	crc,1,1
 2432               		.comm	changeled,1,1
 2433               	.global	newbllevel
 2434               		.data
 2437               	newbllevel:
 2438 0201 1F        		.byte	31
 2439               	.global	bllevel
 2442               	bllevel:
 2443 0202 1F        		.byte	31
 2444               		.comm	count,1,1
 2445               	.global	a7count
 2446               		.section .bss
 2449               	a7count:
 2450 0003 00        		.zero	1
 2451               		.comm	buffer_address,1,1
 2452               		.comm	twdrbuffer,1,1
 2453               	.global	commandbyte
 2454               		.data
 2457               	commandbyte:
 2458 0203 FF        		.byte	-1
 2459               		.comm	led,3,1
 2460               		.text
 2461               	.Letext0:
 2462               		.file 7 "/usr/lib/avr/include/stdint.h"
 2463               		.file 8 "light_ws2812.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccL0F3Xe.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccL0F3Xe.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccL0F3Xe.s:4      *ABS*:0000003f __SREG__
     /tmp/ccL0F3Xe.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccL0F3Xe.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccL0F3Xe.s:11     .text:00000000 _crc8_ccitt_update
     /tmp/ccL0F3Xe.s:43     .text:00000012 ws2812_sendarray_mask
     /tmp/ccL0F3Xe.s:93     .text:00000038 loop59
     /tmp/ccL0F3Xe.s:130    .text:00000068 ws2812_setleds_pin
     /tmp/ccL0F3Xe.s:167    .text:00000084 ws2812_setleds
     /tmp/ccL0F3Xe.s:185    .text:0000008a ws2812_sendarray
     /tmp/ccL0F3Xe.s:203    .text:00000090 writebl
     /tmp/ccL0F3Xe.s:337    .text:0000010a initbl
     /tmp/ccL0F3Xe.s:409    .text:00000140 write
     /tmp/ccL0F3Xe.s:497    .text:00000194 setup_lcd
     /tmp/ccL0F3Xe.s:2143   .data:00000000 commands
     /tmp/ccL0F3Xe.s:566    .text:000001d0 readAna
     /tmp/ccL0F3Xe.s:650    .text:0000023e readVcc
     /tmp/ccL0F3Xe.s:722    .text:000002ac GetTemp
     /tmp/ccL0F3Xe.s:787    .text:0000030a freeRam
     /tmp/ccL0F3Xe.s:835    .text:00000338 I2C_init
                            *COM*:00000001 buffer_address
     /tmp/ccL0F3Xe.s:866    .text:0000034e __vector_9
                            *COM*:00000002 fanspin
     /tmp/ccL0F3Xe.s:923    .text:00000382 __vector_23
                            *COM*:00000002 isrtimer
     /tmp/ccL0F3Xe.s:970    .text:000003b0 __vector_36
     /tmp/ccL0F3Xe.s:2457   .data:00000203 commandbyte
                            *COM*:00000001 crc
     /tmp/ccL0F3Xe.s:2429   .bss:00000002 i2cerror
                            *COM*:00000002 a0
                            *COM*:00000002 a1
                            *COM*:00000002 a2
                            *COM*:00000002 a3
                            *COM*:00000002 a4
                            *COM*:00000002 a5
                            *COM*:00000002 a7
                            *COM*:00000002 rpm
                            *COM*:00000002 vcc
                            *COM*:00000002 temp
                            *COM*:00000002 a7avg
     /tmp/ccL0F3Xe.s:2409   .bss:00000000 i2cbuffer
                            *COM*:00000001 twdrbuffer
     /tmp/ccL0F3Xe.s:2437   .data:00000201 newbllevel
     /tmp/ccL0F3Xe.s:2403   .data:00000200 fanlevel
                            *COM*:00000003 led
                            *COM*:00000001 changeled
     /tmp/ccL0F3Xe.s:2442   .data:00000202 bllevel
     /tmp/ccL0F3Xe.s:1655   .text:0000079c setup
     /tmp/ccL0F3Xe.s:1819   .text.startup:00000000 main
                            *COM*:00000002 a7max
                            *COM*:00000002 a7min
     /tmp/ccL0F3Xe.s:2449   .bss:00000003 a7count
                            *COM*:00000001 count

UNDEFINED SYMBOLS
__divmodsi4
__brkval
__heap_start
__tablejump2__
__floatunsisf
__mulsf3
__fixunssfsi
__do_copy_data
__do_clear_bss
