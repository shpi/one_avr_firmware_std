   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_crc8_ccitt_update:
  12               	.LFB4:
  13               		.file 1 "/usr/lib/avr/include/util/crc16.h"
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/lib/avr/include/util/crc16.h **** 
   7:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/lib/avr/include/util/crc16.h **** 
  10:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/lib/avr/include/util/crc16.h **** 
  13:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/lib/avr/include/util/crc16.h ****      distribution.
  17:/usr/lib/avr/include/util/crc16.h **** 
  18:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/lib/avr/include/util/crc16.h **** 
  22:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** /* $Id$ */
  35:/usr/lib/avr/include/util/crc16.h **** 
  36:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/lib/avr/include/util/crc16.h **** 
  41:/usr/lib/avr/include/util/crc16.h **** /** \file */
  42:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/lib/avr/include/util/crc16.h **** 
  45:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par References:
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     \par
  51:/usr/lib/avr/include/util/crc16.h **** 
  52:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     \par
  57:/usr/lib/avr/include/util/crc16.h **** 
  58:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/lib/avr/include/util/crc16.h **** 
  65:/usr/lib/avr/include/util/crc16.h ****     \code
  66:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/lib/avr/include/util/crc16.h **** 
  69:/usr/lib/avr/include/util/crc16.h ****     int
  70:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/lib/avr/include/util/crc16.h ****     {
  72:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/lib/avr/include/util/crc16.h **** 
  74:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/lib/avr/include/util/crc16.h **** 
  77:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/lib/avr/include/util/crc16.h ****     }
  79:/usr/lib/avr/include/util/crc16.h ****     \endcode
  80:/usr/lib/avr/include/util/crc16.h **** */
  81:/usr/lib/avr/include/util/crc16.h **** 
  82:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/lib/avr/include/util/crc16.h **** 
  85:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/lib/avr/include/util/crc16.h **** 
  92:/usr/lib/avr/include/util/crc16.h ****     \code
  93:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  94:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/lib/avr/include/util/crc16.h ****     {
  96:/usr/lib/avr/include/util/crc16.h **** 	int i;
  97:/usr/lib/avr/include/util/crc16.h **** 
  98:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/lib/avr/include/util/crc16.h **** 	{
 101:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/lib/avr/include/util/crc16.h **** 	    else
 104:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/lib/avr/include/util/crc16.h **** 	}
 106:/usr/lib/avr/include/util/crc16.h **** 
 107:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 108:/usr/lib/avr/include/util/crc16.h ****     }
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 111:/usr/lib/avr/include/util/crc16.h **** 
 112:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/lib/avr/include/util/crc16.h **** {
 115:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/lib/avr/include/util/crc16.h **** 
 118:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/lib/avr/include/util/crc16.h **** 	);
 146:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/lib/avr/include/util/crc16.h **** }
 148:/usr/lib/avr/include/util/crc16.h **** 
 149:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/lib/avr/include/util/crc16.h **** 
 152:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/lib/avr/include/util/crc16.h **** 
 159:/usr/lib/avr/include/util/crc16.h ****     \code
 160:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 161:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/lib/avr/include/util/crc16.h ****     {
 163:/usr/lib/avr/include/util/crc16.h ****         int i;
 164:/usr/lib/avr/include/util/crc16.h **** 
 165:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/lib/avr/include/util/crc16.h ****         {
 168:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/lib/avr/include/util/crc16.h ****             else
 171:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/lib/avr/include/util/crc16.h ****         }
 173:/usr/lib/avr/include/util/crc16.h **** 
 174:/usr/lib/avr/include/util/crc16.h ****         return crc;
 175:/usr/lib/avr/include/util/crc16.h ****     }
 176:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 177:/usr/lib/avr/include/util/crc16.h **** 
 178:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/lib/avr/include/util/crc16.h **** {
 181:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/lib/avr/include/util/crc16.h **** 
 186:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 187:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 188:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 189:/usr/lib/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 190:/usr/lib/avr/include/util/crc16.h **** 
 191:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 192:/usr/lib/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 193:/usr/lib/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 194:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 195:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 196:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 197:/usr/lib/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 198:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 199:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 200:/usr/lib/avr/include/util/crc16.h **** 
 201:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 202:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 203:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 204:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 205:/usr/lib/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 206:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 207:/usr/lib/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 208:/usr/lib/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 209:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 211:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 212:/usr/lib/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 213:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 214:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 215:/usr/lib/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 216:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 217:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 218:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 219:/usr/lib/avr/include/util/crc16.h ****     );
 220:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 221:/usr/lib/avr/include/util/crc16.h **** }
 222:/usr/lib/avr/include/util/crc16.h **** 
 223:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 224:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-CCITT calculation.
 225:/usr/lib/avr/include/util/crc16.h **** 
 226:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x8408)<br>
 227:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
 228:/usr/lib/avr/include/util/crc16.h **** 
 229:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by PPP and IrDA.
 230:/usr/lib/avr/include/util/crc16.h **** 
 231:/usr/lib/avr/include/util/crc16.h ****     See RFC1171 (PPP protocol) and IrDA IrLAP 1.1
 232:/usr/lib/avr/include/util/crc16.h **** 
 233:/usr/lib/avr/include/util/crc16.h ****     \note Although the CCITT polynomial is the same as that used by the Xmodem
 234:/usr/lib/avr/include/util/crc16.h ****     protocol, they are quite different. The difference is in how the bits are
 235:/usr/lib/avr/include/util/crc16.h ****     shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
 236:/usr/lib/avr/include/util/crc16.h ****     input first, while CCITT shifts the LSB of the CRC and the input first.
 237:/usr/lib/avr/include/util/crc16.h **** 
 238:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 239:/usr/lib/avr/include/util/crc16.h **** 
 240:/usr/lib/avr/include/util/crc16.h ****     \code
 241:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 242:/usr/lib/avr/include/util/crc16.h ****     crc_ccitt_update (uint16_t crc, uint8_t data)
 243:/usr/lib/avr/include/util/crc16.h ****     {
 244:/usr/lib/avr/include/util/crc16.h ****         data ^= lo8 (crc);
 245:/usr/lib/avr/include/util/crc16.h ****         data ^= data << 4;
 246:/usr/lib/avr/include/util/crc16.h **** 
 247:/usr/lib/avr/include/util/crc16.h ****         return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
 248:/usr/lib/avr/include/util/crc16.h ****                 ^ ((uint16_t)data << 3));
 249:/usr/lib/avr/include/util/crc16.h ****     }
 250:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 251:/usr/lib/avr/include/util/crc16.h **** 
 252:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 253:/usr/lib/avr/include/util/crc16.h **** _crc_ccitt_update (uint16_t __crc, uint8_t __data)
 254:/usr/lib/avr/include/util/crc16.h **** {
 255:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;
 256:/usr/lib/avr/include/util/crc16.h **** 
 257:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 258:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%1"          "\n\t"
 259:/usr/lib/avr/include/util/crc16.h **** 
 260:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%A0" "\n\t"
 261:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 262:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0xf0"        "\n\t"
 263:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__" "\n\t"
 264:/usr/lib/avr/include/util/crc16.h **** 
 265:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 266:/usr/lib/avr/include/util/crc16.h **** 
 267:/usr/lib/avr/include/util/crc16.h ****         "mov    %B0,%A0"         "\n\t"
 268:/usr/lib/avr/include/util/crc16.h **** 
 269:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 270:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0x0f"        "\n\t"
 271:/usr/lib/avr/include/util/crc16.h ****         "eor    __tmp_reg__,%A0" "\n\t"
 272:/usr/lib/avr/include/util/crc16.h **** 
 273:/usr/lib/avr/include/util/crc16.h ****         "lsr    %A0"             "\n\t"
 274:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t"
 275:/usr/lib/avr/include/util/crc16.h **** 
 276:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%B0"         "\n\t"
 277:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 278:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 279:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 280:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__"
 281:/usr/lib/avr/include/util/crc16.h **** 
 282:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret)
 283:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 284:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 285:/usr/lib/avr/include/util/crc16.h ****     );
 286:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 287:/usr/lib/avr/include/util/crc16.h **** }
 288:/usr/lib/avr/include/util/crc16.h **** 
 289:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 290:/usr/lib/avr/include/util/crc16.h ****     Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
 291:/usr/lib/avr/include/util/crc16.h **** 
 292:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
 293:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 294:/usr/lib/avr/include/util/crc16.h **** 
 295:/usr/lib/avr/include/util/crc16.h ****     See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 296:/usr/lib/avr/include/util/crc16.h **** 
 297:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 298:/usr/lib/avr/include/util/crc16.h **** 
 299:/usr/lib/avr/include/util/crc16.h ****     \code
 300:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 301:/usr/lib/avr/include/util/crc16.h ****     _crc_ibutton_update(uint8_t crc, uint8_t data)
 302:/usr/lib/avr/include/util/crc16.h ****     {
 303:/usr/lib/avr/include/util/crc16.h **** 	uint8_t i;
 304:/usr/lib/avr/include/util/crc16.h **** 
 305:/usr/lib/avr/include/util/crc16.h **** 	crc = crc ^ data;
 306:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; i++)
 307:/usr/lib/avr/include/util/crc16.h **** 	{
 308:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 0x01)
 309:/usr/lib/avr/include/util/crc16.h **** 	        crc = (crc >> 1) ^ 0x8C;
 310:/usr/lib/avr/include/util/crc16.h **** 	    else
 311:/usr/lib/avr/include/util/crc16.h **** 	        crc >>= 1;
 312:/usr/lib/avr/include/util/crc16.h **** 	}
 313:/usr/lib/avr/include/util/crc16.h **** 
 314:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 315:/usr/lib/avr/include/util/crc16.h ****     }
 316:/usr/lib/avr/include/util/crc16.h ****     \endcode
 317:/usr/lib/avr/include/util/crc16.h **** */
 318:/usr/lib/avr/include/util/crc16.h **** 
 319:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 320:/usr/lib/avr/include/util/crc16.h **** _crc_ibutton_update(uint8_t __crc, uint8_t __data)
 321:/usr/lib/avr/include/util/crc16.h **** {
 322:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __i, __pattern;
 323:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 324:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %4" "\n\t"
 325:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%1, 8" "\n\t"
 326:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%2, 0x8C" "\n\t"
 327:/usr/lib/avr/include/util/crc16.h **** 		"1:	lsr	%0" "\n\t"
 328:/usr/lib/avr/include/util/crc16.h **** 		"	brcc	2f" "\n\t"
 329:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %2" "\n\t"
 330:/usr/lib/avr/include/util/crc16.h **** 		"2:	dec	%1" "\n\t"
 331:/usr/lib/avr/include/util/crc16.h **** 		"	brne	1b" "\n\t"
 332:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
 333:/usr/lib/avr/include/util/crc16.h **** 		: "0" (__crc), "r" (__data));
 334:/usr/lib/avr/include/util/crc16.h **** 	return __crc;
 335:/usr/lib/avr/include/util/crc16.h **** }
 336:/usr/lib/avr/include/util/crc16.h **** 
 337:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 338:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-8-CCITT calculation.
 339:/usr/lib/avr/include/util/crc16.h **** 
 340:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
 341:/usr/lib/avr/include/util/crc16.h ****     
 342:/usr/lib/avr/include/util/crc16.h ****     For use with simple CRC-8<br>
 343:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 344:/usr/lib/avr/include/util/crc16.h ****     
 345:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ROHC<br>
 346:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 347:/usr/lib/avr/include/util/crc16.h ****     Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
 348:/usr/lib/avr/include/util/crc16.h ****     
 349:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ATM/ITU<br>
 350:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 351:/usr/lib/avr/include/util/crc16.h ****     Final XOR value: 0x55<br>
 352:/usr/lib/avr/include/util/crc16.h ****     Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
 353:/usr/lib/avr/include/util/crc16.h ****     
 354:/usr/lib/avr/include/util/crc16.h ****     The C equivalent has been originally written by Dave Hylands.
 355:/usr/lib/avr/include/util/crc16.h ****     Assembly code is based on _crc_ibutton_update optimization.
 356:/usr/lib/avr/include/util/crc16.h **** 
 357:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 358:/usr/lib/avr/include/util/crc16.h **** 
 359:/usr/lib/avr/include/util/crc16.h ****     \code
 360:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 361:/usr/lib/avr/include/util/crc16.h ****     _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
 362:/usr/lib/avr/include/util/crc16.h ****     {
 363:/usr/lib/avr/include/util/crc16.h ****         uint8_t   i;
 364:/usr/lib/avr/include/util/crc16.h ****         uint8_t   data;
 365:/usr/lib/avr/include/util/crc16.h **** 
 366:/usr/lib/avr/include/util/crc16.h ****         data = inCrc ^ inData;
 367:/usr/lib/avr/include/util/crc16.h **** 
 368:/usr/lib/avr/include/util/crc16.h ****         for ( i = 0; i < 8; i++ )
 369:/usr/lib/avr/include/util/crc16.h ****         {
 370:/usr/lib/avr/include/util/crc16.h ****             if (( data & 0x80 ) != 0 )
 371:/usr/lib/avr/include/util/crc16.h ****             {
 372:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 373:/usr/lib/avr/include/util/crc16.h ****                 data ^= 0x07;
 374:/usr/lib/avr/include/util/crc16.h ****             }
 375:/usr/lib/avr/include/util/crc16.h ****             else
 376:/usr/lib/avr/include/util/crc16.h ****             {
 377:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 378:/usr/lib/avr/include/util/crc16.h ****             }
 379:/usr/lib/avr/include/util/crc16.h ****         }
 380:/usr/lib/avr/include/util/crc16.h ****         return data;
 381:/usr/lib/avr/include/util/crc16.h ****     }
 382:/usr/lib/avr/include/util/crc16.h ****     \endcode
 383:/usr/lib/avr/include/util/crc16.h **** */
 384:/usr/lib/avr/include/util/crc16.h **** 
 385:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 386:/usr/lib/avr/include/util/crc16.h **** _crc8_ccitt_update(uint8_t __crc, uint8_t __data)
 387:/usr/lib/avr/include/util/crc16.h **** {
  14               		.loc 1 387 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 388:/usr/lib/avr/include/util/crc16.h ****     uint8_t __i, __pattern;
 389:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
  21               		.loc 1 389 0
  22               	/* #APP */
  23               	 ;  389 "/usr/lib/avr/include/util/crc16.h" 1
  24 0000 8627      		    eor    r24, r22
  25 0002 98E0      		    ldi    r25, 8
  26 0004 67E0      		    ldi    r22, 0x07
  27 0006 880F      		1:  lsl    r24
  28 0008 00F4      		    brcc   2f
  29 000a 8627      		    eor    r24, r22
  30 000c 9A95      		2:  dec    r25
  31 000e 01F4      		    brne   1b
  32               		
  33               	 ;  0 "" 2
  34               	.LVL1:
 390:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %4" "\n\t"
 391:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %1, 8" "\n\t"
 392:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %2, 0x07" "\n\t"
 393:/usr/lib/avr/include/util/crc16.h ****         "1:  lsl    %0" "\n\t"
 394:/usr/lib/avr/include/util/crc16.h ****         "    brcc   2f" "\n\t"
 395:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %2" "\n\t"
 396:/usr/lib/avr/include/util/crc16.h ****         "2:  dec    %1" "\n\t"
 397:/usr/lib/avr/include/util/crc16.h ****         "    brne   1b" "\n\t"
 398:/usr/lib/avr/include/util/crc16.h ****         : "=r" (__crc), "=d" (__i), "=d" (__pattern)
 399:/usr/lib/avr/include/util/crc16.h ****         : "0" (__crc), "r" (__data));
 400:/usr/lib/avr/include/util/crc16.h ****     return __crc;
 401:/usr/lib/avr/include/util/crc16.h **** }
  35               		.loc 1 401 0
  36               	/* #NOAPP */
  37 0010 0895      		ret
  38               		.cfi_endproc
  39               	.LFE4:
  41               	.global	ws2812_sendarray_mask
  43               	ws2812_sendarray_mask:
  44               	.LFB23:
  45               		.file 2 "light_ws2812.c"
   1:light_ws2812.c **** /*
   2:light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:light_ws2812.c **** *
   4:light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:light_ws2812.c **** *
   7:light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:light_ws2812.c **** *
   9:light_ws2812.c **** *
  10:light_ws2812.c **** * Jun 2019, modified for SHPI by Lutz Harder
  11:light_ws2812.c **** * License: GNU GPL v2+ (see License.txt)
  12:light_ws2812.c **** */
  13:light_ws2812.c **** 
  14:light_ws2812.c **** #include "light_ws2812.h"
  15:light_ws2812.c **** #include <avr/interrupt.h>
  16:light_ws2812.c **** #include <avr/io.h>
  17:light_ws2812.c **** #include <util/delay.h>
  18:light_ws2812.c ****  
  19:light_ws2812.c **** // Setleds for standard RGB 
  20:light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  21:light_ws2812.c **** {
  22:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  23:light_ws2812.c **** }
  24:light_ws2812.c **** 
  25:light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  26:light_ws2812.c **** {
  27:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  28:light_ws2812.c ****   _delay_us(ws2812_resettime);
  29:light_ws2812.c **** }
  30:light_ws2812.c **** 
  31:light_ws2812.c **** 
  32:light_ws2812.c **** 
  33:light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  34:light_ws2812.c **** {
  35:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  36:light_ws2812.c **** }
  37:light_ws2812.c **** 
  38:light_ws2812.c **** /*
  39:light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  40:light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  41:light_ws2812.c **** */
  42:light_ws2812.c **** 
  43:light_ws2812.c **** // Timing in ns
  44:light_ws2812.c **** #define w_zeropulse   350
  45:light_ws2812.c **** #define w_onepulse    900
  46:light_ws2812.c **** #define w_totalperiod 120
  47:light_ws2812.c **** 
  48:light_ws2812.c **** // Fixed cycles used by the inner loop
  49:light_ws2812.c **** #define w_fixedlow    2
  50:light_ws2812.c **** #define w_fixedhigh   4
  51:light_ws2812.c **** #define w_fixedtotal  8   
  52:light_ws2812.c **** 
  53:light_ws2812.c **** // Insert NOPs to match the timing, if possible
  54:light_ws2812.c **** #define w_zerocycles    (((F_CPU/1000)*w_zeropulse          )/1000000)
  55:light_ws2812.c **** #define w_onecycles     (((F_CPU/1000)*w_onepulse    +500000)/1000000)
  56:light_ws2812.c **** #define w_totalcycles   (((F_CPU/1000)*w_totalperiod +500000)/1000000)
  57:light_ws2812.c **** 
  58:light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  59:light_ws2812.c **** #define w1 (w_zerocycles-w_fixedlow)
  60:light_ws2812.c **** // w2   nops between fe low and fe high
  61:light_ws2812.c **** #define w2 (w_onecycles-w_fixedhigh-w1)
  62:light_ws2812.c **** // w3   nops to complete loop
  63:light_ws2812.c **** #define w3 (w_totalcycles-w_fixedtotal-w1-w2)
  64:light_ws2812.c **** 
  65:light_ws2812.c **** #if w1>0
  66:light_ws2812.c ****   #define w1_nops w1
  67:light_ws2812.c **** #else
  68:light_ws2812.c ****   #define w1_nops  0
  69:light_ws2812.c **** #endif
  70:light_ws2812.c **** 
  71:light_ws2812.c **** // The only critical timing parameter is the minimum pulse length of the "0"
  72:light_ws2812.c **** // Warn or throw error if this timing can not be met with current F_CPU settings.
  73:light_ws2812.c **** #define w_lowtime ((w1_nops+w_fixedlow)*1000000)/(F_CPU/1000)
  74:light_ws2812.c **** #if w_lowtime>550
  75:light_ws2812.c ****    #error "Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?"
  76:light_ws2812.c **** #elif w_lowtime>450
  77:light_ws2812.c ****    #warning "Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S)."
  78:light_ws2812.c ****    #warning "Please consider a higher clockspeed, if possible"
  79:light_ws2812.c **** #endif   
  80:light_ws2812.c **** 
  81:light_ws2812.c **** #if w2>0
  82:light_ws2812.c **** #define w2_nops w2
  83:light_ws2812.c **** #else
  84:light_ws2812.c **** #define w2_nops  0
  85:light_ws2812.c **** #endif
  86:light_ws2812.c **** 
  87:light_ws2812.c **** #if w3>0
  88:light_ws2812.c **** #define w3_nops w3
  89:light_ws2812.c **** #else
  90:light_ws2812.c **** #define w3_nops  0
  91:light_ws2812.c **** #endif
  92:light_ws2812.c **** 
  93:light_ws2812.c **** #define w_nop1  "nop      \n\t"
  94:light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
  95:light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
  96:light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
  97:light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
  98:light_ws2812.c **** 
  99:light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 100:light_ws2812.c **** {
  46               		.loc 2 100 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 101:light_ws2812.c ****   uint8_t curbyte,ctr,masklo;
 102:light_ws2812.c ****   uint8_t sreg_prev;
 103:light_ws2812.c ****   
 104:light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  53               		.loc 2 104 0
  54 0012 2AB1      		in r18,0xa
  55 0014 242B      		or r18,r20
  56 0016 2AB9      		out 0xa,r18
 105:light_ws2812.c ****   
 106:light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  57               		.loc 2 106 0
  58 0018 2BB1      		in r18,0xb
  59 001a 342F      		mov r19,r20
  60 001c 3095      		com r19
  61 001e 2323      		and r18,r19
  62               	.LVL3:
 107:light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  63               		.loc 2 107 0
  64 0020 3BB1      		in r19,0xb
  65 0022 432B      		or r20,r19
  66               	.LVL4:
 108:light_ws2812.c ****   
 109:light_ws2812.c ****   sreg_prev=SREG;
  67               		.loc 2 109 0
  68 0024 3FB7      		in r19,__SREG__
  69               	.LVL5:
 110:light_ws2812.c ****   cli();  
  70               		.loc 2 110 0
  71               	/* #APP */
  72               	 ;  110 "light_ws2812.c" 1
  73 0026 F894      		cli
  74               	 ;  0 "" 2
  75               	/* #NOAPP */
  76 0028 FC01      		movw r30,r24
  77 002a 680F      		add r22,r24
  78 002c 791F      		adc r23,r25
  79               	.LVL6:
  80               	.L3:
 111:light_ws2812.c **** 
 112:light_ws2812.c ****   while (datlen--) {
  81               		.loc 2 112 0
  82 002e E617      		cp r30,r22
  83 0030 F707      		cpc r31,r23
  84 0032 01F0      		breq .L6
  85               	.LVL7:
 113:light_ws2812.c ****     curbyte=*data++;
  86               		.loc 2 113 0
  87 0034 8191      		ld r24,Z+
  88               	.LVL8:
 114:light_ws2812.c ****     
 115:light_ws2812.c ****     asm volatile(
  89               		.loc 2 115 0
  90               	/* #APP */
  91               	 ;  115 "light_ws2812.c" 1
  92 0036 98E0      		       ldi   r25,8  
  93               		loop59:            
  94 0038 4BB9      		       out   11,r20 
  95 003a 0000      		nop      
  96 003c 00C0      		rjmp .+0 
  97 003e 87FF      		       sbrs  r24,7  
  98 0040 2BB9      		       out   11,r18 
  99 0042 880F      		       lsl   r24    
 100 0044 0000      		nop      
 101 0046 00C0      		rjmp .+0 
 102 0048 00C0      		rjmp .+0 
 103 004a 00C0      		rjmp .+0 
 104 004c 2BB9      		       out   11,r18 
 105 004e 00C0      		rjmp .+0 
 106 0050 00C0      		rjmp .+0 
 107 0052 00C0      		rjmp .+0 
 108 0054 00C0      		rjmp .+0 
 109 0056 00C0      		rjmp .+0 
 110 0058 00C0      		rjmp .+0 
 111 005a 00C0      		rjmp .+0 
 112 005c 00C0      		rjmp .+0 
 113 005e 9A95      		       dec   r25    
 114 0060 01F4      		       brne  loop59
 115               		
 116               	 ;  0 "" 2
 117               	.LVL9:
 118               	/* #NOAPP */
 119 0062 00C0      		rjmp .L3
 120               	.LVL10:
 121               	.L6:
 116:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 117:light_ws2812.c ****     "loop%=:            \n\t"
 118:light_ws2812.c ****     "       out   %2,%3 \n\t"    
 119:light_ws2812.c **** #if (w1_nops&1)
 120:light_ws2812.c **** w_nop1
 121:light_ws2812.c **** #endif
 122:light_ws2812.c **** #if (w1_nops&2)
 123:light_ws2812.c **** w_nop2
 124:light_ws2812.c **** #endif
 125:light_ws2812.c **** #if (w1_nops&4)
 126:light_ws2812.c **** w_nop4
 127:light_ws2812.c **** #endif
 128:light_ws2812.c **** #if (w1_nops&8)
 129:light_ws2812.c **** w_nop8
 130:light_ws2812.c **** #endif
 131:light_ws2812.c **** #if (w1_nops&16)
 132:light_ws2812.c **** w_nop16
 133:light_ws2812.c **** #endif
 134:light_ws2812.c ****     "       sbrs  %1,7  \n\t"   
 135:light_ws2812.c ****     "       out   %2,%4 \n\t"  
 136:light_ws2812.c ****     "       lsl   %1    \n\t"   
 137:light_ws2812.c **** #if (w2_nops&1)
 138:light_ws2812.c ****   w_nop1
 139:light_ws2812.c **** #endif
 140:light_ws2812.c **** #if (w2_nops&2)
 141:light_ws2812.c ****   w_nop2
 142:light_ws2812.c **** #endif
 143:light_ws2812.c **** #if (w2_nops&4)
 144:light_ws2812.c ****   w_nop4
 145:light_ws2812.c **** #endif
 146:light_ws2812.c **** #if (w2_nops&8)
 147:light_ws2812.c ****   w_nop8
 148:light_ws2812.c **** #endif
 149:light_ws2812.c **** #if (w2_nops&16)
 150:light_ws2812.c ****   w_nop16 
 151:light_ws2812.c **** #endif
 152:light_ws2812.c ****     "       out   %2,%4 \n\t"   
 153:light_ws2812.c **** #if (w3_nops&1)
 154:light_ws2812.c **** w_nop1
 155:light_ws2812.c **** #endif
 156:light_ws2812.c **** #if (w3_nops&2)
 157:light_ws2812.c **** w_nop2
 158:light_ws2812.c **** #endif
 159:light_ws2812.c **** #if (w3_nops&4)
 160:light_ws2812.c **** w_nop4
 161:light_ws2812.c **** #endif
 162:light_ws2812.c **** #if (w3_nops&8)
 163:light_ws2812.c **** w_nop8
 164:light_ws2812.c **** #endif
 165:light_ws2812.c **** #if (w3_nops&16)
 166:light_ws2812.c **** w_nop16
 167:light_ws2812.c **** #endif
 168:light_ws2812.c **** 
 169:light_ws2812.c ****     "       dec   %0    \n\t"   
 170:light_ws2812.c ****     "       brne  loop%=\n\t"   
 171:light_ws2812.c ****     :	"=&d" (ctr)
 172:light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 173:light_ws2812.c ****     );
 174:light_ws2812.c ****   }
 175:light_ws2812.c ****   
 176:light_ws2812.c ****   SREG=sreg_prev;
 122               		.loc 2 176 0
 123 0064 3FBF      		out __SREG__,r19
 124 0066 0895      		ret
 125               		.cfi_endproc
 126               	.LFE23:
 128               	.global	ws2812_setleds_pin
 130               	ws2812_setleds_pin:
 131               	.LFB21:
  26:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 132               		.loc 2 26 0
 133               		.cfi_startproc
 134               	.LVL11:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 139               		.loc 2 27 0
 140 0068 9B01      		movw r18,r22
 141 006a 220F      		lsl r18
 142 006c 331F      		rol r19
 143 006e 620F      		add r22,r18
 144 0070 731F      		adc r23,r19
 145               	.LVL12:
 146 0072 0E94 0000 		call ws2812_sendarray_mask
 147               	.LVL13:
 148               	.LBB56:
 149               	.LBB57:
 150               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 151               		.loc 3 276 0
 152 0076 8FEA      		ldi r24,lo8(1199)
 153 0078 94E0      		ldi r25,hi8(1199)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL14:
 159 0082 0895      		ret
 160               	.LBE57:
 161               	.LBE56:
 162               		.cfi_endproc
 163               	.LFE21:
 165               	.global	ws2812_setleds
 167               	ws2812_setleds:
 168               	.LFB20:
  21:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 169               		.loc 2 21 0
 170               		.cfi_startproc
 171               	.LVL15:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  22:light_ws2812.c **** }
 176               		.loc 2 22 0
 177 0084 40E2      		ldi r20,lo8(32)
 178 0086 0C94 0000 		jmp ws2812_setleds_pin
 179               	.LVL16:
 180               		.cfi_endproc
 181               	.LFE20:
 183               	.global	ws2812_sendarray
 185               	ws2812_sendarray:
 186               	.LFB22:
  34:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 187               		.loc 2 34 0
 188               		.cfi_startproc
 189               	.LVL17:
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 0 */
 193               	.L__stack_usage = 0
  35:light_ws2812.c **** }
 194               		.loc 2 35 0
 195 008a 40E2      		ldi r20,lo8(32)
 196 008c 0C94 0000 		jmp ws2812_sendarray_mask
 197               	.LVL18:
 198               		.cfi_endproc
 199               	.LFE22:
 201               	.global	write_backlight
 203               	write_backlight:
 204               	.LFB24:
 205               		.file 4 "main.c"
   1:main.c        **** /*
   2:main.c        ****  *  SHPI.one Basic Firmware v1.2 BETA
   3:main.c        ****  *
   4:main.c        ****  *
   5:main.c        ****  *
   6:main.c        ****  * Basic Firmware for ATmega32u4 slave,  no radio module support included
   7:main.c        ****  *
   8:main.c        ****  * Jul    15th, 2019  v 1.1b initial Version
   9:main.c        ****  * October 4th, 2019  v1.2  Beta
  10:main.c        ****  *    NEW: implemented CRC Check via CRC8  CCITT
  11:main.c        **** 
  12:main.c        ****  * Aug 28th, 2020 v2.0
  13:main.c        ****  *
  14:main.c        ****  *
  15:main.c        ****  *
  16:main.c        ****  *
  17:main.c        ****  * Author: Lutz Harder
  18:main.c        ****  * License: GNU GPL
  19:main.c        ****  */
  20:main.c        **** 
  21:main.c        **** #define FW_VERSION  0x01
  22:main.c        **** #define I2C_ADDR 0x2A
  23:main.c        **** #define LCD_WRITE_DELAY 0.5
  24:main.c        **** #define LCD_WAIT 100
  25:main.c        **** #define ws2812_resettime  300
  26:main.c        **** #define ws2812_port D
  27:main.c        **** #define ws2812_pin  5
  28:main.c        **** 
  29:main.c        **** #define SDA_LINE  (PIND & (1<<PD1))
  30:main.c        **** #define SCL_LINE  (PIND & (1<<PD0))
  31:main.c        **** 
  32:main.c        **** #include <util/crc16.h>
  33:main.c        **** #include <avr/wdt.h>
  34:main.c        **** #include <avr/power.h>
  35:main.c        **** #include <avr/io.h>
  36:main.c        **** #include <stdlib.h>
  37:main.c        **** #include <util/delay.h>
  38:main.c        **** #include <avr/interrupt.h>
  39:main.c        **** #include <stdint.h>
  40:main.c        **** #include <util/twi.h>
  41:main.c        **** #include "light_ws2812.c"
  42:main.c        **** #include "light_ws2812.h"
  43:main.c        **** 
  44:main.c        **** struct cRGB led[255];
  45:main.c        **** uint8_t displaychange = 0, jumptobootloader = 0, watchdog = 0x00, display = 0xFF, led_position = 0,
  46:main.c        **** uint16_t a0,a1,a2,a3,a4,a5,a7,a7avg,a7max,a7min,vcc,temp,rpm,fanspin,isrtimer,i2cbuffer = 0, watchi
  47:main.c        **** 
  48:main.c        **** uint16_t data_lcd_shpi397[] =
  49:main.c        **** {
  50:main.c        **** 
  51:main.c        **** 0x0FF,0x1FF,0x198,0x106,0x104,0x101,
  52:main.c        **** 0x008,0x110,
  53:main.c        **** 0x021,0x10D,
  54:main.c        **** 0x030,0x102,
  55:main.c        **** 0x031,0x100,
  56:main.c        **** 0x040,0x110,
  57:main.c        **** 0x041,0x155,
  58:main.c        **** 0x042,0x102,    
  59:main.c        **** 0x043,0x184,
  60:main.c        **** 0x044,0x184, 
  61:main.c        **** 0x050,0x178,  
  62:main.c        **** 0x051,0x178, 
  63:main.c        **** 0x052,0x100,
  64:main.c        **** 0x053,0x177,
  65:main.c        **** 0x057,0x160,
  66:main.c        **** 0x060,0x107,
  67:main.c        **** 0x061,0x100, 
  68:main.c        **** 0x062,0x108, 
  69:main.c        **** 0x063,0x100, 
  70:main.c        **** 0x0A0,0x100,
  71:main.c        **** 0x0A1,0x107,
  72:main.c        **** 0x0A2,0x10C,
  73:main.c        **** 0x0A3,0x10B,
  74:main.c        **** 0x0A4,0x103,
  75:main.c        **** 0x0A5,0x107,
  76:main.c        **** 0x0A6,0x106,
  77:main.c        **** 0x0A7,0x104,
  78:main.c        **** 0x0A8,0x108,
  79:main.c        **** 0x0A9,0x10C,
  80:main.c        **** 0x0AA,0x113,
  81:main.c        **** 0x0AB,0x106,
  82:main.c        **** 0x0AC,0x10D,
  83:main.c        **** 0x0AD,0x119,
  84:main.c        **** 0x0AE,0x110,
  85:main.c        **** 0x0AF,0x100, 
  86:main.c        **** 0x0C0,0x100,
  87:main.c        **** 0x0C1,0x107,
  88:main.c        **** 0x0C2,0x10C,
  89:main.c        **** 0x0C3,0x10B,
  90:main.c        **** 0x0C4,0x103,
  91:main.c        **** 0x0C5,0x107,
  92:main.c        **** 0x0C6,0x107,
  93:main.c        **** 0x0C7,0x104,
  94:main.c        **** 0x0C8,0x108,
  95:main.c        **** 0x0C9,0x10C,
  96:main.c        **** 0x0CA,0x113,
  97:main.c        **** 0x0CB,0x106,
  98:main.c        **** 0x0CC,0x10D,
  99:main.c        **** 0x0CD,0x118,
 100:main.c        **** 0x0CE,0x110,
 101:main.c        **** 0x0CF,0x100,
 102:main.c        **** 0x0FF,0x1FF,0x198,0x106,0x104,0x106, 
 103:main.c        **** 0x000,0x120,
 104:main.c        **** 0x001,0x10A,
 105:main.c        **** 0x002,0x100,
 106:main.c        **** 0x003,0x100,
 107:main.c        **** 0x004,0x101,
 108:main.c        **** 0x005,0x101,
 109:main.c        **** 0x006,0x198,
 110:main.c        **** 0x007,0x106,
 111:main.c        **** 0x008,0x101,
 112:main.c        **** 0x009,0x180,
 113:main.c        **** 0x00A,0x100,
 114:main.c        **** 0x00B,0x100,
 115:main.c        **** 0x00C,0x101,
 116:main.c        **** 0x00D,0x101,
 117:main.c        **** 0x00E,0x100,
 118:main.c        **** 0x00F,0x100,
 119:main.c        **** 0x010,0x1F0,
 120:main.c        **** 0x011,0x1F4,
 121:main.c        **** 0x012,0x101,
 122:main.c        **** 0x013,0x100,
 123:main.c        **** 0x014,0x100,
 124:main.c        **** 0x015,0x1C0,
 125:main.c        **** 0x016,0x108,
 126:main.c        **** 0x017,0x100,
 127:main.c        **** 0x018,0x100,
 128:main.c        **** 0x019,0x100,
 129:main.c        **** 0x01A,0x100,
 130:main.c        **** 0x01B,0x100,
 131:main.c        **** 0x01C,0x100,
 132:main.c        **** 0x01D,0x100,
 133:main.c        **** 0x020,0x101,
 134:main.c        **** 0x021,0x123,
 135:main.c        **** 0x022,0x145,
 136:main.c        **** 0x023,0x167,
 137:main.c        **** 0x024,0x101,
 138:main.c        **** 0x025,0x123,
 139:main.c        **** 0x026,0x145,
 140:main.c        **** 0x027,0x167,
 141:main.c        **** 0x030,0x111,
 142:main.c        **** 0x031,0x111,
 143:main.c        **** 0x032,0x100,
 144:main.c        **** 0x033,0x1EE,
 145:main.c        **** 0x034,0x1FF,
 146:main.c        **** 0x035,0x1BB,
 147:main.c        **** 0x036,0x1AA,
 148:main.c        **** 0x037,0x1DD,
 149:main.c        **** 0x038,0x1CC,
 150:main.c        **** 0x039,0x166,
 151:main.c        **** 0x03A,0x177,
 152:main.c        **** 0x03B,0x122,
 153:main.c        **** 0x03C,0x122,
 154:main.c        **** 0x03D,0x122,
 155:main.c        **** 0x03E,0x122,
 156:main.c        **** 0x03F,0x122,
 157:main.c        **** 0x040,0x122,
 158:main.c        **** 0x052,0x110,
 159:main.c        **** 0x053,0x110,
 160:main.c        **** 0x054,0x113,
 161:main.c        **** 0x0FF,0x1FF,0x198,0x106,0x104,0x107,
 162:main.c        **** 0x018,0x11D,  
 163:main.c        **** 0x017,0x122,
 164:main.c        **** 0x002,0x177,
 165:main.c        **** 0x026,0x1B2,
 166:main.c        **** 0x0E1,0x179,
 167:main.c        **** 0x0FF,0x1FF,0x198,0x106,0x104,0x100,   
 168:main.c        **** 0x03A,0x160, 
 169:main.c        **** 0x035,0x100,
 170:main.c        **** 0x011,0x100, 
 171:main.c        **** 0xffff,          
 172:main.c        **** 0x029,0x100,
 173:main.c        **** 
 174:main.c        **** };
 175:main.c        **** 
 176:main.c        **** 
 177:main.c        **** 
 178:main.c        **** 
 179:main.c        **** 
 180:main.c        **** 								 // set single wire brightness  AL3050
 181:main.c        **** void write_backlight(uint8_t data)
 182:main.c        **** {
 206               		.loc 4 182 0
 207               		.cfi_startproc
 208               	.LVL19:
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213               		.loc 4 182 0
 214 0090 27E0      		ldi r18,lo8(7)
 215 0092 30E0      		ldi r19,0
 183:main.c        **** 	uint8_t count = 8;
 184:main.c        **** 	do
 185:main.c        **** 	{
 186:main.c        **** 		PORTD &= ~_BV(PD4);
 187:main.c        **** 		_delay_us(50);
 188:main.c        **** 		if (!(data & (1 << (count - 1))))
 216               		.loc 4 188 0
 217 0094 90E0      		ldi r25,0
 218               	.LVL20:
 219               	.L13:
 186:main.c        **** 		_delay_us(50);
 220               		.loc 4 186 0
 221 0096 5C98      		cbi 0xb,4
 222               	.LVL21:
 223               	.LBB58:
 224               	.LBB59:
 225               		.loc 3 276 0
 226 0098 E7EC      		ldi r30,lo8(199)
 227 009a F0E0      		ldi r31,hi8(199)
 228 009c 3197      	1:	sbiw r30,1
 229 009e 01F4      		brne 1b
 230 00a0 00C0      		rjmp .
 231 00a2 0000      		nop
 232               	.LVL22:
 233               	.LBE59:
 234               	.LBE58:
 235               		.loc 4 188 0
 236 00a4 AC01      		movw r20,r24
 237 00a6 022E      		mov r0,r18
 238 00a8 00C0      		rjmp 2f
 239               		1:
 240 00aa 5595      		asr r21
 241 00ac 4795      		ror r20
 242               		2:
 243 00ae 0A94      		dec r0
 244 00b0 02F4      		brpl 1b
 245 00b2 BA01      		movw r22,r20
 246 00b4 6170      		andi r22,1
 247 00b6 7727      		clr r23
 248 00b8 40FD      		sbrc r20,0
 249 00ba 00C0      		rjmp .L11
 250               	.LVL23:
 251               	.LBB60:
 252               	.LBB61:
 253               		.loc 3 276 0
 254 00bc E7EC      		ldi r30,lo8(199)
 255 00be F0E0      		ldi r31,hi8(199)
 256 00c0 3197      	1:	sbiw r30,1
 257 00c2 01F4      		brne 1b
 258 00c4 00C0      		rjmp .
 259 00c6 0000      		nop
 260               	.LVL24:
 261               	.L11:
 262               	.LBE61:
 263               	.LBE60:
 189:main.c        **** 		{
 190:main.c        **** 			_delay_us(50);
 191:main.c        **** 		}
 192:main.c        **** 		PORTD |= _BV(PD4);
 264               		.loc 4 192 0
 265 00c8 5C9A      		sbi 0xb,4
 266               	.LVL25:
 267               	.LBB62:
 268               	.LBB63:
 269               		.loc 3 276 0
 270 00ca E7EC      		ldi r30,lo8(199)
 271 00cc F0E0      		ldi r31,hi8(199)
 272 00ce 3197      	1:	sbiw r30,1
 273 00d0 01F4      		brne 1b
 274 00d2 00C0      		rjmp .
 275 00d4 0000      		nop
 276               	.LVL26:
 277               	.LBE63:
 278               	.LBE62:
 193:main.c        **** 		_delay_us(50);
 194:main.c        **** 		if ((data & (1 << (count - 1))) != 0)
 279               		.loc 4 194 0
 280 00d6 672B      		or r22,r23
 281 00d8 01F0      		breq .L12
 282               	.LVL27:
 283               	.LBB64:
 284               	.LBB65:
 285               		.loc 3 276 0
 286 00da E7EC      		ldi r30,lo8(199)
 287 00dc F0E0      		ldi r31,hi8(199)
 288 00de 3197      	1:	sbiw r30,1
 289 00e0 01F4      		brne 1b
 290 00e2 00C0      		rjmp .
 291 00e4 0000      		nop
 292               	.LVL28:
 293               	.L12:
 294               	.LVL29:
 295               	.LBE65:
 296               	.LBE64:
 297 00e6 2150      		subi r18,1
 298 00e8 3109      		sbc r19,__zero_reg__
 299 00ea 00F4      		brcc .L13
 195:main.c        **** 		{
 196:main.c        **** 			_delay_us(50);
 197:main.c        **** 		}
 198:main.c        **** 		count--;
 199:main.c        **** 	} while (count);
 200:main.c        **** 
 201:main.c        **** 	PORTD &= ~_BV(PD4);
 300               		.loc 4 201 0
 301 00ec 5C98      		cbi 0xb,4
 302               	.LVL30:
 303               	.LBB66:
 304               	.LBB67:
 305               		.loc 3 276 0
 306 00ee 87EC      		ldi r24,lo8(199)
 307 00f0 90E0      		ldi r25,hi8(199)
 308 00f2 0197      	1:	sbiw r24,1
 309 00f4 01F4      		brne 1b
 310               	.LVL31:
 311 00f6 00C0      		rjmp .
 312 00f8 0000      		nop
 313               	.LVL32:
 314               	.LBE67:
 315               	.LBE66:
 202:main.c        **** 	_delay_us(50);
 203:main.c        **** 	PORTD |= _BV(PD4);
 316               		.loc 4 203 0
 317 00fa 5C9A      		sbi 0xb,4
 318               	.LVL33:
 319               	.LBB68:
 320               	.LBB69:
 321               		.loc 3 276 0
 322 00fc E7EC      		ldi r30,lo8(199)
 323 00fe F0E0      		ldi r31,hi8(199)
 324 0100 3197      	1:	sbiw r30,1
 325 0102 01F4      		brne 1b
 326 0104 00C0      		rjmp .
 327 0106 0000      		nop
 328               	.LVL34:
 329 0108 0895      		ret
 330               	.LBE69:
 331               	.LBE68:
 332               		.cfi_endproc
 333               	.LFE24:
 335               	.global	init_backlight
 337               	init_backlight:
 338               	.LFB25:
 204:main.c        **** 	_delay_us(50);
 205:main.c        **** }
 206:main.c        **** 
 207:main.c        **** 
 208:main.c        **** void init_backlight(void)		 // init AL3050 single wire dimming
 209:main.c        **** {
 339               		.loc 4 209 0
 340               		.cfi_startproc
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
 210:main.c        **** 	PORTD &= ~_BV(PD4);
 345               		.loc 4 210 0
 346 010a 5C98      		cbi 0xb,4
 347               	.LVL35:
 348               	.LBB70:
 349               	.LBB71:
 350               		.loc 3 276 0
 351 010c 8FED      		ldi r24,lo8(11999)
 352 010e 9EE2      		ldi r25,hi8(11999)
 353 0110 0197      	1:	sbiw r24,1
 354 0112 01F4      		brne 1b
 355 0114 00C0      		rjmp .
 356 0116 0000      		nop
 357               	.LVL36:
 358               	.LBE71:
 359               	.LBE70:
 211:main.c        **** 	_delay_us(3000);
 212:main.c        **** 	PORTD |= _BV(PD4);
 360               		.loc 4 212 0
 361 0118 5C9A      		sbi 0xb,4
 362               	.LVL37:
 363               	.LBB72:
 364               	.LBB73:
 365               		.loc 3 276 0
 366 011a 8FED      		ldi r24,lo8(479)
 367 011c 91E0      		ldi r25,hi8(479)
 368 011e 0197      	1:	sbiw r24,1
 369 0120 01F4      		brne 1b
 370 0122 00C0      		rjmp .
 371 0124 0000      		nop
 372               	.LVL38:
 373               	.LBE73:
 374               	.LBE72:
 213:main.c        **** 	_delay_us(120);
 214:main.c        **** 	PORTD &= ~_BV(PD4);
 375               		.loc 4 214 0
 376 0126 5C98      		cbi 0xb,4
 377               	.LVL39:
 378               	.LBB74:
 379               	.LBB75:
 380               		.loc 3 276 0
 381 0128 8FEC      		ldi r24,lo8(1999)
 382 012a 97E0      		ldi r25,hi8(1999)
 383 012c 0197      	1:	sbiw r24,1
 384 012e 01F4      		brne 1b
 385 0130 00C0      		rjmp .
 386 0132 0000      		nop
 387               	.LVL40:
 388               	.LBE75:
 389               	.LBE74:
 215:main.c        **** 	_delay_us(500);
 216:main.c        **** 	PORTD |= _BV(PD4);
 390               		.loc 4 216 0
 391 0134 5C9A      		sbi 0xb,4
 392               	.LVL41:
 393               	.LBB76:
 394               	.LBB77:
 395               		.loc 3 276 0
 396 0136 9AE1      		ldi r25,lo8(26)
 397 0138 9A95      	1:	dec r25
 398 013a 01F4      		brne 1b
 399 013c 00C0      		rjmp .
 400               	.LVL42:
 401               	.LBE77:
 402               	.LBE76:
 217:main.c        **** 	_delay_us(5);
 218:main.c        **** 	bllevel = 31;
 403               		.loc 4 218 0
 404 013e 8FE1      		ldi r24,lo8(31)
 405 0140 8093 0000 		sts bllevel,r24
 219:main.c        **** 	newbllevel = 31;
 406               		.loc 4 219 0
 407 0144 8093 0000 		sts newbllevel,r24
 408 0148 0895      		ret
 409               		.cfi_endproc
 410               	.LFE25:
 412               	.global	write_lcd
 414               	write_lcd:
 415               	.LFB26:
 220:main.c        **** }
 221:main.c        **** 
 222:main.c        **** 
 223:main.c        **** 
 224:main.c        **** 								 //  write routine for LCD setup
 225:main.c        **** void write_lcd(uint16_t data, uint8_t count)
 226:main.c        **** {
 416               		.loc 4 226 0
 417               		.cfi_startproc
 418               	.LVL43:
 419               	/* prologue: function */
 420               	/* frame size = 0 */
 421               	/* stack size = 0 */
 422               	.L__stack_usage = 0
 423 014a AC01      		movw r20,r24
 227:main.c        **** 	PORTD &= ~_BV(PD4);
 424               		.loc 4 227 0
 425 014c 5C98      		cbi 0xb,4
 228:main.c        **** 
 229:main.c        **** 	do
 230:main.c        **** 	{
 231:main.c        **** 		PORTB &= ~_BV(PB2);
 232:main.c        **** 								 // BITWISE AND -> PB2
 233:main.c        **** 		PORTB |= (((data & (1 << (count - 1))) != 0) << 2);
 426               		.loc 4 233 0
 427 014e E1E0      		ldi r30,lo8(1)
 428 0150 F0E0      		ldi r31,0
 429               	.LVL44:
 430               	.L21:
 231:main.c        **** 								 // BITWISE AND -> PB2
 431               		.loc 4 231 0
 432 0152 2A98      		cbi 0x5,2
 433               		.loc 4 233 0
 434 0154 95B1      		in r25,0x5
 435 0156 8FEF      		ldi r24,lo8(-1)
 436 0158 860F      		add r24,r22
 437 015a 9F01      		movw r18,r30
 438 015c 00C0      		rjmp 2f
 439               		1:
 440 015e 220F      		lsl r18
 441 0160 331F      		rol r19
 442               		2:
 443 0162 8A95      		dec r24
 444 0164 02F4      		brpl 1b
 445 0166 2423      		and r18,r20
 446 0168 3523      		and r19,r21
 447 016a 232B      		or r18,r19
 448 016c 01F4      		brne .L22
 449 016e 20E0      		ldi r18,0
 450 0170 00C0      		rjmp .L20
 451               	.L22:
 452 0172 24E0      		ldi r18,lo8(4)
 453               	.L20:
 454               		.loc 4 233 0 is_stmt 0 discriminator 4
 455 0174 922B      		or r25,r18
 456 0176 95B9      		out 0x5,r25
 234:main.c        **** 		PORTB &= ~_BV(PB1);
 457               		.loc 4 234 0 is_stmt 1 discriminator 4
 458 0178 2998      		cbi 0x5,1
 459               	.LVL45:
 460               	.LBB78:
 461               	.LBB79:
 462               		.loc 3 276 0 discriminator 4
 463 017a 82E0      		ldi r24,lo8(2)
 464 017c 8A95      	1:	dec r24
 465 017e 01F4      		brne 1b
 466 0180 00C0      		rjmp .
 467               	.LVL46:
 468               	.LBE79:
 469               	.LBE78:
 235:main.c        **** 		_delay_us(LCD_WRITE_DELAY);
 236:main.c        **** 		PORTB |= _BV(PB1);
 470               		.loc 4 236 0 discriminator 4
 471 0182 299A      		sbi 0x5,1
 472               	.LVL47:
 473               	.LBB80:
 474               	.LBB81:
 475               		.loc 3 276 0 discriminator 4
 476 0184 82E0      		ldi r24,lo8(2)
 477 0186 8A95      	1:	dec r24
 478 0188 01F4      		brne 1b
 479 018a 00C0      		rjmp .
 480               	.LVL48:
 481               	.LBE81:
 482               	.LBE80:
 237:main.c        **** 		_delay_us(LCD_WRITE_DELAY);
 238:main.c        **** 		count--;
 483               		.loc 4 238 0 discriminator 4
 484 018c 6150      		subi r22,lo8(-(-1))
 485               	.LVL49:
 239:main.c        **** 	} while (count);
 486               		.loc 4 239 0 discriminator 4
 487 018e 01F4      		brne .L21
 240:main.c        **** 	PORTB &= ~_BV(PB2);
 488               		.loc 4 240 0
 489 0190 2A98      		cbi 0x5,2
 241:main.c        **** 	PORTD |= _BV(PD4);
 490               		.loc 4 241 0
 491 0192 5C9A      		sbi 0xb,4
 492               	.LVL50:
 493               	.LBB82:
 494               	.LBB83:
 495               		.loc 3 276 0
 496 0194 82E0      		ldi r24,lo8(2)
 497 0196 8A95      	1:	dec r24
 498 0198 01F4      		brne 1b
 499 019a 00C0      		rjmp .
 500               	.LVL51:
 501 019c 0895      		ret
 502               	.LBE83:
 503               	.LBE82:
 504               		.cfi_endproc
 505               	.LFE26:
 507               	.global	setup_lcd
 509               	setup_lcd:
 510               	.LFB27:
 242:main.c        **** 	_delay_us(LCD_WRITE_DELAY);
 243:main.c        **** 
 244:main.c        **** }
 245:main.c        **** 
 246:main.c        **** 
 247:main.c        **** void setup_lcd(void)
 248:main.c        **** {
 511               		.loc 4 248 0
 512               		.cfi_startproc
 513 019e CF93      		push r28
 514               	.LCFI0:
 515               		.cfi_def_cfa_offset 3
 516               		.cfi_offset 28, -2
 517 01a0 DF93      		push r29
 518               	.LCFI1:
 519               		.cfi_def_cfa_offset 4
 520               		.cfi_offset 29, -3
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 2 */
 524               	.L__stack_usage = 2
 249:main.c        **** 
 250:main.c        **** 	PORTD |= _BV(PD4);
 525               		.loc 4 250 0
 526 01a2 5C9A      		sbi 0xb,4
 527               	.LVL52:
 528               	.LBB84:
 529               	.LBB85:
 530               		.loc 3 276 0
 531 01a4 2AE1      		ldi r18,lo8(26)
 532 01a6 2A95      	1:	dec r18
 533 01a8 01F4      		brne 1b
 534 01aa 00C0      		rjmp .
 535               	.LVL53:
 536 01ac C0E0      		ldi r28,lo8(data_lcd_shpi397)
 537 01ae D0E0      		ldi r29,hi8(data_lcd_shpi397)
 538               	.LVL54:
 539               	.L25:
 540               	.LBE85:
 541               	.LBE84:
 542               	.LBB86:
 251:main.c        **** 	_delay_us(5);
 252:main.c        **** 
 253:main.c        **** 	for(int x=0; x < sizeof(data_lcd_shpi397)/sizeof(uint16_t); x++ )
 543               		.loc 4 253 0 discriminator 1
 544 01b0 80E0      		ldi r24,hi8(data_lcd_shpi397+518)
 545 01b2 C030      		cpi r28,lo8(data_lcd_shpi397+518)
 546 01b4 D807      		cpc r29,r24
 547 01b6 01F0      		breq .L29
 254:main.c        **** 	{
 255:main.c        **** 
 256:main.c        **** 		if (data_lcd_shpi397[x] == 0xffff)
 548               		.loc 4 256 0
 549 01b8 8991      		ld r24,Y+
 550 01ba 9991      		ld r25,Y+
 551 01bc 8F3F      		cpi r24,-1
 552 01be 2FEF      		ldi r18,-1
 553 01c0 9207      		cpc r25,r18
 554 01c2 01F4      		brne .L26
 555               	.LVL55:
 556               	.LBB87:
 557               	.LBB88:
 187:/usr/lib/avr/include/util/delay.h **** 
 558               		.loc 3 187 0
 559 01c4 8FEF      		ldi r24,lo8(319999)
 560 01c6 91EE      		ldi r25,hi8(319999)
 561 01c8 24E0      		ldi r18,hlo8(319999)
 562 01ca 8150      	1:	subi r24,1
 563 01cc 9040      		sbci r25,0
 564 01ce 2040      		sbci r18,0
 565 01d0 01F4      		brne 1b
 566 01d2 00C0      		rjmp .
 567 01d4 0000      		nop
 568 01d6 00C0      		rjmp .L25
 569               	.LVL56:
 570               	.L26:
 571               	.LBE88:
 572               	.LBE87:
 257:main.c        **** 			{_delay_ms(LCD_WAIT);}
 258:main.c        **** 			else { write_lcd(data_lcd_shpi397[x],9);}
 573               		.loc 4 258 0
 574 01d8 69E0      		ldi r22,lo8(9)
 575 01da 0E94 0000 		call write_lcd
 576               	.LVL57:
 577 01de 00C0      		rjmp .L25
 578               	.L29:
 579               	/* epilogue start */
 580               	.LBE86:
 259:main.c        **** 
 260:main.c        **** 	}
 261:main.c        **** }
 581               		.loc 4 261 0
 582 01e0 DF91      		pop r29
 583 01e2 CF91      		pop r28
 584 01e4 0895      		ret
 585               		.cfi_endproc
 586               	.LFE27:
 588               	.global	read_analog
 590               	read_analog:
 591               	.LFB28:
 262:main.c        **** 
 263:main.c        **** 
 264:main.c        **** uint16_t read_analog(uint8_t channel)
 265:main.c        **** {
 592               		.loc 4 265 0
 593               		.cfi_startproc
 594               	.LVL58:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 266:main.c        **** 	uint8_t low, high;
 267:main.c        **** 	ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 599               		.loc 4 267 0
 600 01e6 9091 7A00 		lds r25,122
 601 01ea 9760      		ori r25,lo8(7)
 602 01ec 9093 7A00 		sts 122,r25
 268:main.c        **** 	ADCSRB = 0x40;
 603               		.loc 4 268 0
 604 01f0 90E4      		ldi r25,lo8(64)
 605 01f2 9093 7B00 		sts 123,r25
 269:main.c        **** 	ADMUX = ((0 << REFS1) | (1 << REFS0) | (0 << ADLAR));
 606               		.loc 4 269 0
 607 01f6 9093 7C00 		sts 124,r25
 270:main.c        **** 
 271:main.c        **** 	if (channel >= 8)			 //
 608               		.loc 4 271 0
 609 01fa 8830      		cpi r24,lo8(8)
 610 01fc 00F0      		brlo .L31
 272:main.c        **** 	{
 273:main.c        **** 		channel -= 0x08;		 //ch - 8
 611               		.loc 4 273 0
 612 01fe 8850      		subi r24,lo8(-(-8))
 613               	.LVL59:
 274:main.c        **** 		ADCSRB |= (1 << MUX5);	 // set MUX5 on ADCSRB to read upper bit ADC8-ADC13
 614               		.loc 4 274 0
 615 0200 9091 7B00 		lds r25,123
 616 0204 9062      		ori r25,lo8(32)
 617 0206 00C0      		rjmp .L35
 618               	.L31:
 275:main.c        **** 	}
 276:main.c        **** 	else
 277:main.c        **** 	{
 278:main.c        **** 		ADCSRB &= ~(1 << MUX5);	 // clear MUX 5
 619               		.loc 4 278 0
 620 0208 9091 7B00 		lds r25,123
 621 020c 9F7D      		andi r25,lo8(-33)
 622               	.L35:
 623 020e 9093 7B00 		sts 123,r25
 624               	.LVL60:
 279:main.c        **** 	}
 280:main.c        **** 	channel &= 0x07;
 281:main.c        **** 	ADMUX |= channel;			 // selecting channel
 625               		.loc 4 281 0
 626 0212 9091 7C00 		lds r25,124
 627 0216 8770      		andi r24,lo8(7)
 628               	.LVL61:
 629 0218 892B      		or r24,r25
 630               	.LVL62:
 631 021a 8093 7C00 		sts 124,r24
 282:main.c        **** 
 283:main.c        **** 	ADCSRA |= _BV(ADEN);
 632               		.loc 4 283 0
 633 021e 8091 7A00 		lds r24,122
 634 0222 8068      		ori r24,lo8(-128)
 635 0224 8093 7A00 		sts 122,r24
 636               	.LVL63:
 637               	.LBB89:
 638               	.LBB90:
 187:/usr/lib/avr/include/util/delay.h **** 
 639               		.loc 3 187 0
 640 0228 8FE3      		ldi r24,lo8(7999)
 641 022a 9FE1      		ldi r25,hi8(7999)
 642 022c 0197      	1:	sbiw r24,1
 643 022e 01F4      		brne 1b
 644 0230 00C0      		rjmp .
 645 0232 0000      		nop
 646               	.LVL64:
 647               	.LBE90:
 648               	.LBE89:
 284:main.c        **** 	_delay_ms(2);
 285:main.c        **** 	ADCSRA |= (1 << ADSC);
 649               		.loc 4 285 0
 650 0234 8091 7A00 		lds r24,122
 651 0238 8064      		ori r24,lo8(64)
 652 023a 8093 7A00 		sts 122,r24
 653               	.L33:
 286:main.c        **** 
 287:main.c        **** 	while ((ADCSRA & _BV(ADSC)));// measuring
 654               		.loc 4 287 0 discriminator 1
 655 023e 8091 7A00 		lds r24,122
 656 0242 86FD      		sbrc r24,6
 657 0244 00C0      		rjmp .L33
 288:main.c        **** 	low = ADCL;
 658               		.loc 4 288 0
 659 0246 8091 7800 		lds r24,120
 660               	.LVL65:
 289:main.c        **** 	high = ADCH;
 661               		.loc 4 289 0
 662 024a 2091 7900 		lds r18,121
 663               	.LVL66:
 290:main.c        **** 	return (high << 8) | low;
 664               		.loc 4 290 0
 665 024e 90E0      		ldi r25,0
 291:main.c        **** 
 292:main.c        **** }
 666               		.loc 4 292 0
 667 0250 922B      		or r25,r18
 668 0252 0895      		ret
 669               		.cfi_endproc
 670               	.LFE28:
 672               	.global	readVcc
 674               	readVcc:
 675               	.LFB29:
 293:main.c        **** 
 294:main.c        **** 
 295:main.c        **** uint16_t readVcc(void)
 296:main.c        **** {
 676               		.loc 4 296 0
 677               		.cfi_startproc
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 0 */
 681               	.L__stack_usage = 0
 297:main.c        **** 	ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
 682               		.loc 4 297 0
 683 0254 8EE5      		ldi r24,lo8(94)
 684 0256 8093 7C00 		sts 124,r24
 298:main.c        **** 	ADCSRA |= _BV(ADEN);
 685               		.loc 4 298 0
 686 025a 8091 7A00 		lds r24,122
 687 025e 8068      		ori r24,lo8(-128)
 688 0260 8093 7A00 		sts 122,r24
 299:main.c        **** 	ADCSRB &= ~_BV(MUX5);
 689               		.loc 4 299 0
 690 0264 8091 7B00 		lds r24,123
 691 0268 8F7D      		andi r24,lo8(-33)
 692 026a 8093 7B00 		sts 123,r24
 693               	.LVL67:
 694               	.LBB91:
 695               	.LBB92:
 187:/usr/lib/avr/include/util/delay.h **** 
 696               		.loc 3 187 0
 697 026e 8FE3      		ldi r24,lo8(7999)
 698 0270 9FE1      		ldi r25,hi8(7999)
 699 0272 0197      	1:	sbiw r24,1
 700 0274 01F4      		brne 1b
 701 0276 00C0      		rjmp .
 702 0278 0000      		nop
 703               	.LVL68:
 704               	.LBE92:
 705               	.LBE91:
 300:main.c        **** 	_delay_ms(2);
 301:main.c        **** 	ADCSRA |= 1 << ADSC;
 706               		.loc 4 301 0
 707 027a 8091 7A00 		lds r24,122
 708 027e 8064      		ori r24,lo8(64)
 709 0280 8093 7A00 		sts 122,r24
 710               	.L37:
 302:main.c        **** 	while ((ADCSRA & _BV(ADSC)));// measuring
 711               		.loc 4 302 0 discriminator 1
 712 0284 8091 7A00 		lds r24,122
 713 0288 86FD      		sbrc r24,6
 714 028a 00C0      		rjmp .L37
 303:main.c        **** 	ADCSRA |= 1 << ADSC;
 715               		.loc 4 303 0
 716 028c 8091 7A00 		lds r24,122
 717 0290 8064      		ori r24,lo8(64)
 718 0292 8093 7A00 		sts 122,r24
 719               	.L38:
 304:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 720               		.loc 4 304 0 discriminator 1
 721 0296 8091 7A00 		lds r24,122
 722 029a 86FD      		sbrc r24,6
 723 029c 00C0      		rjmp .L38
 305:main.c        **** 	return 1125300L / (ADCL | (ADCH<<8));
 724               		.loc 4 305 0
 725 029e 2091 7800 		lds r18,120
 726 02a2 8091 7900 		lds r24,121
 727 02a6 30E0      		ldi r19,0
 728 02a8 382B      		or r19,r24
 729 02aa 032E      		mov __tmp_reg__,r19
 730 02ac 000C      		lsl r0
 731 02ae 440B      		sbc r20,r20
 732 02b0 550B      		sbc r21,r21
 733 02b2 64EB      		ldi r22,lo8(-76)
 734 02b4 7BE2      		ldi r23,lo8(43)
 735 02b6 81E1      		ldi r24,lo8(17)
 736 02b8 90E0      		ldi r25,0
 737 02ba 0E94 0000 		call __divmodsi4
 306:main.c        **** }
 738               		.loc 4 306 0
 739 02be C901      		movw r24,r18
 740 02c0 0895      		ret
 741               		.cfi_endproc
 742               	.LFE29:
 744               	.global	GetTemp
 746               	GetTemp:
 747               	.LFB30:
 307:main.c        **** 
 308:main.c        **** 
 309:main.c        **** uint16_t GetTemp(void)
 310:main.c        **** {
 748               		.loc 4 310 0
 749               		.cfi_startproc
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 311:main.c        **** 
 312:main.c        **** 								 // Set internal V reference, temperature reading
 313:main.c        **** 	ADMUX = _BV(REFS1) | _BV(REFS0) | 7;
 754               		.loc 4 313 0
 755 02c2 87EC      		ldi r24,lo8(-57)
 756 02c4 8093 7C00 		sts 124,r24
 314:main.c        **** 	ADCSRB = 0x20;				 // ref  24.6
 757               		.loc 4 314 0
 758 02c8 80E2      		ldi r24,lo8(32)
 759 02ca 8093 7B00 		sts 123,r24
 315:main.c        **** 								 // Clear auto trigger and interrupt enable
 316:main.c        **** 	ADCSRA &= ~(_BV(ADATE) | _BV(ADIE));
 760               		.loc 4 316 0
 761 02ce 8091 7A00 		lds r24,122
 762 02d2 877D      		andi r24,lo8(-41)
 763 02d4 8093 7A00 		sts 122,r24
 317:main.c        **** 	ADCSRA |= _BV(ADEN);		 // enable the ADC
 764               		.loc 4 317 0
 765 02d8 8091 7A00 		lds r24,122
 766 02dc 8068      		ori r24,lo8(-128)
 767 02de 8093 7A00 		sts 122,r24
 768               	.LVL69:
 769               	.LBB93:
 770               	.LBB94:
 187:/usr/lib/avr/include/util/delay.h **** 
 771               		.loc 3 187 0
 772 02e2 8FE3      		ldi r24,lo8(7999)
 773 02e4 9FE1      		ldi r25,hi8(7999)
 774 02e6 0197      	1:	sbiw r24,1
 775 02e8 01F4      		brne 1b
 776 02ea 00C0      		rjmp .
 777 02ec 0000      		nop
 778               	.LVL70:
 779               	.LBE94:
 780               	.LBE93:
 318:main.c        **** 	_delay_ms(2);				 // delay for voltages to become stable.
 319:main.c        **** 
 320:main.c        **** 	ADCSRA |= _BV(ADSC);		 // measuring
 781               		.loc 4 320 0
 782 02ee 8091 7A00 		lds r24,122
 783 02f2 8064      		ori r24,lo8(64)
 784 02f4 8093 7A00 		sts 122,r24
 785               	.L42:
 321:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 786               		.loc 4 321 0 discriminator 1
 787 02f8 8091 7A00 		lds r24,122
 788 02fc 86FD      		sbrc r24,6
 789 02fe 00C0      		rjmp .L42
 322:main.c        **** 
 323:main.c        **** 	ADCSRA |= _BV(ADSC);
 790               		.loc 4 323 0
 791 0300 8091 7A00 		lds r24,122
 792 0304 8064      		ori r24,lo8(64)
 793 0306 8093 7A00 		sts 122,r24
 794               	.L43:
 324:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 795               		.loc 4 324 0 discriminator 1
 796 030a 8091 7A00 		lds r24,122
 797 030e 86FD      		sbrc r24,6
 798 0310 00C0      		rjmp .L43
 325:main.c        **** 
 326:main.c        **** 	return (ADCL | (ADCH << 8));
 799               		.loc 4 326 0
 800 0312 8091 7800 		lds r24,120
 801 0316 2091 7900 		lds r18,121
 802 031a 90E0      		ldi r25,0
 327:main.c        **** }
 803               		.loc 4 327 0
 804 031c 922B      		or r25,r18
 805 031e 0895      		ret
 806               		.cfi_endproc
 807               	.LFE30:
 809               	.global	freeRam
 811               	freeRam:
 812               	.LFB31:
 328:main.c        **** 
 329:main.c        **** 
 330:main.c        **** uint16_t freeRam(void)
 331:main.c        **** {
 813               		.loc 4 331 0
 814               		.cfi_startproc
 815 0320 CF93      		push r28
 816               	.LCFI2:
 817               		.cfi_def_cfa_offset 3
 818               		.cfi_offset 28, -2
 819 0322 DF93      		push r29
 820               	.LCFI3:
 821               		.cfi_def_cfa_offset 4
 822               		.cfi_offset 29, -3
 823 0324 00D0      		rcall .
 824               	.LCFI4:
 825               		.cfi_def_cfa_offset 6
 826 0326 CDB7      		in r28,__SP_L__
 827 0328 DEB7      		in r29,__SP_H__
 828               	.LCFI5:
 829               		.cfi_def_cfa_register 28
 830               	/* prologue: function */
 831               	/* frame size = 2 */
 832               	/* stack size = 4 */
 833               	.L__stack_usage = 4
 332:main.c        **** 	extern char __heap_start, * __brkval;
 333:main.c        **** 	int v;
 334:main.c        **** 	return (uint16_t) & v - (__brkval == 0 ? (int) & __heap_start : (int) __brkval);
 834               		.loc 4 334 0
 835 032a 2091 0000 		lds r18,__brkval
 836 032e 3091 0000 		lds r19,__brkval+1
 837 0332 2115      		cp r18,__zero_reg__
 838 0334 3105      		cpc r19,__zero_reg__
 839 0336 01F4      		brne .L47
 840 0338 20E0      		ldi r18,lo8(__heap_start)
 841 033a 30E0      		ldi r19,hi8(__heap_start)
 842               	.L47:
 335:main.c        **** }
 843               		.loc 4 335 0 discriminator 4
 844 033c CE01      		movw r24,r28
 845 033e 0196      		adiw r24,1
 846 0340 821B      		sub r24,r18
 847 0342 930B      		sbc r25,r19
 848               	/* epilogue start */
 849 0344 0F90      		pop __tmp_reg__
 850 0346 0F90      		pop __tmp_reg__
 851 0348 DF91      		pop r29
 852 034a CF91      		pop r28
 853 034c 0895      		ret
 854               		.cfi_endproc
 855               	.LFE31:
 857               	.global	I2C_init
 859               	I2C_init:
 860               	.LFB32:
 336:main.c        **** 
 337:main.c        **** 
 338:main.c        **** void I2C_init(uint8_t address)	 // setup ATmega as I2C slave
 339:main.c        **** {
 861               		.loc 4 339 0
 862               		.cfi_startproc
 863               	.LVL71:
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866               	/* stack size = 0 */
 867               	.L__stack_usage = 0
 340:main.c        **** 	cli();
 868               		.loc 4 340 0
 869               	/* #APP */
 870               	 ;  340 "main.c" 1
 871 034e F894      		cli
 872               	 ;  0 "" 2
 341:main.c        **** 
 342:main.c        **** 	TWAR = (address << 1);
 873               		.loc 4 342 0
 874               	/* #NOAPP */
 875 0350 880F      		lsl r24
 876               	.LVL72:
 877 0352 8093 BA00 		sts 186,r24
 343:main.c        **** 	TWCR = (1 << TWEN) |		 // TWI Interface enabled.
 878               		.loc 4 343 0
 879 0356 85EC      		ldi r24,lo8(-59)
 880 0358 8093 BC00 		sts 188,r24
 344:main.c        **** 		(1 << TWIE) | (1 << TWINT) |// Enable TWI Interupt and clear the flag.
 345:main.c        **** 								 // Prepare to ACK next time the Slave is addressed.
 346:main.c        **** 		(1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) |
 347:main.c        **** 		(0 << TWWC);
 348:main.c        **** 
 349:main.c        **** 	buffer_address = 0xFF;
 881               		.loc 4 349 0
 882 035c 8FEF      		ldi r24,lo8(-1)
 883 035e 8093 0000 		sts buffer_address,r24
 884 0362 0895      		ret
 885               		.cfi_endproc
 886               	.LFE32:
 888               	.global	__vector_9
 890               	__vector_9:
 891               	.LFB33:
 350:main.c        **** 
 351:main.c        **** }
 352:main.c        **** 
 353:main.c        **** 
 354:main.c        **** ISR(PCINT0_vect)
 355:main.c        **** {
 892               		.loc 4 355 0
 893               		.cfi_startproc
 894 0364 1F92      		push r1
 895               	.LCFI6:
 896               		.cfi_def_cfa_offset 3
 897               		.cfi_offset 1, -2
 898 0366 0F92      		push r0
 899               	.LCFI7:
 900               		.cfi_def_cfa_offset 4
 901               		.cfi_offset 0, -3
 902 0368 0FB6      		in r0,__SREG__
 903 036a 0F92      		push r0
 904 036c 1124      		clr __zero_reg__
 905 036e 8F93      		push r24
 906               	.LCFI8:
 907               		.cfi_def_cfa_offset 5
 908               		.cfi_offset 24, -4
 909 0370 9F93      		push r25
 910               	.LCFI9:
 911               		.cfi_def_cfa_offset 6
 912               		.cfi_offset 25, -5
 913               	/* prologue: Signal */
 914               	/* frame size = 0 */
 915               	/* stack size = 5 */
 916               	.L__stack_usage = 5
 356:main.c        **** 	sei();
 917               		.loc 4 356 0
 918               	/* #APP */
 919               	 ;  356 "main.c" 1
 920 0372 7894      		sei
 921               	 ;  0 "" 2
 357:main.c        **** 	if (bit_is_clear(PINB, PB4)) fanspin++;
 922               		.loc 4 357 0
 923               	/* #NOAPP */
 924 0374 1C99      		sbic 0x3,4
 925 0376 00C0      		rjmp .L50
 926               		.loc 4 357 0 is_stmt 0 discriminator 1
 927 0378 8091 0000 		lds r24,fanspin
 928 037c 9091 0000 		lds r25,fanspin+1
 929 0380 0196      		adiw r24,1
 930 0382 9093 0000 		sts fanspin+1,r25
 931 0386 8093 0000 		sts fanspin,r24
 932               	.L50:
 933               	/* epilogue start */
 358:main.c        **** }								 // counting VENT_RPM
 934               		.loc 4 358 0 is_stmt 1
 935 038a 9F91      		pop r25
 936 038c 8F91      		pop r24
 937 038e 0F90      		pop r0
 938 0390 0FBE      		out __SREG__,r0
 939 0392 0F90      		pop r0
 940 0394 1F90      		pop r1
 941 0396 1895      		reti
 942               		.cfi_endproc
 943               	.LFE33:
 945               	.global	__vector_23
 947               	__vector_23:
 948               	.LFB34:
 359:main.c        **** 
 360:main.c        **** 
 361:main.c        **** ISR(TIMER0_OVF_vect)
 362:main.c        **** {
 949               		.loc 4 362 0
 950               		.cfi_startproc
 951 0398 1F92      		push r1
 952               	.LCFI10:
 953               		.cfi_def_cfa_offset 3
 954               		.cfi_offset 1, -2
 955 039a 0F92      		push r0
 956               	.LCFI11:
 957               		.cfi_def_cfa_offset 4
 958               		.cfi_offset 0, -3
 959 039c 0FB6      		in r0,__SREG__
 960 039e 0F92      		push r0
 961 03a0 1124      		clr __zero_reg__
 962 03a2 8F93      		push r24
 963               	.LCFI12:
 964               		.cfi_def_cfa_offset 5
 965               		.cfi_offset 24, -4
 966 03a4 9F93      		push r25
 967               	.LCFI13:
 968               		.cfi_def_cfa_offset 6
 969               		.cfi_offset 25, -5
 970               	/* prologue: Signal */
 971               	/* frame size = 0 */
 972               	/* stack size = 5 */
 973               	.L__stack_usage = 5
 363:main.c        **** 	isrtimer++;
 974               		.loc 4 363 0
 975 03a6 8091 0000 		lds r24,isrtimer
 976 03aa 9091 0000 		lds r25,isrtimer+1
 977 03ae 0196      		adiw r24,1
 978 03b0 9093 0000 		sts isrtimer+1,r25
 979 03b4 8093 0000 		sts isrtimer,r24
 980               	/* epilogue start */
 364:main.c        **** }								 // reuse timer0 for counting VENT_RPM
 981               		.loc 4 364 0
 982 03b8 9F91      		pop r25
 983 03ba 8F91      		pop r24
 984 03bc 0F90      		pop r0
 985 03be 0FBE      		out __SREG__,r0
 986 03c0 0F90      		pop r0
 987 03c2 1F90      		pop r1
 988 03c4 1895      		reti
 989               		.cfi_endproc
 990               	.LFE34:
 992               	.global	__vector_36
 994               	__vector_36:
 995               	.LFB35:
 365:main.c        **** 
 366:main.c        **** 
 367:main.c        **** ISR(TWI_vect)
 368:main.c        **** {
 996               		.loc 4 368 0
 997               		.cfi_startproc
 998 03c6 1F92      		push r1
 999               	.LCFI14:
 1000               		.cfi_def_cfa_offset 3
 1001               		.cfi_offset 1, -2
 1002 03c8 0F92      		push r0
 1003               	.LCFI15:
 1004               		.cfi_def_cfa_offset 4
 1005               		.cfi_offset 0, -3
 1006 03ca 0FB6      		in r0,__SREG__
 1007 03cc 0F92      		push r0
 1008 03ce 1124      		clr __zero_reg__
 1009 03d0 2F93      		push r18
 1010               	.LCFI16:
 1011               		.cfi_def_cfa_offset 5
 1012               		.cfi_offset 18, -4
 1013 03d2 3F93      		push r19
 1014               	.LCFI17:
 1015               		.cfi_def_cfa_offset 6
 1016               		.cfi_offset 19, -5
 1017 03d4 4F93      		push r20
 1018               	.LCFI18:
 1019               		.cfi_def_cfa_offset 7
 1020               		.cfi_offset 20, -6
 1021 03d6 5F93      		push r21
 1022               	.LCFI19:
 1023               		.cfi_def_cfa_offset 8
 1024               		.cfi_offset 21, -7
 1025 03d8 6F93      		push r22
 1026               	.LCFI20:
 1027               		.cfi_def_cfa_offset 9
 1028               		.cfi_offset 22, -8
 1029 03da 7F93      		push r23
 1030               	.LCFI21:
 1031               		.cfi_def_cfa_offset 10
 1032               		.cfi_offset 23, -9
 1033 03dc 8F93      		push r24
 1034               	.LCFI22:
 1035               		.cfi_def_cfa_offset 11
 1036               		.cfi_offset 24, -10
 1037 03de 9F93      		push r25
 1038               	.LCFI23:
 1039               		.cfi_def_cfa_offset 12
 1040               		.cfi_offset 25, -11
 1041 03e0 AF93      		push r26
 1042               	.LCFI24:
 1043               		.cfi_def_cfa_offset 13
 1044               		.cfi_offset 26, -12
 1045 03e2 BF93      		push r27
 1046               	.LCFI25:
 1047               		.cfi_def_cfa_offset 14
 1048               		.cfi_offset 27, -13
 1049 03e4 CF93      		push r28
 1050               	.LCFI26:
 1051               		.cfi_def_cfa_offset 15
 1052               		.cfi_offset 28, -14
 1053 03e6 EF93      		push r30
 1054               	.LCFI27:
 1055               		.cfi_def_cfa_offset 16
 1056               		.cfi_offset 30, -15
 1057 03e8 FF93      		push r31
 1058               	.LCFI28:
 1059               		.cfi_def_cfa_offset 17
 1060               		.cfi_offset 31, -16
 1061               	/* prologue: Signal */
 1062               	/* frame size = 0 */
 1063               	/* stack size = 16 */
 1064               	.L__stack_usage = 16
 369:main.c        **** 
 370:main.c        **** 	switch (TW_STATUS)
 1065               		.loc 4 370 0
 1066 03ea 8091 B900 		lds r24,185
 1067 03ee 887F      		andi r24,lo8(-8)
 1068 03f0 8038      		cpi r24,lo8(-128)
 1069 03f2 01F0      		breq .L55
 1070 03f4 00F4      		brsh .L56
 1071 03f6 8823      		tst r24
 1072 03f8 01F4      		brne .+2
 1073 03fa 00C0      		rjmp .L57
 1074 03fc 8036      		cpi r24,lo8(96)
 1075 03fe 01F0      		breq .+2
 1076 0400 00C0      		rjmp .L54
 371:main.c        **** 	{
 372:main.c        **** 
 373:main.c        **** 		case TW_SR_SLA_ACK:
 374:main.c        **** 
 375:main.c        **** 			TWCR = (1 << TWIE) | (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
 1077               		.loc 4 375 0
 1078 0402 85EC      		ldi r24,lo8(-59)
 1079 0404 8093 BC00 		sts 188,r24
 376:main.c        **** 								 // set buffer pos undefined
 377:main.c        **** 			buffer_address = 0xFF;
 1080               		.loc 4 377 0
 1081 0408 8FEF      		ldi r24,lo8(-1)
 1082 040a 8093 0000 		sts buffer_address,r24
 378:main.c        **** 			break;
 1083               		.loc 4 378 0
 1084 040e 00C0      		rjmp .L53
 1085               	.L56:
 370:main.c        **** 	{
 1086               		.loc 4 370 0
 1087 0410 883A      		cpi r24,lo8(-88)
 1088 0412 01F4      		brne .+2
 1089 0414 00C0      		rjmp .L59
 1090 0416 883B      		cpi r24,lo8(-72)
 1091 0418 01F4      		brne .+2
 1092 041a 00C0      		rjmp .L59
 1093 041c 00C0      		rjmp .L54
 1094               	.L55:
 379:main.c        **** 
 380:main.c        **** 		case TW_SR_DATA_ACK:	 // received data from master
 381:main.c        **** 
 382:main.c        **** 			if (buffer_address == 0xFF)
 1095               		.loc 4 382 0
 1096 041e 8091 0000 		lds r24,buffer_address
 1097 0422 8F3F      		cpi r24,lo8(-1)
 1098 0424 01F0      		breq .+2
 1099 0426 00C0      		rjmp .L61
 383:main.c        **** 			{
 384:main.c        **** 
 385:main.c        **** 				commandbyte = TWDR;
 1100               		.loc 4 385 0
 1101 0428 6091 BB00 		lds r22,187
 1102 042c 6093 0000 		sts commandbyte,r22
 386:main.c        **** 				if (crc_active)   crc = _crc8_ccitt_update(0, commandbyte);
 1103               		.loc 4 386 0
 1104 0430 8091 0000 		lds r24,crc_active
 1105 0434 8823      		tst r24
 1106 0436 01F0      		breq .L62
 1107               		.loc 4 386 0 is_stmt 0 discriminator 1
 1108 0438 80E0      		ldi r24,0
 1109 043a 0E94 0000 		call _crc8_ccitt_update
 1110               	.LVL73:
 1111 043e 8093 0000 		sts crc,r24
 1112               	.L62:
 387:main.c        **** 				buffer_address = 0;
 1113               		.loc 4 387 0 is_stmt 1
 1114 0442 1092 0000 		sts buffer_address,__zero_reg__
 388:main.c        **** 				i2cerror = 0;
 1115               		.loc 4 388 0
 1116 0446 1092 0000 		sts i2cerror,__zero_reg__
 389:main.c        **** 
 390:main.c        **** 				switch (commandbyte)
 1117               		.loc 4 390 0
 1118 044a E091 0000 		lds r30,commandbyte
 1119 044e 8E2F      		mov r24,r30
 1120 0450 90E0      		ldi r25,0
 1121 0452 8831      		cpi r24,24
 1122 0454 9105      		cpc r25,__zero_reg__
 1123 0456 00F0      		brlo .+2
 1124 0458 00C0      		rjmp .L63
 1125 045a FC01      		movw r30,r24
 1126 045c E050      		subi r30,lo8(-(gs(.L65)))
 1127 045e F040      		sbci r31,hi8(-(gs(.L65)))
 1128 0460 0C94 0000 		jmp __tablejump2__
 1129               		.section	.progmem.gcc_sw_table,"a",@progbits
 1130               		.p2align	1
 1131               	.L65:
 1132 0000 0000      		.word gs(.L64)
 1133 0002 0000      		.word gs(.L66)
 1134 0004 0000      		.word gs(.L67)
 1135 0006 0000      		.word gs(.L68)
 1136 0008 0000      		.word gs(.L69)
 1137 000a 0000      		.word gs(.L70)
 1138 000c 0000      		.word gs(.L71)
 1139 000e 0000      		.word gs(.L63)
 1140 0010 0000      		.word gs(.L72)
 1141 0012 0000      		.word gs(.L73)
 1142 0014 0000      		.word gs(.L74)
 1143 0016 0000      		.word gs(.L75)
 1144 0018 0000      		.word gs(.L63)
 1145 001a 0000      		.word gs(.L63)
 1146 001c 0000      		.word gs(.L63)
 1147 001e 0000      		.word gs(.L63)
 1148 0020 0000      		.word gs(.L63)
 1149 0022 0000      		.word gs(.L63)
 1150 0024 0000      		.word gs(.L63)
 1151 0026 0000      		.word gs(.L63)
 1152 0028 0000      		.word gs(.L63)
 1153 002a 0000      		.word gs(.L63)
 1154 002c 0000      		.word gs(.L63)
 1155 002e 0000      		.word gs(.L76)
 1156               		.text
 1157               	.L64:
 391:main.c        **** 				{
 392:main.c        **** 
 393:main.c        **** 					case 0x00: i2cbuffer = a0; break;
 1158               		.loc 4 393 0
 1159 0464 8091 0000 		lds r24,a0
 1160 0468 9091 0000 		lds r25,a0+1
 1161 046c 00C0      		rjmp .L270
 1162               	.L66:
 394:main.c        **** 					case 0x01: i2cbuffer = a1; break;
 1163               		.loc 4 394 0
 1164 046e 8091 0000 		lds r24,a1
 1165 0472 9091 0000 		lds r25,a1+1
 1166 0476 00C0      		rjmp .L270
 1167               	.L67:
 395:main.c        **** 					case 0x02: i2cbuffer = a2; break;
 1168               		.loc 4 395 0
 1169 0478 8091 0000 		lds r24,a2
 1170 047c 9091 0000 		lds r25,a2+1
 1171 0480 00C0      		rjmp .L270
 1172               	.L68:
 396:main.c        **** 					case 0x03: i2cbuffer = a3; break;
 1173               		.loc 4 396 0
 1174 0482 8091 0000 		lds r24,a3
 1175 0486 9091 0000 		lds r25,a3+1
 1176 048a 00C0      		rjmp .L270
 1177               	.L69:
 397:main.c        **** 					case 0x04: i2cbuffer = a4; break;
 1178               		.loc 4 397 0
 1179 048c 8091 0000 		lds r24,a4
 1180 0490 9091 0000 		lds r25,a4+1
 1181 0494 00C0      		rjmp .L270
 1182               	.L70:
 398:main.c        **** 					case 0x05: i2cbuffer = a5; break;
 1183               		.loc 4 398 0
 1184 0496 8091 0000 		lds r24,a5
 1185 049a 9091 0000 		lds r25,a5+1
 1186 049e 00C0      		rjmp .L270
 1187               	.L71:
 399:main.c        **** 					case 0x06: i2cbuffer = a7; break;
 1188               		.loc 4 399 0
 1189 04a0 8091 0000 		lds r24,a7
 1190 04a4 9091 0000 		lds r25,a7+1
 1191 04a8 00C0      		rjmp .L270
 1192               	.L72:
 400:main.c        **** 					case 0x08: i2cbuffer = rpm;break;
 1193               		.loc 4 400 0
 1194 04aa 8091 0000 		lds r24,rpm
 1195 04ae 9091 0000 		lds r25,rpm+1
 1196 04b2 00C0      		rjmp .L270
 1197               	.L73:
 401:main.c        **** 					case 0x09: i2cbuffer = vcc; break;
 1198               		.loc 4 401 0
 1199 04b4 8091 0000 		lds r24,vcc
 1200 04b8 9091 0000 		lds r25,vcc+1
 1201 04bc 00C0      		rjmp .L270
 1202               	.L74:
 402:main.c        **** 					case 0x0A: i2cbuffer = temp;break;
 1203               		.loc 4 402 0
 1204 04be 8091 0000 		lds r24,temp
 1205 04c2 9091 0000 		lds r25,temp+1
 1206 04c6 00C0      		rjmp .L270
 1207               	.L75:
 403:main.c        **** 					case 0x0B: i2cbuffer = freeRam(); break;
 1208               		.loc 4 403 0
 1209 04c8 0E94 0000 		call freeRam
 1210               	.LVL74:
 1211 04cc 00C0      		rjmp .L270
 1212               	.L76:
 404:main.c        **** 					case 0x17: i2cbuffer = a7avg; break;
 1213               		.loc 4 404 0
 1214 04ce 8091 0000 		lds r24,a7avg
 1215 04d2 9091 0000 		lds r25,a7avg+1
 1216               	.L270:
 1217 04d6 9093 0000 		sts i2cbuffer+1,r25
 1218 04da 8093 0000 		sts i2cbuffer,r24
 1219 04de 00C0      		rjmp .L63
 1220               	.L61:
 405:main.c        **** 
 406:main.c        **** 				}
 407:main.c        **** 			}
 408:main.c        **** 			else
 409:main.c        **** 			{
 410:main.c        **** 
 411:main.c        **** 				if (buffer_address == 0)
 1221               		.loc 4 411 0
 1222 04e0 8111      		cpse r24,__zero_reg__
 1223 04e2 00C0      		rjmp .L77
 412:main.c        **** 				{
 413:main.c        **** 					twdrbuffer = TWDR;
 1224               		.loc 4 413 0
 1225 04e4 8091 BB00 		lds r24,187
 1226 04e8 8093 0000 		sts twdrbuffer,r24
 414:main.c        **** 					if (commandbyte == 0xFE) crc_active = twdrbuffer;
 1227               		.loc 4 414 0
 1228 04ec 9091 0000 		lds r25,commandbyte
 1229 04f0 9E3F      		cpi r25,lo8(-2)
 1230 04f2 01F4      		brne .L78
 1231               		.loc 4 414 0 is_stmt 0 discriminator 1
 1232 04f4 8093 0000 		sts crc_active,r24
 1233               	.L78:
 415:main.c        **** 					crc = _crc8_ccitt_update(crc,TWDR);
 1234               		.loc 4 415 0 is_stmt 1
 1235 04f8 6091 BB00 		lds r22,187
 1236 04fc 8091 0000 		lds r24,crc
 1237 0500 0E94 0000 		call _crc8_ccitt_update
 1238               	.LVL75:
 1239 0504 8093 0000 		sts crc,r24
 1240               	.L77:
 416:main.c        **** 
 417:main.c        **** 				}
 418:main.c        **** 
 419:main.c        **** 				if ((crc_active && (buffer_address == 1) && (TWDR == crc)) ||   (!crc_active && buffer_address 
 1241               		.loc 4 419 0
 1242 0508 9091 0000 		lds r25,crc_active
 1243 050c 8091 0000 		lds r24,buffer_address
 1244 0510 9923      		tst r25
 1245 0512 01F0      		breq .L79
 1246               		.loc 4 419 0 is_stmt 0 discriminator 1
 1247 0514 8130      		cpi r24,lo8(1)
 1248 0516 01F0      		breq .+2
 1249 0518 00C0      		rjmp .L80
 1250               		.loc 4 419 0 discriminator 3
 1251 051a 9091 BB00 		lds r25,187
 1252 051e 8091 0000 		lds r24,crc
 1253 0522 9813      		cpse r25,r24
 1254 0524 00C0      		rjmp .L80
 1255 0526 00C0      		rjmp .L81
 1256               	.L79:
 1257               		.loc 4 419 0 discriminator 6
 1258 0528 8111      		cpse r24,__zero_reg__
 1259 052a 00C0      		rjmp .L80
 1260               	.L81:
 420:main.c        **** 				{
 421:main.c        **** 
 422:main.c        **** 					if (commandbyte == 0x87 ) {newbllevel = twdrbuffer;}
 1261               		.loc 4 422 0 is_stmt 1
 1262 052c 8091 0000 		lds r24,commandbyte
 1263 0530 8738      		cpi r24,lo8(-121)
 1264 0532 01F4      		brne .L82
 1265               		.loc 4 422 0 is_stmt 0 discriminator 1
 1266 0534 8091 0000 		lds r24,twdrbuffer
 1267 0538 8093 0000 		sts newbllevel,r24
 1268 053c 00C0      		rjmp .L83
 1269               	.L82:
 423:main.c        **** 								 // switch display controller on off
 424:main.c        **** 					else if (commandbyte == 0x98 )
 1270               		.loc 4 424 0 is_stmt 1
 1271 053e 8839      		cpi r24,lo8(-104)
 1272 0540 01F4      		brne .L84
 425:main.c        **** 					{
 426:main.c        **** 						displaychange = 1; if (twdrbuffer == 0xFF)
 1273               		.loc 4 426 0
 1274 0542 81E0      		ldi r24,lo8(1)
 1275 0544 8093 0000 		sts displaychange,r24
 1276 0548 C091 0000 		lds r28,twdrbuffer
 427:main.c        **** 						{
 428:main.c        **** 							write_lcd(0x029,9);write_lcd(0x013,9); display = 0xFF;
 1277               		.loc 4 428 0
 1278 054c 69E0      		ldi r22,lo8(9)
 426:main.c        **** 						{
 1279               		.loc 4 426 0
 1280 054e CF3F      		cpi r28,lo8(-1)
 1281 0550 01F4      		brne .L85
 1282               		.loc 4 428 0
 1283 0552 89E2      		ldi r24,lo8(41)
 1284 0554 90E0      		ldi r25,0
 1285 0556 0E94 0000 		call write_lcd
 1286               	.LVL76:
 1287 055a 69E0      		ldi r22,lo8(9)
 1288 055c 83E1      		ldi r24,lo8(19)
 1289 055e 90E0      		ldi r25,0
 1290 0560 0E94 0000 		call write_lcd
 1291               	.LVL77:
 1292 0564 C093 0000 		sts display,r28
 1293 0568 00C0      		rjmp .L83
 1294               	.L85:
 429:main.c        **** 						}
 430:main.c        **** 						else
 431:main.c        **** 						{
 432:main.c        **** 							write_lcd(0x028,9); display = 0x00;
 1295               		.loc 4 432 0
 1296 056a 88E2      		ldi r24,lo8(40)
 1297 056c 90E0      		ldi r25,0
 1298 056e 0E94 0000 		call write_lcd
 1299               	.LVL78:
 1300 0572 1092 0000 		sts display,__zero_reg__
 1301 0576 00C0      		rjmp .L83
 1302               	.L84:
 433:main.c        **** 						}
 434:main.c        **** 					}
 435:main.c        **** 								 // display white / black
 436:main.c        **** 					else if (commandbyte == 0x99 )
 1303               		.loc 4 436 0
 1304 0578 8939      		cpi r24,lo8(-103)
 1305 057a 01F4      		brne .L86
 437:main.c        **** 					{
 438:main.c        **** 						displaychange = 1; if (twdrbuffer == 0xFF)
 1306               		.loc 4 438 0
 1307 057c 81E0      		ldi r24,lo8(1)
 1308 057e 8093 0000 		sts displaychange,r24
 1309 0582 8091 0000 		lds r24,twdrbuffer
 439:main.c        **** 						{
 440:main.c        **** 							write_lcd(0x023,9);
 1310               		.loc 4 440 0
 1311 0586 69E0      		ldi r22,lo8(9)
 438:main.c        **** 						{
 1312               		.loc 4 438 0
 1313 0588 8F3F      		cpi r24,lo8(-1)
 1314 058a 01F4      		brne .L87
 1315               		.loc 4 440 0
 1316 058c 83E2      		ldi r24,lo8(35)
 1317 058e 90E0      		ldi r25,0
 1318 0590 00C0      		rjmp .L268
 1319               	.L87:
 441:main.c        **** 						}
 442:main.c        **** 						else if (twdrbuffer == 0x00)
 1320               		.loc 4 442 0
 1321 0592 8111      		cpse r24,__zero_reg__
 1322 0594 00C0      		rjmp .L88
 443:main.c        **** 						{
 444:main.c        **** 							write_lcd(0x022,9);
 1323               		.loc 4 444 0
 1324 0596 82E2      		ldi r24,lo8(34)
 1325 0598 90E0      		ldi r25,0
 1326 059a 00C0      		rjmp .L268
 1327               	.L88:
 445:main.c        **** 						}
 446:main.c        **** 						else
 447:main.c        **** 						{
 448:main.c        **** 							write_lcd(0x013,9);
 1328               		.loc 4 448 0
 1329 059c 83E1      		ldi r24,lo8(19)
 1330 059e 90E0      		ldi r25,0
 1331               	.L268:
 1332 05a0 0E94 0000 		call write_lcd
 1333               	.LVL79:
 1334 05a4 00C0      		rjmp .L83
 1335               	.L86:
 449:main.c        **** 						}
 450:main.c        **** 					}
 451:main.c        **** 								 //set Relais 1
 452:main.c        **** 					else if (commandbyte == 0x8D )
 1336               		.loc 4 452 0
 1337 05a6 8D38      		cpi r24,lo8(-115)
 1338 05a8 01F4      		brne .L89
 453:main.c        **** 					{
 454:main.c        **** 						if (twdrbuffer == 0xFF)
 1339               		.loc 4 454 0
 1340 05aa 8091 0000 		lds r24,twdrbuffer
 1341 05ae 8F3F      		cpi r24,lo8(-1)
 1342 05b0 01F4      		brne .L90
 455:main.c        **** 						{
 456:main.c        **** 							PORTC |= _BV(PC6);
 1343               		.loc 4 456 0
 1344 05b2 469A      		sbi 0x8,6
 1345 05b4 00C0      		rjmp .L83
 1346               	.L90:
 457:main.c        **** 						}
 458:main.c        **** 						else
 459:main.c        **** 						{
 460:main.c        **** 							PORTC &= ~_BV(PC6);
 1347               		.loc 4 460 0
 1348 05b6 4698      		cbi 0x8,6
 1349 05b8 00C0      		rjmp .L83
 1350               	.L89:
 461:main.c        **** 						}
 462:main.c        **** 					}
 463:main.c        **** 								 //set Relais 2
 464:main.c        **** 					else if (commandbyte == 0x8E )
 1351               		.loc 4 464 0
 1352 05ba 8E38      		cpi r24,lo8(-114)
 1353 05bc 01F4      		brne .L91
 465:main.c        **** 					{
 466:main.c        **** 						if (twdrbuffer == 0xFF)
 1354               		.loc 4 466 0
 1355 05be 8091 0000 		lds r24,twdrbuffer
 1356 05c2 8F3F      		cpi r24,lo8(-1)
 1357 05c4 01F4      		brne .L92
 467:main.c        **** 						{
 468:main.c        **** 							PORTD |= _BV(PD7);
 1358               		.loc 4 468 0
 1359 05c6 5F9A      		sbi 0xb,7
 1360 05c8 00C0      		rjmp .L83
 1361               	.L92:
 469:main.c        **** 						}
 470:main.c        **** 						else
 471:main.c        **** 						{
 472:main.c        **** 							PORTD &= ~_BV(PD7);
 1362               		.loc 4 472 0
 1363 05ca 5F98      		cbi 0xb,7
 1364 05cc 00C0      		rjmp .L83
 1365               	.L91:
 473:main.c        **** 						}
 474:main.c        **** 					}
 475:main.c        **** 								 //set Relais 3
 476:main.c        **** 					else if (commandbyte == 0x8F )
 1366               		.loc 4 476 0
 1367 05ce 8F38      		cpi r24,lo8(-113)
 1368 05d0 01F4      		brne .L93
 477:main.c        **** 					{
 478:main.c        **** 						if (twdrbuffer == 0xFF)
 1369               		.loc 4 478 0
 1370 05d2 8091 0000 		lds r24,twdrbuffer
 1371 05d6 8F3F      		cpi r24,lo8(-1)
 1372 05d8 01F4      		brne .L94
 479:main.c        **** 						{
 480:main.c        **** 							PORTB |= _BV(PB6);
 1373               		.loc 4 480 0
 1374 05da 2E9A      		sbi 0x5,6
 1375 05dc 00C0      		rjmp .L83
 1376               	.L94:
 481:main.c        **** 						}
 482:main.c        **** 						else
 483:main.c        **** 						{
 484:main.c        **** 							PORTB &= ~_BV(PB6);
 1377               		.loc 4 484 0
 1378 05de 2E98      		cbi 0x5,6
 1379 05e0 00C0      		rjmp .L83
 1380               	.L93:
 485:main.c        **** 						}
 486:main.c        **** 					}
 487:main.c        **** 								 //set D13
 488:main.c        **** 					else if (commandbyte == 0x90 )
 1381               		.loc 4 488 0
 1382 05e2 8039      		cpi r24,lo8(-112)
 1383 05e4 01F4      		brne .L95
 489:main.c        **** 					{
 490:main.c        **** 						if (twdrbuffer == 0xFF)
 1384               		.loc 4 490 0
 1385 05e6 8091 0000 		lds r24,twdrbuffer
 1386 05ea 8F3F      		cpi r24,lo8(-1)
 1387 05ec 01F4      		brne .L96
 491:main.c        **** 						{
 492:main.c        **** 							PORTC |= _BV(PC7);
 1388               		.loc 4 492 0
 1389 05ee 479A      		sbi 0x8,7
 1390 05f0 00C0      		rjmp .L83
 1391               	.L96:
 493:main.c        **** 						}
 494:main.c        **** 						else
 495:main.c        **** 						{
 496:main.c        **** 							PORTC &= ~_BV(PC7);
 1392               		.loc 4 496 0
 1393 05f2 4798      		cbi 0x8,7
 1394 05f4 00C0      		rjmp .L83
 1395               	.L95:
 497:main.c        **** 						}
 498:main.c        **** 					}
 499:main.c        **** 								 //set HWB ->Gasheater      (D13 on prototypes)
 500:main.c        **** 					else if (commandbyte == 0x91 )
 1396               		.loc 4 500 0
 1397 05f6 8139      		cpi r24,lo8(-111)
 1398 05f8 01F4      		brne .L97
 501:main.c        **** 					{
 502:main.c        **** 						if (twdrbuffer == 0x00)
 1399               		.loc 4 502 0
 1400 05fa 8091 0000 		lds r24,twdrbuffer
 1401 05fe 8111      		cpse r24,__zero_reg__
 1402 0600 00C0      		rjmp .L98
 503:main.c        **** 						{
 504:main.c        **** 							PORTE |=  (1<<2);
 1403               		.loc 4 504 0
 1404 0602 729A      		sbi 0xe,2
 1405 0604 00C0      		rjmp .L83
 1406               	.L98:
 505:main.c        **** 						}
 506:main.c        **** 						else
 507:main.c        **** 						{
 508:main.c        **** 							PORTE &= ~(1<<2);
 1407               		.loc 4 508 0
 1408 0606 7298      		cbi 0xe,2
 1409 0608 00C0      		rjmp .L83
 1410               	.L97:
 509:main.c        **** 						}
 510:main.c        **** 					}
 511:main.c        **** 								 //set Buzzer
 512:main.c        **** 					else if (commandbyte == 0x92 )
 1411               		.loc 4 512 0
 1412 060a 8239      		cpi r24,lo8(-110)
 1413 060c 01F4      		brne .L99
 513:main.c        **** 					{
 514:main.c        **** 						if (twdrbuffer == 0xFF)
 1414               		.loc 4 514 0
 1415 060e 8091 0000 		lds r24,twdrbuffer
 1416 0612 8F3F      		cpi r24,lo8(-1)
 1417 0614 01F4      		brne .L100
 515:main.c        **** 						{
 516:main.c        **** 							PORTB |= _BV(PB5);
 1418               		.loc 4 516 0
 1419 0616 2D9A      		sbi 0x5,5
 1420 0618 00C0      		rjmp .L83
 1421               	.L100:
 517:main.c        **** 						}
 518:main.c        **** 						else if (twdrbuffer == 0x01)
 1422               		.loc 4 518 0
 1423 061a 8130      		cpi r24,lo8(1)
 1424 061c 01F4      		brne .L101
 519:main.c        **** 						{
 520:main.c        **** 							PORTB |= _BV(PB5); twdrbuffer = 0x02;
 1425               		.loc 4 520 0
 1426 061e 2D9A      		sbi 0x5,5
 1427 0620 82E0      		ldi r24,lo8(2)
 1428 0622 8093 0000 		sts twdrbuffer,r24
 1429 0626 00C0      		rjmp .L83
 1430               	.L101:
 521:main.c        **** 						}
 522:main.c        **** 						else
 523:main.c        **** 						{
 524:main.c        **** 							PORTB &= ~_BV(PB5);twdrbuffer = 0x00;
 1431               		.loc 4 524 0
 1432 0628 2D98      		cbi 0x5,5
 1433 062a 1092 0000 		sts twdrbuffer,__zero_reg__
 1434 062e 00C0      		rjmp .L83
 1435               	.L99:
 525:main.c        **** 						}
 526:main.c        **** 					}
 527:main.c        **** 								 //set Vent
 528:main.c        **** 					else if (commandbyte == 0x93 )
 1436               		.loc 4 528 0
 1437 0630 8339      		cpi r24,lo8(-109)
 1438 0632 01F4      		brne .L102
 529:main.c        **** 					{
 530:main.c        **** 						OCR0A = twdrbuffer;fanlevel = twdrbuffer;
 1439               		.loc 4 530 0
 1440 0634 8091 0000 		lds r24,twdrbuffer
 1441 0638 87BD      		out 0x27,r24
 1442 063a 8091 0000 		lds r24,twdrbuffer
 1443 063e 8093 0000 		sts fanlevel,r24
 1444 0642 00C0      		rjmp .L83
 1445               	.L102:
 531:main.c        **** 					}
 532:main.c        **** 								 //set r color
 533:main.c        **** 					else if (commandbyte == 0x94 )
 1446               		.loc 4 533 0
 1447 0644 8439      		cpi r24,lo8(-108)
 1448 0646 01F4      		brne .L103
 534:main.c        **** 					{
 535:main.c        **** 						led[led_position].r = twdrbuffer;changeled = 1;
 1449               		.loc 4 535 0
 1450 0648 8091 0000 		lds r24,led_position
 1451 064c 90E0      		ldi r25,0
 1452 064e FC01      		movw r30,r24
 1453 0650 EE0F      		lsl r30
 1454 0652 FF1F      		rol r31
 1455 0654 8E0F      		add r24,r30
 1456 0656 9F1F      		adc r25,r31
 1457 0658 FC01      		movw r30,r24
 1458 065a E050      		subi r30,lo8(-(led))
 1459 065c F040      		sbci r31,hi8(-(led))
 1460 065e 8091 0000 		lds r24,twdrbuffer
 1461 0662 8183      		std Z+1,r24
 1462 0664 00C0      		rjmp .L269
 1463               	.L103:
 536:main.c        **** 					}
 537:main.c        **** 								 //set g color
 538:main.c        **** 					else if (commandbyte == 0x95 )
 1464               		.loc 4 538 0
 1465 0666 8539      		cpi r24,lo8(-107)
 1466 0668 01F4      		brne .L104
 539:main.c        **** 					{
 540:main.c        **** 						led[led_position].g = twdrbuffer;changeled = 1;
 1467               		.loc 4 540 0
 1468 066a 8091 0000 		lds r24,led_position
 1469 066e 90E0      		ldi r25,0
 1470 0670 FC01      		movw r30,r24
 1471 0672 EE0F      		lsl r30
 1472 0674 FF1F      		rol r31
 1473 0676 8E0F      		add r24,r30
 1474 0678 9F1F      		adc r25,r31
 1475 067a FC01      		movw r30,r24
 1476 067c E050      		subi r30,lo8(-(led))
 1477 067e F040      		sbci r31,hi8(-(led))
 1478 0680 8091 0000 		lds r24,twdrbuffer
 1479 0684 8083      		st Z,r24
 1480 0686 00C0      		rjmp .L269
 1481               	.L104:
 541:main.c        **** 					}
 542:main.c        **** 								 //set b color
 543:main.c        **** 					else if (commandbyte == 0x96 )
 1482               		.loc 4 543 0
 1483 0688 8639      		cpi r24,lo8(-106)
 1484 068a 01F4      		brne .L105
 544:main.c        **** 					{
 545:main.c        **** 						led[led_position].b = twdrbuffer;changeled = 1;
 1485               		.loc 4 545 0
 1486 068c 8091 0000 		lds r24,led_position
 1487 0690 90E0      		ldi r25,0
 1488 0692 FC01      		movw r30,r24
 1489 0694 EE0F      		lsl r30
 1490 0696 FF1F      		rol r31
 1491 0698 8E0F      		add r24,r30
 1492 069a 9F1F      		adc r25,r31
 1493 069c FC01      		movw r30,r24
 1494 069e E050      		subi r30,lo8(-(led))
 1495 06a0 F040      		sbci r31,hi8(-(led))
 1496 06a2 8091 0000 		lds r24,twdrbuffer
 1497 06a6 8283      		std Z+2,r24
 1498               	.L269:
 1499 06a8 81E0      		ldi r24,lo8(1)
 1500 06aa 8093 0000 		sts changeled,r24
 1501 06ae 00C0      		rjmp .L83
 1502               	.L105:
 546:main.c        **** 					}
 547:main.c        **** 								 //jump to bootloader
 548:main.c        **** 					else if (commandbyte == 0xFD )
 1503               		.loc 4 548 0
 1504 06b0 8D3F      		cpi r24,lo8(-3)
 1505 06b2 01F4      		brne .L106
 549:main.c        **** 					{
 550:main.c        **** 						if (twdrbuffer == 0xFF) jumptobootloader = 1;
 1506               		.loc 4 550 0
 1507 06b4 8091 0000 		lds r24,twdrbuffer
 1508 06b8 8F3F      		cpi r24,lo8(-1)
 1509 06ba 01F4      		brne .L83
 1510               		.loc 4 550 0 is_stmt 0 discriminator 1
 1511 06bc 81E0      		ldi r24,lo8(1)
 1512 06be 8093 0000 		sts jumptobootloader,r24
 1513 06c2 00C0      		rjmp .L83
 1514               	.L106:
 551:main.c        **** 					}
 552:main.c        **** 					else if (commandbyte == 0xA1 ) {led_position = twdrbuffer;}
 1515               		.loc 4 552 0 is_stmt 1
 1516 06c4 813A      		cpi r24,lo8(-95)
 1517 06c6 01F4      		brne .L107
 1518               		.loc 4 552 0 is_stmt 0 discriminator 1
 1519 06c8 8091 0000 		lds r24,twdrbuffer
 1520 06cc 8093 0000 		sts led_position,r24
 1521 06d0 00C0      		rjmp .L83
 1522               	.L107:
 553:main.c        **** 					else if (commandbyte == 0xA0 ) {watchdog = twdrbuffer;}
 1523               		.loc 4 553 0 is_stmt 1
 1524 06d2 803A      		cpi r24,lo8(-96)
 1525 06d4 01F4      		brne .L80
 1526               		.loc 4 553 0 is_stmt 0 discriminator 1
 1527 06d6 8091 0000 		lds r24,twdrbuffer
 1528 06da 8093 0000 		sts watchdog,r24
 1529 06de 00C0      		rjmp .L83
 1530               	.L80:
 554:main.c        **** 					else {i2cerror++;}
 1531               		.loc 4 554 0 is_stmt 1
 1532 06e0 8091 0000 		lds r24,i2cerror
 1533 06e4 8F5F      		subi r24,lo8(-(1))
 1534 06e6 8093 0000 		sts i2cerror,r24
 1535               	.L83:
 555:main.c        **** 
 556:main.c        **** 				}
 557:main.c        **** 				else {i2cerror++;}
 558:main.c        **** 
 559:main.c        **** 				buffer_address++;
 1536               		.loc 4 559 0
 1537 06ea 8091 0000 		lds r24,buffer_address
 1538 06ee 8F5F      		subi r24,lo8(-(1))
 1539 06f0 8093 0000 		sts buffer_address,r24
 1540               	.L63:
 560:main.c        **** 
 561:main.c        **** 			}
 562:main.c        **** 			TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1541               		.loc 4 562 0
 1542 06f4 85EC      		ldi r24,lo8(-59)
 1543 06f6 8093 BC00 		sts 188,r24
 563:main.c        **** 			if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1544               		.loc 4 563 0
 1545 06fa 8091 0000 		lds r24,commandbyte
 1546 06fe 8239      		cpi r24,lo8(-110)
 1547 0700 01F0      		breq .+2
 1548 0702 00C0      		rjmp .L53
 1549 0704 8091 0000 		lds r24,twdrbuffer
 1550 0708 8230      		cpi r24,lo8(2)
 1551 070a 01F0      		breq .+2
 1552 070c 00C0      		rjmp .L53
 1553               	.LVL80:
 1554               	.LBB95:
 1555               	.LBB96:
 1556               		.loc 3 276 0
 1557 070e 85E8      		ldi r24,lo8(-123)
 1558 0710 8A95      	1:	dec r24
 1559 0712 01F4      		brne 1b
 1560 0714 0000      		nop
 1561               	.LVL81:
 1562               	.LBE96:
 1563               	.LBE95:
 1564               		.loc 4 563 0
 1565 0716 2D98      		cbi 0x5,5
 1566 0718 00C0      		rjmp .L53
 1567               	.L59:
 564:main.c        **** 			break;
 565:main.c        **** 
 566:main.c        **** 		case TW_ST_SLA_ACK:		 //  slave adressed
 567:main.c        **** 		case TW_ST_DATA_ACK:
 568:main.c        **** 
 569:main.c        **** 			switch(commandbyte)
 1568               		.loc 4 569 0
 1569 071a 8091 0000 		lds r24,commandbyte
 1570 071e 8431      		cpi r24,lo8(20)
 1571 0720 01F4      		brne .+2
 1572 0722 00C0      		rjmp .L111
 1573 0724 00F4      		brsh .L112
 1574 0726 8D30      		cpi r24,lo8(13)
 1575 0728 01F4      		brne .+2
 1576 072a 00C0      		rjmp .L113
 1577 072c 00F4      		brsh .L114
 1578 072e 9091 0000 		lds r25,buffer_address
 1579 0732 8730      		cpi r24,lo8(7)
 1580 0734 01F4      		brne .+2
 1581 0736 00C0      		rjmp .L115
 1582 0738 00F4      		brsh .+2
 1583 073a 00C0      		rjmp .L116
 1584 073c 8C30      		cpi r24,lo8(12)
 1585 073e 00F0      		brlo .+2
 1586 0740 00C0      		rjmp .L266
 1587 0742 00C0      		rjmp .L116
 1588               	.L114:
 1589 0744 8031      		cpi r24,lo8(16)
 1590 0746 01F4      		brne .+2
 1591 0748 00C0      		rjmp .L118
 1592 074a 00F4      		brsh .L119
 1593 074c 8E30      		cpi r24,lo8(14)
 1594 074e 01F4      		brne .+2
 1595 0750 00C0      		rjmp .L120
 1596 0752 8F30      		cpi r24,lo8(15)
 1597 0754 01F4      		brne .+2
 1598 0756 00C0      		rjmp .L121
 1599 0758 00C0      		rjmp .L110
 1600               	.L119:
 1601 075a 9091 0000 		lds r25,buffer_address
 1602 075e 8231      		cpi r24,lo8(18)
 1603 0760 01F4      		brne .+2
 1604 0762 00C0      		rjmp .L122
 1605 0764 00F4      		brsh .+2
 1606 0766 00C0      		rjmp .L267
 1607 0768 00C0      		rjmp .L311
 1608               	.L112:
 1609 076a 8E37      		cpi r24,lo8(126)
 1610 076c 01F4      		brne .+2
 1611 076e 00C0      		rjmp .L125
 1612 0770 00F4      		brsh .L126
 1613 0772 8731      		cpi r24,lo8(23)
 1614 0774 01F4      		brne .+2
 1615 0776 00C0      		rjmp .L116
 1616 0778 00F4      		brsh .L127
 1617 077a 8531      		cpi r24,lo8(21)
 1618 077c 01F4      		brne .+2
 1619 077e 00C0      		rjmp .L128
 1620 0780 8631      		cpi r24,lo8(22)
 1621 0782 01F4      		brne .+2
 1622 0784 00C0      		rjmp .L129
 1623 0786 00C0      		rjmp .L110
 1624               	.L127:
 1625 0788 8032      		cpi r24,lo8(32)
 1626 078a 01F0      		breq .L130
 1627 078c 8132      		cpi r24,lo8(33)
 1628 078e 01F0      		breq .L131
 1629 0790 8831      		cpi r24,lo8(24)
 1630 0792 01F0      		breq .+2
 1631 0794 00C0      		rjmp .L110
 1632 0796 00C0      		rjmp .L312
 1633               	.L126:
 1634 0798 8739      		cpi r24,lo8(-105)
 1635 079a 00F4      		brsh .L133
 1636 079c 8D38      		cpi r24,lo8(-115)
 1637 079e 00F4      		brsh .L134
 1638 07a0 8F37      		cpi r24,lo8(127)
 1639 07a2 01F4      		brne .+2
 1640 07a4 00C0      		rjmp .L135
 1641 07a6 8738      		cpi r24,lo8(-121)
 1642 07a8 01F0      		breq .L134
 1643 07aa 00C0      		rjmp .L110
 1644               	.L133:
 1645 07ac 805A      		subi r24,lo8(-(96))
 1646 07ae 8230      		cpi r24,lo8(2)
 1647 07b0 00F0      		brlo .+2
 1648 07b2 00C0      		rjmp .L110
 1649               	.L134:
 570:main.c        **** 			{
 571:main.c        **** 
 572:main.c        **** 				case 0x87:
 573:main.c        **** 				case 0x8D:
 574:main.c        **** 				case 0x8E:
 575:main.c        **** 				case 0x8F:
 576:main.c        **** 				case 0x90:
 577:main.c        **** 				case 0x91:
 578:main.c        **** 				case 0x92:
 579:main.c        **** 				case 0x93:
 580:main.c        **** 				case 0x94:
 581:main.c        **** 				case 0x95:
 582:main.c        **** 				case 0xA1:
 583:main.c        **** 				case 0XA0:
 584:main.c        **** 				case 0x96:  { TWDR = crc;  crc = 0xFF;}
 1650               		.loc 4 584 0
 1651 07b4 8091 0000 		lds r24,crc
 1652 07b8 8093 BB00 		sts 187,r24
 1653 07bc 8FEF      		ldi r24,lo8(-1)
 1654 07be 00C0      		rjmp .L274
 1655               	.L312:
 585:main.c        **** 				break;
 586:main.c        **** 
 587:main.c        **** 				case 0x18:
 588:main.c        **** 					if (buffer_address == 0)  {TWDR = display; crc = _crc8_ccitt_update(crc,TWDR);}
 1656               		.loc 4 588 0
 1657 07c0 8091 0000 		lds r24,buffer_address
 1658 07c4 8111      		cpse r24,__zero_reg__
 1659 07c6 00C0      		rjmp .L184
 1660               		.loc 4 588 0 is_stmt 0 discriminator 1
 1661 07c8 8091 0000 		lds r24,display
 1662 07cc 00C0      		rjmp .L272
 1663               	.L130:
 589:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 590:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 591:main.c        **** 
 592:main.c        **** 					break;
 593:main.c        **** 
 594:main.c        **** 				case 0x20:
 595:main.c        **** 					if (buffer_address == 0)  {TWDR = watchdog; crc = _crc8_ccitt_update(crc,TWDR);}
 1664               		.loc 4 595 0 is_stmt 1
 1665 07ce 8091 0000 		lds r24,buffer_address
 1666 07d2 8111      		cpse r24,__zero_reg__
 1667 07d4 00C0      		rjmp .L184
 1668               		.loc 4 595 0 is_stmt 0 discriminator 1
 1669 07d6 8091 0000 		lds r24,watchdog
 1670               	.L272:
 1671 07da 8093 BB00 		sts 187,r24
 1672               	.L275:
 1673 07de 6091 BB00 		lds r22,187
 1674 07e2 8091 0000 		lds r24,crc
 1675 07e6 0E94 0000 		call _crc8_ccitt_update
 1676               	.LVL82:
 1677               	.L274:
 1678 07ea 8093 0000 		sts crc,r24
 1679 07ee 00C0      		rjmp .L136
 1680               	.L131:
 596:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 597:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 598:main.c        **** 
 599:main.c        **** 					break;
 600:main.c        **** 
 601:main.c        **** 				case 0x21:
 602:main.c        **** 					if (buffer_address == 0)  {TWDR = led_position; crc = _crc8_ccitt_update(crc,TWDR);}
 1681               		.loc 4 602 0 is_stmt 1
 1682 07f0 8091 0000 		lds r24,buffer_address
 1683 07f4 8111      		cpse r24,__zero_reg__
 1684 07f6 00C0      		rjmp .L184
 1685               		.loc 4 602 0 is_stmt 0 discriminator 1
 1686 07f8 8091 0000 		lds r24,led_position
 1687 07fc 00C0      		rjmp .L272
 1688               	.L111:
 603:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 604:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 605:main.c        **** 
 606:main.c        **** 					break;
 607:main.c        **** 
 608:main.c        **** 				case 0x14:
 609:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_ccitt_update(crc,TWDR);}
 1689               		.loc 4 609 0 is_stmt 1
 1690 07fe 8091 0000 		lds r24,buffer_address
 1691 0802 8111      		cpse r24,__zero_reg__
 1692 0804 00C0      		rjmp .L184
 1693 0806 00C0      		rjmp .L277
 1694               	.L128:
 610:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 611:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 612:main.c        **** 					break;
 613:main.c        **** 				case 0x15:
 614:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].g; crc = _crc8_ccitt_update(crc,TWDR);}
 1695               		.loc 4 614 0
 1696 0808 8091 0000 		lds r24,buffer_address
 1697 080c 8111      		cpse r24,__zero_reg__
 1698 080e 00C0      		rjmp .L184
 1699 0810 00C0      		rjmp .L278
 1700               	.L129:
 615:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 616:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 617:main.c        **** 					break;
 618:main.c        **** 
 619:main.c        **** 				case 0x16:
 620:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].b; crc = _crc8_ccitt_update(crc,TWDR);}
 1701               		.loc 4 620 0
 1702 0812 8091 0000 		lds r24,buffer_address
 1703 0816 8111      		cpse r24,__zero_reg__
 1704 0818 00C0      		rjmp .L184
 1705 081a 00C0      		rjmp .L279
 1706               	.L116:
 621:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 622:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 623:main.c        **** 					break;
 624:main.c        **** 
 625:main.c        **** 				case 0x00:
 626:main.c        **** 				case 0x01:
 627:main.c        **** 				case 0x02:
 628:main.c        **** 				case 0x03:
 629:main.c        **** 				case 0x04:
 630:main.c        **** 				case 0x05:
 631:main.c        **** 				case 0x06:
 632:main.c        **** 				case 0x08:
 633:main.c        **** 				case 0x09:
 634:main.c        **** 				case 0x0A:
 635:main.c        **** 				case 0x0B:
 636:main.c        **** 				case 0x17:
 637:main.c        **** 					if (buffer_address == 0) {TWDR = i2cbuffer & 0xFF; crc = _crc8_ccitt_update(crc,TWDR);}
 1707               		.loc 4 637 0
 1708 081c 8091 0000 		lds r24,buffer_address
 1709 0820 8111      		cpse r24,__zero_reg__
 1710 0822 00C0      		rjmp .L149
 1711               		.loc 4 637 0 is_stmt 0 discriminator 1
 1712 0824 8091 0000 		lds r24,i2cbuffer
 1713 0828 00C0      		rjmp .L272
 1714               	.L149:
 638:main.c        **** 					else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_ccitt_update(crc,TWDR);}
 1715               		.loc 4 638 0 is_stmt 1
 1716 082a 8130      		cpi r24,lo8(1)
 1717 082c 01F4      		brne .L150
 1718               		.loc 4 638 0 is_stmt 0 discriminator 1
 1719 082e 8091 0000 		lds r24,i2cbuffer+1
 1720 0832 00C0      		rjmp .L272
 1721               	.L150:
 639:main.c        **** 					else if (crc_active && buffer_address == 2) {TWDR = crc;}
 1722               		.loc 4 639 0 is_stmt 1
 1723 0834 9091 0000 		lds r25,crc_active
 1724 0838 9923      		tst r25
 1725 083a 01F4      		brne .+2
 1726 083c 00C0      		rjmp .L187
 1727               		.loc 4 639 0 is_stmt 0 discriminator 1
 1728 083e 8230      		cpi r24,lo8(2)
 1729 0840 01F0      		breq .+2
 1730 0842 00C0      		rjmp .L187
 1731 0844 00C0      		rjmp .L280
 1732               	.L266:
 640:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 641:main.c        **** 					break;
 642:main.c        **** 
 643:main.c        **** 				case 0x0C:
 644:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_ccitt_update(crc,TWDR);}
 1733               		.loc 4 644 0 is_stmt 1
 1734 0846 9111      		cpse r25,__zero_reg__
 1735 0848 00C0      		rjmp .L152
 1736               	.L277:
 1737               		.loc 4 644 0 is_stmt 0 discriminator 1
 1738 084a 8091 0000 		lds r24,led_position
 1739 084e 90E0      		ldi r25,0
 1740 0850 FC01      		movw r30,r24
 1741 0852 EE0F      		lsl r30
 1742 0854 FF1F      		rol r31
 1743 0856 8E0F      		add r24,r30
 1744 0858 9F1F      		adc r25,r31
 1745 085a FC01      		movw r30,r24
 1746 085c E050      		subi r30,lo8(-(led))
 1747 085e F040      		sbci r31,hi8(-(led))
 1748 0860 8181      		ldd r24,Z+1
 1749 0862 00C0      		rjmp .L272
 1750               	.L152:
 645:main.c        **** 					else if (buffer_address == 1)  {TWDR = led[led_position].g; crc = _crc8_ccitt_update(crc,TWDR)
 1751               		.loc 4 645 0 is_stmt 1
 1752 0864 9130      		cpi r25,lo8(1)
 1753 0866 01F4      		brne .L153
 1754               	.L278:
 1755               		.loc 4 645 0 is_stmt 0 discriminator 1
 1756 0868 8091 0000 		lds r24,led_position
 1757 086c 90E0      		ldi r25,0
 1758 086e FC01      		movw r30,r24
 1759 0870 EE0F      		lsl r30
 1760 0872 FF1F      		rol r31
 1761 0874 8E0F      		add r24,r30
 1762 0876 9F1F      		adc r25,r31
 1763 0878 FC01      		movw r30,r24
 1764 087a E050      		subi r30,lo8(-(led))
 1765 087c F040      		sbci r31,hi8(-(led))
 1766 087e 8081      		ld r24,Z
 1767 0880 00C0      		rjmp .L272
 1768               	.L153:
 646:main.c        **** 					else if (buffer_address == 2)  {TWDR = led[led_position].b; crc = _crc8_ccitt_update(crc,TWDR)
 1769               		.loc 4 646 0 is_stmt 1
 1770 0882 9230      		cpi r25,lo8(2)
 1771 0884 01F4      		brne .L154
 1772               	.L279:
 1773               		.loc 4 646 0 is_stmt 0 discriminator 1
 1774 0886 8091 0000 		lds r24,led_position
 1775 088a 90E0      		ldi r25,0
 1776 088c FC01      		movw r30,r24
 1777 088e EE0F      		lsl r30
 1778 0890 FF1F      		rol r31
 1779 0892 8E0F      		add r24,r30
 1780 0894 9F1F      		adc r25,r31
 1781 0896 FC01      		movw r30,r24
 1782 0898 E050      		subi r30,lo8(-(led))
 1783 089a F040      		sbci r31,hi8(-(led))
 1784 089c 8281      		ldd r24,Z+2
 1785 089e 00C0      		rjmp .L272
 1786               	.L154:
 647:main.c        **** 					else if (crc_active && buffer_address == 3)  {TWDR = crc;}
 1787               		.loc 4 647 0 is_stmt 1
 1788 08a0 8091 0000 		lds r24,crc_active
 1789 08a4 8823      		tst r24
 1790 08a6 01F4      		brne .+2
 1791 08a8 00C0      		rjmp .L187
 1792               		.loc 4 647 0 is_stmt 0 discriminator 1
 1793 08aa 9330      		cpi r25,lo8(3)
 1794 08ac 01F0      		breq .+2
 1795 08ae 00C0      		rjmp .L187
 1796 08b0 00C0      		rjmp .L280
 1797               	.L113:
 648:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 649:main.c        **** 					break;
 650:main.c        **** 
 651:main.c        **** 				case 0x0D:
 652:main.c        **** 					if (buffer_address == 0)
 1798               		.loc 4 652 0 is_stmt 1
 1799 08b2 8091 0000 		lds r24,buffer_address
 1800 08b6 8111      		cpse r24,__zero_reg__
 1801 08b8 00C0      		rjmp .L184
 653:main.c        **** 					{
 654:main.c        **** 						if (bit_is_set(PINC,PC6))
 1802               		.loc 4 654 0
 1803 08ba 369B      		sbis 0x6,6
 1804 08bc 00C0      		rjmp .L177
 1805 08be 00C0      		rjmp .L296
 1806               	.L120:
 655:main.c        **** 						{
 656:main.c        **** 							TWDR = 0xFF;
 657:main.c        **** 						}
 658:main.c        **** 						else
 659:main.c        **** 						{
 660:main.c        **** 							TWDR = 0x00;
 661:main.c        **** 						}
 662:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 663:main.c        **** 					}
 664:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 665:main.c        **** 					else {TWDR = 0xFF; i2cerror++;}
 666:main.c        **** 					break;
 667:main.c        **** 
 668:main.c        **** 				case 0x0E:
 669:main.c        **** 					if (buffer_address == 0)
 1807               		.loc 4 669 0
 1808 08c0 8091 0000 		lds r24,buffer_address
 1809 08c4 8111      		cpse r24,__zero_reg__
 1810 08c6 00C0      		rjmp .L184
 670:main.c        **** 					{
 671:main.c        **** 						if (bit_is_set(PIND,PD7))
 1811               		.loc 4 671 0
 1812 08c8 4F9B      		sbis 0x9,7
 1813 08ca 00C0      		rjmp .L177
 1814 08cc 00C0      		rjmp .L296
 1815               	.L121:
 672:main.c        **** 						{
 673:main.c        **** 							TWDR = 0xFF;
 674:main.c        **** 						}
 675:main.c        **** 						else
 676:main.c        **** 						{
 677:main.c        **** 							TWDR = 0x00;
 678:main.c        **** 						}
 679:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 680:main.c        **** 					}
 681:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 682:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 683:main.c        **** 					break;
 684:main.c        **** 
 685:main.c        **** 				case 0x0F:
 686:main.c        **** 					if (buffer_address == 0)
 1816               		.loc 4 686 0
 1817 08ce 8091 0000 		lds r24,buffer_address
 1818 08d2 8111      		cpse r24,__zero_reg__
 1819 08d4 00C0      		rjmp .L184
 687:main.c        **** 					{
 688:main.c        **** 						if (bit_is_set(PINB,PB6))
 1820               		.loc 4 688 0
 1821 08d6 1E9B      		sbis 0x3,6
 1822 08d8 00C0      		rjmp .L177
 1823 08da 00C0      		rjmp .L296
 1824               	.L118:
 689:main.c        **** 						{
 690:main.c        **** 							TWDR = 0xFF;
 691:main.c        **** 						}
 692:main.c        **** 						else
 693:main.c        **** 						{
 694:main.c        **** 							TWDR = 0x00;
 695:main.c        **** 						}
 696:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 697:main.c        **** 					}
 698:main.c        **** 					else if (crc_active && buffer_address == 1) { TWDR = crc;}
 699:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 700:main.c        **** 					break;
 701:main.c        **** 
 702:main.c        **** 				case 0x10:
 703:main.c        **** 					if (buffer_address == 0)
 1825               		.loc 4 703 0
 1826 08dc 8091 0000 		lds r24,buffer_address
 1827 08e0 8111      		cpse r24,__zero_reg__
 1828 08e2 00C0      		rjmp .L184
 704:main.c        **** 					{
 705:main.c        **** 						if (bit_is_set(PINC,PC7))
 1829               		.loc 4 705 0
 1830 08e4 379B      		sbis 0x6,7
 1831 08e6 00C0      		rjmp .L177
 1832 08e8 00C0      		rjmp .L296
 1833               	.L267:
 706:main.c        **** 						{
 707:main.c        **** 							TWDR = 0xFF;
 708:main.c        **** 						}
 709:main.c        **** 						else
 710:main.c        **** 						{
 711:main.c        **** 							TWDR = 0x00;
 712:main.c        **** 						}
 713:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 714:main.c        **** 					}
 715:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 716:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 717:main.c        **** 					break;
 718:main.c        **** 
 719:main.c        **** 				case 0x11:
 720:main.c        **** 					if (buffer_address == 0)
 1834               		.loc 4 720 0
 1835 08ea 9111      		cpse r25,__zero_reg__
 1836 08ec 00C0      		rjmp .L172
 721:main.c        **** 					{
 722:main.c        **** 						if (bit_is_set(PINE,PE2))
 1837               		.loc 4 722 0
 1838 08ee 629B      		sbis 0xc,2
 1839 08f0 00C0      		rjmp .L296
 1840 08f2 00C0      		rjmp .L177
 1841               	.L172:
 723:main.c        **** 						{
 724:main.c        **** 							TWDR = 0x00;
 725:main.c        **** 						}
 726:main.c        **** 						else
 727:main.c        **** 						{
 728:main.c        **** 							TWDR = 0xff;
 729:main.c        **** 						}
 730:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 731:main.c        **** 					}
 732:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 1842               		.loc 4 732 0
 1843 08f4 8091 0000 		lds r24,crc_active
 1844 08f8 8823      		tst r24
 1845 08fa 01F0      		breq .L175
 1846               		.loc 4 732 0 is_stmt 0 discriminator 1
 1847 08fc 9130      		cpi r25,lo8(1)
 1848 08fe 01F0      		breq .L280
 1849               	.L175:
 733:main.c        **** 					else                          {TWDR = 0xFF; buffer_address = 0xFE; i2cerror++;}
 1850               		.loc 4 733 0 is_stmt 1
 1851 0900 8FEF      		ldi r24,lo8(-1)
 1852 0902 8093 BB00 		sts 187,r24
 1853 0906 8EEF      		ldi r24,lo8(-2)
 1854 0908 8093 0000 		sts buffer_address,r24
 1855 090c 00C0      		rjmp .L273
 1856               	.L122:
 734:main.c        **** 					break;
 735:main.c        **** 
 736:main.c        **** 				case 0x12:
 737:main.c        **** 					if (buffer_address == 0)
 1857               		.loc 4 737 0
 1858 090e 9111      		cpse r25,__zero_reg__
 1859 0910 00C0      		rjmp .L186
 738:main.c        **** 					{
 739:main.c        **** 						if (bit_is_set(PINB,PB5))
 1860               		.loc 4 739 0
 1861 0912 1D9B      		sbis 0x3,5
 1862 0914 00C0      		rjmp .L177
 1863               	.L296:
 740:main.c        **** 						{
 741:main.c        **** 							TWDR = 0xFF;
 1864               		.loc 4 741 0
 1865 0916 8FEF      		ldi r24,lo8(-1)
 1866 0918 00C0      		rjmp .L272
 1867               	.L177:
 742:main.c        **** 						}
 743:main.c        **** 						else
 744:main.c        **** 						{
 745:main.c        **** 							TWDR = 0x00;
 1868               		.loc 4 745 0
 1869 091a 1092 BB00 		sts 187,__zero_reg__
 1870 091e 00C0      		rjmp .L275
 1871               	.L311:
 746:main.c        **** 						}
 747:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 748:main.c        **** 					}
 749:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 750:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 751:main.c        **** 					break;
 752:main.c        **** 
 753:main.c        **** 				case 0x13:
 754:main.c        **** 					if (buffer_address == 0) {TWDR = OCR0A; crc = _crc8_ccitt_update(crc,TWDR);}
 1872               		.loc 4 754 0
 1873 0920 9111      		cpse r25,__zero_reg__
 1874 0922 00C0      		rjmp .L186
 1875               		.loc 4 754 0 is_stmt 0 discriminator 1
 1876 0924 87B5      		in r24,0x27
 1877 0926 00C0      		rjmp .L272
 1878               	.L125:
 755:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 756:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 757:main.c        **** 					break;
 758:main.c        **** 
 759:main.c        **** 				case 0x7E:
 760:main.c        **** 					if (buffer_address == 0) {TWDR = crc_active; crc = _crc8_ccitt_update(crc,TWDR);}
 1879               		.loc 4 760 0 is_stmt 1
 1880 0928 8091 0000 		lds r24,buffer_address
 1881 092c 9091 0000 		lds r25,crc_active
 1882 0930 8111      		cpse r24,__zero_reg__
 1883 0932 00C0      		rjmp .L308
 1884               		.loc 4 760 0 is_stmt 0 discriminator 1
 1885 0934 9093 BB00 		sts 187,r25
 1886 0938 00C0      		rjmp .L275
 1887               	.L135:
 761:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 762:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 763:main.c        **** 					break;
 764:main.c        **** 
 765:main.c        **** 				case 0x7F:
 766:main.c        **** 					if (buffer_address == 0) {TWDR = FW_VERSION; crc = _crc8_ccitt_update(crc,TWDR);}
 1888               		.loc 4 766 0 is_stmt 1
 1889 093a 8091 0000 		lds r24,buffer_address
 1890 093e 8111      		cpse r24,__zero_reg__
 1891 0940 00C0      		rjmp .L184
 1892               		.loc 4 766 0 is_stmt 0 discriminator 1
 1893 0942 81E0      		ldi r24,lo8(1)
 1894 0944 00C0      		rjmp .L272
 1895               	.L184:
 767:main.c        **** 					else if (crc_active && buffer_address == 1) {TWDR = crc;}
 1896               		.loc 4 767 0 is_stmt 1
 1897 0946 9091 0000 		lds r25,crc_active
 1898               	.L308:
 1899 094a 9923      		tst r25
 1900 094c 01F0      		breq .L187
 1901               		.loc 4 767 0 is_stmt 0 discriminator 1
 1902 094e 8130      		cpi r24,lo8(1)
 1903 0950 01F4      		brne .L187
 1904 0952 00C0      		rjmp .L280
 1905               	.L115:
 768:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 769:main.c        **** 					break;
 770:main.c        **** 
 771:main.c        **** 				case 0x07:
 772:main.c        **** 					if (buffer_address == 0)  {TWDR = bllevel; if (crc_active) crc = _crc8_ccitt_update(crc,TWDR);
 1906               		.loc 4 772 0 is_stmt 1
 1907 0954 9111      		cpse r25,__zero_reg__
 1908 0956 00C0      		rjmp .L186
 1909               		.loc 4 772 0 is_stmt 0 discriminator 1
 1910 0958 8091 0000 		lds r24,bllevel
 1911 095c 8093 BB00 		sts 187,r24
 1912 0960 8091 0000 		lds r24,crc_active
 1913 0964 8823      		tst r24
 1914 0966 01F0      		breq .L136
 1915 0968 00C0      		rjmp .L275
 1916               	.L186:
 773:main.c        **** 					else if (crc_active && buffer_address == 1)  {TWDR = crc;}
 1917               		.loc 4 773 0 is_stmt 1
 1918 096a 8091 0000 		lds r24,crc_active
 1919 096e 8823      		tst r24
 1920 0970 01F0      		breq .L187
 1921               		.loc 4 773 0 is_stmt 0 discriminator 1
 1922 0972 9130      		cpi r25,lo8(1)
 1923 0974 01F4      		brne .L187
 1924               	.L280:
 1925               		.loc 4 773 0 discriminator 2
 1926 0976 8091 0000 		lds r24,crc
 1927 097a 00C0      		rjmp .L271
 1928               	.L187:
 774:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 1929               		.loc 4 774 0 is_stmt 1
 1930 097c 8FEF      		ldi r24,lo8(-1)
 1931 097e 8093 BB00 		sts 187,r24
 1932               	.L273:
 1933 0982 8091 0000 		lds r24,i2cerror
 1934 0986 8F5F      		subi r24,lo8(-(1))
 1935 0988 8093 0000 		sts i2cerror,r24
 1936 098c 00C0      		rjmp .L136
 1937               	.L110:
 775:main.c        **** 
 776:main.c        **** 					break;
 777:main.c        **** 
 778:main.c        **** 				default: TWDR = 0xFF;
 1938               		.loc 4 778 0
 1939 098e 8FEF      		ldi r24,lo8(-1)
 1940               	.L271:
 1941 0990 8093 BB00 		sts 187,r24
 1942               	.L136:
 1943               	.LVL83:
 1944               	.LBB97:
 1945               	.LBB98:
 1946               		.loc 3 276 0
 1947 0994 85E3      		ldi r24,lo8(53)
 1948 0996 8A95      	1:	dec r24
 1949 0998 01F4      		brne 1b
 1950 099a 0000      		nop
 1951               	.LVL84:
 1952               	.LBE98:
 1953               	.LBE97:
 779:main.c        **** 
 780:main.c        **** 			}
 781:main.c        **** 
 782:main.c        **** 			_delay_us(10);
 783:main.c        **** 
 784:main.c        **** 			buffer_address++;
 1954               		.loc 4 784 0
 1955 099c 8091 0000 		lds r24,buffer_address
 1956 09a0 8F5F      		subi r24,lo8(-(1))
 1957 09a2 8093 0000 		sts buffer_address,r24
 1958 09a6 00C0      		rjmp .L54
 1959               	.L57:
 785:main.c        **** 			TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 786:main.c        **** 			break;
 787:main.c        **** 
 788:main.c        **** 		case TW_BUS_ERROR:
 789:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1960               		.loc 4 789 0
 1961 09a8 85ED      		ldi r24,lo8(-43)
 1962 09aa 00C0      		rjmp .L276
 1963               	.L54:
 790:main.c        **** 			break;
 791:main.c        **** 
 792:main.c        **** 			//case TW_SR_STOP:  TWCR |= (1<<TWINT)|(1<<TWEA)|(1<<TWEN);  break;
 793:main.c        **** 
 794:main.c        **** 		default:
 795:main.c        **** 			TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)| (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|  (0<<TWWC);
 1964               		.loc 4 795 0
 1965 09ac 85EC      		ldi r24,lo8(-59)
 1966               	.L276:
 1967 09ae 8093 BC00 		sts 188,r24
 1968               	.L53:
 1969               	/* epilogue start */
 796:main.c        **** 
 797:main.c        **** 	}
 798:main.c        **** 
 799:main.c        **** }
 1970               		.loc 4 799 0
 1971 09b2 FF91      		pop r31
 1972 09b4 EF91      		pop r30
 1973 09b6 CF91      		pop r28
 1974 09b8 BF91      		pop r27
 1975 09ba AF91      		pop r26
 1976 09bc 9F91      		pop r25
 1977 09be 8F91      		pop r24
 1978 09c0 7F91      		pop r23
 1979 09c2 6F91      		pop r22
 1980 09c4 5F91      		pop r21
 1981 09c6 4F91      		pop r20
 1982 09c8 3F91      		pop r19
 1983 09ca 2F91      		pop r18
 1984 09cc 0F90      		pop r0
 1985 09ce 0FBE      		out __SREG__,r0
 1986 09d0 0F90      		pop r0
 1987 09d2 1F90      		pop r1
 1988 09d4 1895      		reti
 1989               		.cfi_endproc
 1990               	.LFE35:
 1992               	.global	setup
 1994               	setup:
 1995               	.LFB36:
 800:main.c        **** 
 801:main.c        **** 
 802:main.c        **** void setup(void)
 803:main.c        **** {
 1996               		.loc 4 803 0
 1997               		.cfi_startproc
 1998 09d6 CF93      		push r28
 1999               	.LCFI29:
 2000               		.cfi_def_cfa_offset 3
 2001               		.cfi_offset 28, -2
 2002 09d8 DF93      		push r29
 2003               	.LCFI30:
 2004               		.cfi_def_cfa_offset 4
 2005               		.cfi_offset 29, -3
 2006               	/* prologue: function */
 2007               	/* frame size = 0 */
 2008               	/* stack size = 2 */
 2009               	.L__stack_usage = 2
 804:main.c        ****         UDCON = 1;
 2010               		.loc 4 804 0
 2011 09da 81E0      		ldi r24,lo8(1)
 2012 09dc 8093 E000 		sts 224,r24
 805:main.c        ****         USBCON = (1<<FRZCLK); 
 2013               		.loc 4 805 0
 2014 09e0 90E2      		ldi r25,lo8(32)
 2015 09e2 9093 D800 		sts 216,r25
 806:main.c        **** 	DDRF = 0b00000000;
 2016               		.loc 4 806 0
 2017 09e6 10BA      		out 0x10,__zero_reg__
 807:main.c        **** 	DDRD = 0b10111011;
 2018               		.loc 4 807 0
 2019 09e8 9BEB      		ldi r25,lo8(-69)
 2020 09ea 9AB9      		out 0xa,r25
 808:main.c        **** 	PORTD= 0b00000000;
 2021               		.loc 4 808 0
 2022 09ec 1BB8      		out 0xb,__zero_reg__
 809:main.c        **** 	DDRE = 0b00000000;
 2023               		.loc 4 809 0
 2024 09ee 1DB8      		out 0xd,__zero_reg__
 810:main.c        **** 	DDRE |= (1<<2);				 // be carefull with hwb, check if its connected to GND via 10k (prototypes!)
 2025               		.loc 4 810 0
 2026 09f0 6A9A      		sbi 0xd,2
 811:main.c        **** 	DDRB = 0b11100110;
 2027               		.loc 4 811 0
 2028 09f2 96EE      		ldi r25,lo8(-26)
 2029 09f4 94B9      		out 0x4,r25
 812:main.c        **** 	DDRC = 0b11000000;
 2030               		.loc 4 812 0
 2031 09f6 90EC      		ldi r25,lo8(-64)
 2032 09f8 97B9      		out 0x7,r25
 813:main.c        **** 	OCR0A = 0;					 //    start value for FAN  0 / 255  (-> p-channel so inverted)       0x00 is ON  0
 2033               		.loc 4 813 0
 2034 09fa 17BC      		out 0x27,__zero_reg__
 814:main.c        **** 	TCCR0B  =  0b00000001;
 2035               		.loc 4 814 0
 2036 09fc 85BD      		out 0x25,r24
 815:main.c        **** 	TCCR0A  =  0b10000011;		 // 8bit  62khz
 2037               		.loc 4 815 0
 2038 09fe 83E8      		ldi r24,lo8(-125)
 2039 0a00 84BD      		out 0x24,r24
 816:main.c        **** 	TIMSK0 |= (1 << TOIE0);		 // init interrupt for timer0 overflow
 2040               		.loc 4 816 0
 2041 0a02 EEE6      		ldi r30,lo8(110)
 2042 0a04 F0E0      		ldi r31,0
 2043 0a06 8081      		ld r24,Z
 2044 0a08 8160      		ori r24,lo8(1)
 2045 0a0a 8083      		st Z,r24
 2046               	.LVL85:
 2047               	.LBB99:
 2048               	.LBB100:
 2049               		.file 5 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/power.h **** 
   5:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/power.h **** 
   8:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/avr/power.h ****      distribution.
  14:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/lib/avr/include/avr/power.h **** 
  18:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/lib/avr/include/avr/power.h **** 
  30:/usr/lib/avr/include/avr/power.h **** /* $Id$ */
  31:/usr/lib/avr/include/avr/power.h **** 
  32:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/lib/avr/include/avr/power.h **** 
  35:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** 
  39:/usr/lib/avr/include/avr/power.h **** /** \file */
  40:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  41:/usr/lib/avr/include/avr/power.h **** 
  42:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  43:/usr/lib/avr/include/avr/power.h **** 
  44:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  45:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  46:/usr/lib/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  47:/usr/lib/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  48:/usr/lib/avr/include/avr/power.h **** Register (CLKPR).
  49:/usr/lib/avr/include/avr/power.h **** 
  50:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  51:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  52:/usr/lib/avr/include/avr/power.h **** 
  53:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  54:/usr/lib/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  55:/usr/lib/avr/include/avr/power.h **** power reduction macros are not available..
  56:/usr/lib/avr/include/avr/power.h **** 
  57:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  58:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  59:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  60:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  61:/usr/lib/avr/include/avr/power.h **** 
  62:/usr/lib/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  63:/usr/lib/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  64:/usr/lib/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  65:/usr/lib/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  66:/usr/lib/avr/include/avr/power.h **** the clock below 131.072 kHz.
  67:/usr/lib/avr/include/avr/power.h **** 
  68:/usr/lib/avr/include/avr/power.h **** */
  69:/usr/lib/avr/include/avr/power.h **** 
  70:/usr/lib/avr/include/avr/power.h **** 
  71:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  72:/usr/lib/avr/include/avr/power.h **** 
  73:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  74:/usr/lib/avr/include/avr/power.h **** <small>
  75:/usr/lib/avr/include/avr/power.h **** <center>
  76:/usr/lib/avr/include/avr/power.h **** <table border="3">
  77:/usr/lib/avr/include/avr/power.h ****   <tr>
  78:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  79:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  80:/usr/lib/avr/include/avr/power.h ****   </tr>
  81:/usr/lib/avr/include/avr/power.h **** 
  82:/usr/lib/avr/include/avr/power.h ****   <tr>
  83:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  84:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  85:/usr/lib/avr/include/avr/power.h ****   </tr>
  86:/usr/lib/avr/include/avr/power.h **** 
  87:/usr/lib/avr/include/avr/power.h ****   <tr>
  88:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  89:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  90:/usr/lib/avr/include/avr/power.h ****   </tr>
  91:/usr/lib/avr/include/avr/power.h **** 
  92:/usr/lib/avr/include/avr/power.h ****   <tr>
  93:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  94:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  95:/usr/lib/avr/include/avr/power.h ****   </tr>
  96:/usr/lib/avr/include/avr/power.h **** 
  97:/usr/lib/avr/include/avr/power.h ****   <tr>
  98:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  99:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
 100:/usr/lib/avr/include/avr/power.h ****   </tr>
 101:/usr/lib/avr/include/avr/power.h **** 
 102:/usr/lib/avr/include/avr/power.h ****   <tr>
 103:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 104:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 105:/usr/lib/avr/include/avr/power.h ****   </tr>
 106:/usr/lib/avr/include/avr/power.h **** 
 107:/usr/lib/avr/include/avr/power.h ****   <tr>
 108:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 109:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 110:/usr/lib/avr/include/avr/power.h ****   </tr>
 111:/usr/lib/avr/include/avr/power.h **** 
 112:/usr/lib/avr/include/avr/power.h ****   <tr>
 113:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 114:/usr/lib/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 115:/usr/lib/avr/include/avr/power.h ****   </tr>
 116:/usr/lib/avr/include/avr/power.h **** 
 117:/usr/lib/avr/include/avr/power.h ****   <tr>
 118:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 119:/usr/lib/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 120:/usr/lib/avr/include/avr/power.h ****   </tr>
 121:/usr/lib/avr/include/avr/power.h **** 
 122:/usr/lib/avr/include/avr/power.h ****   <tr>
 123:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 124:/usr/lib/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 125:/usr/lib/avr/include/avr/power.h ****   </tr>
 126:/usr/lib/avr/include/avr/power.h **** 
 127:/usr/lib/avr/include/avr/power.h ****   <tr>
 128:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 129:/usr/lib/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 130:/usr/lib/avr/include/avr/power.h ****   </tr>
 131:/usr/lib/avr/include/avr/power.h **** 
 132:/usr/lib/avr/include/avr/power.h ****    <tr>
 133:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 134:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 135:/usr/lib/avr/include/avr/power.h ****   </tr>
 136:/usr/lib/avr/include/avr/power.h **** 
 137:/usr/lib/avr/include/avr/power.h ****   <tr>
 138:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 139:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 140:/usr/lib/avr/include/avr/power.h ****   </tr>
 141:/usr/lib/avr/include/avr/power.h **** 
 142:/usr/lib/avr/include/avr/power.h ****   <tr>
 143:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 144:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 145:/usr/lib/avr/include/avr/power.h ****   </tr>
 146:/usr/lib/avr/include/avr/power.h **** 
 147:/usr/lib/avr/include/avr/power.h ****   <tr>
 148:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 149:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 150:/usr/lib/avr/include/avr/power.h ****   </tr>
 151:/usr/lib/avr/include/avr/power.h ****   
 152:/usr/lib/avr/include/avr/power.h ****   <tr>
 153:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 154:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 155:/usr/lib/avr/include/avr/power.h ****   </tr>
 156:/usr/lib/avr/include/avr/power.h **** 
 157:/usr/lib/avr/include/avr/power.h ****   <tr>
 158:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 159:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 160:/usr/lib/avr/include/avr/power.h ****   </tr>
 161:/usr/lib/avr/include/avr/power.h **** 
 162:/usr/lib/avr/include/avr/power.h ****   <tr>
 163:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 164:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 165:/usr/lib/avr/include/avr/power.h ****   </tr>
 166:/usr/lib/avr/include/avr/power.h **** 
 167:/usr/lib/avr/include/avr/power.h ****   <tr>
 168:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 169:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 170:/usr/lib/avr/include/avr/power.h ****   </tr>
 171:/usr/lib/avr/include/avr/power.h **** 
 172:/usr/lib/avr/include/avr/power.h ****   <tr>
 173:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 174:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 175:/usr/lib/avr/include/avr/power.h ****   </tr>
 176:/usr/lib/avr/include/avr/power.h **** 
 177:/usr/lib/avr/include/avr/power.h ****   <tr>
 178:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 179:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 180:/usr/lib/avr/include/avr/power.h ****   </tr>
 181:/usr/lib/avr/include/avr/power.h **** 
 182:/usr/lib/avr/include/avr/power.h ****   <tr>
 183:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 184:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 185:/usr/lib/avr/include/avr/power.h ****   </tr>
 186:/usr/lib/avr/include/avr/power.h **** 
 187:/usr/lib/avr/include/avr/power.h ****   <tr>
 188:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 189:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 190:/usr/lib/avr/include/avr/power.h ****   </tr>
 191:/usr/lib/avr/include/avr/power.h **** 
 192:/usr/lib/avr/include/avr/power.h ****   <tr>
 193:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 194:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 195:/usr/lib/avr/include/avr/power.h ****   </tr>
 196:/usr/lib/avr/include/avr/power.h **** 
 197:/usr/lib/avr/include/avr/power.h ****   <tr>
 198:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 199:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 200:/usr/lib/avr/include/avr/power.h ****   </tr>
 201:/usr/lib/avr/include/avr/power.h **** 
 202:/usr/lib/avr/include/avr/power.h ****   <tr>
 203:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 204:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 205:/usr/lib/avr/include/avr/power.h ****   </tr>
 206:/usr/lib/avr/include/avr/power.h **** 
 207:/usr/lib/avr/include/avr/power.h ****   <tr>
 208:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 209:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 210:/usr/lib/avr/include/avr/power.h ****   </tr>
 211:/usr/lib/avr/include/avr/power.h **** 
 212:/usr/lib/avr/include/avr/power.h ****   <tr>
 213:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 214:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 215:/usr/lib/avr/include/avr/power.h ****   </tr>
 216:/usr/lib/avr/include/avr/power.h **** 
 217:/usr/lib/avr/include/avr/power.h ****   <tr>
 218:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 219:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 220:/usr/lib/avr/include/avr/power.h ****   </tr>
 221:/usr/lib/avr/include/avr/power.h **** 
 222:/usr/lib/avr/include/avr/power.h ****   <tr>
 223:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 224:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 225:/usr/lib/avr/include/avr/power.h ****   </tr>
 226:/usr/lib/avr/include/avr/power.h **** 
 227:/usr/lib/avr/include/avr/power.h ****   <tr>
 228:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 229:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 230:/usr/lib/avr/include/avr/power.h ****   </tr>
 231:/usr/lib/avr/include/avr/power.h **** 
 232:/usr/lib/avr/include/avr/power.h ****   <tr>
 233:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 234:/usr/lib/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 235:/usr/lib/avr/include/avr/power.h ****   </tr>
 236:/usr/lib/avr/include/avr/power.h **** 
 237:/usr/lib/avr/include/avr/power.h ****   <tr>
 238:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 239:/usr/lib/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 240:/usr/lib/avr/include/avr/power.h ****   </tr>
 241:/usr/lib/avr/include/avr/power.h **** 
 242:/usr/lib/avr/include/avr/power.h ****   <tr>
 243:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 244:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 245:/usr/lib/avr/include/avr/power.h ****   </tr>
 246:/usr/lib/avr/include/avr/power.h **** 
 247:/usr/lib/avr/include/avr/power.h ****   <tr>
 248:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 249:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 250:/usr/lib/avr/include/avr/power.h ****   </tr>
 251:/usr/lib/avr/include/avr/power.h **** 
 252:/usr/lib/avr/include/avr/power.h ****   <tr>
 253:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 254:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 255:/usr/lib/avr/include/avr/power.h ****   </tr>
 256:/usr/lib/avr/include/avr/power.h **** 
 257:/usr/lib/avr/include/avr/power.h ****   <tr>
 258:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 259:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 260:/usr/lib/avr/include/avr/power.h ****   </tr>
 261:/usr/lib/avr/include/avr/power.h **** 
 262:/usr/lib/avr/include/avr/power.h ****   <tr>
 263:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 264:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 265:/usr/lib/avr/include/avr/power.h ****   </tr>
 266:/usr/lib/avr/include/avr/power.h **** 
 267:/usr/lib/avr/include/avr/power.h ****   <tr>
 268:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 269:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 270:/usr/lib/avr/include/avr/power.h ****   </tr>
 271:/usr/lib/avr/include/avr/power.h **** 
 272:/usr/lib/avr/include/avr/power.h ****   <tr>
 273:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 274:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 275:/usr/lib/avr/include/avr/power.h ****   </tr>
 276:/usr/lib/avr/include/avr/power.h **** 
 277:/usr/lib/avr/include/avr/power.h ****   <tr>
 278:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 279:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 280:/usr/lib/avr/include/avr/power.h ****   </tr>
 281:/usr/lib/avr/include/avr/power.h **** 
 282:/usr/lib/avr/include/avr/power.h ****   <tr>
 283:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 284:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 285:/usr/lib/avr/include/avr/power.h ****   </tr>
 286:/usr/lib/avr/include/avr/power.h **** 
 287:/usr/lib/avr/include/avr/power.h ****   <tr>
 288:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 289:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 290:/usr/lib/avr/include/avr/power.h ****   </tr>
 291:/usr/lib/avr/include/avr/power.h **** 
 292:/usr/lib/avr/include/avr/power.h ****   <tr>
 293:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 294:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 295:/usr/lib/avr/include/avr/power.h ****   </tr>
 296:/usr/lib/avr/include/avr/power.h **** 
 297:/usr/lib/avr/include/avr/power.h ****   <tr>
 298:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 299:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 300:/usr/lib/avr/include/avr/power.h ****   </tr>
 301:/usr/lib/avr/include/avr/power.h **** 
 302:/usr/lib/avr/include/avr/power.h ****   <tr>
 303:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 304:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 305:/usr/lib/avr/include/avr/power.h ****   </tr>
 306:/usr/lib/avr/include/avr/power.h **** 
 307:/usr/lib/avr/include/avr/power.h ****   <tr>
 308:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 309:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 310:/usr/lib/avr/include/avr/power.h ****   </tr>
 311:/usr/lib/avr/include/avr/power.h **** 
 312:/usr/lib/avr/include/avr/power.h ****   <tr>
 313:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 314:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 315:/usr/lib/avr/include/avr/power.h ****   </tr>
 316:/usr/lib/avr/include/avr/power.h **** 
 317:/usr/lib/avr/include/avr/power.h ****   <tr>
 318:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 319:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 320:/usr/lib/avr/include/avr/power.h ****   </tr>
 321:/usr/lib/avr/include/avr/power.h **** 
 322:/usr/lib/avr/include/avr/power.h ****   <tr>
 323:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 324:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 325:/usr/lib/avr/include/avr/power.h ****   </tr>
 326:/usr/lib/avr/include/avr/power.h **** 
 327:/usr/lib/avr/include/avr/power.h ****   <tr>
 328:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 329:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 330:/usr/lib/avr/include/avr/power.h ****   </tr>
 331:/usr/lib/avr/include/avr/power.h **** 
 332:/usr/lib/avr/include/avr/power.h ****   <tr>
 333:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 334:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 335:/usr/lib/avr/include/avr/power.h ****   </tr>
 336:/usr/lib/avr/include/avr/power.h **** 
 337:/usr/lib/avr/include/avr/power.h ****   <tr>
 338:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 339:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 340:/usr/lib/avr/include/avr/power.h ****   </tr>
 341:/usr/lib/avr/include/avr/power.h **** 
 342:/usr/lib/avr/include/avr/power.h ****   <tr>
 343:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 344:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 345:/usr/lib/avr/include/avr/power.h ****   </tr>
 346:/usr/lib/avr/include/avr/power.h **** 
 347:/usr/lib/avr/include/avr/power.h ****   <tr>
 348:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 349:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 350:/usr/lib/avr/include/avr/power.h ****   </tr>
 351:/usr/lib/avr/include/avr/power.h **** 
 352:/usr/lib/avr/include/avr/power.h ****   <tr>
 353:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 354:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 355:/usr/lib/avr/include/avr/power.h ****   </tr>
 356:/usr/lib/avr/include/avr/power.h **** 
 357:/usr/lib/avr/include/avr/power.h ****   <tr>
 358:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 359:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 360:/usr/lib/avr/include/avr/power.h ****   </tr>
 361:/usr/lib/avr/include/avr/power.h **** 
 362:/usr/lib/avr/include/avr/power.h ****   <tr>
 363:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 364:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 365:/usr/lib/avr/include/avr/power.h ****   </tr>
 366:/usr/lib/avr/include/avr/power.h **** 
 367:/usr/lib/avr/include/avr/power.h ****   <tr>
 368:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 369:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 370:/usr/lib/avr/include/avr/power.h ****   </tr>
 371:/usr/lib/avr/include/avr/power.h **** 
 372:/usr/lib/avr/include/avr/power.h ****   <tr>
 373:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 374:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 375:/usr/lib/avr/include/avr/power.h ****   </tr>
 376:/usr/lib/avr/include/avr/power.h **** 
 377:/usr/lib/avr/include/avr/power.h ****   <tr>
 378:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 379:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 380:/usr/lib/avr/include/avr/power.h ****   </tr>
 381:/usr/lib/avr/include/avr/power.h **** 
 382:/usr/lib/avr/include/avr/power.h ****   <tr>
 383:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 384:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 385:/usr/lib/avr/include/avr/power.h ****   </tr>
 386:/usr/lib/avr/include/avr/power.h **** 
 387:/usr/lib/avr/include/avr/power.h ****   <tr>
 388:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 389:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 390:/usr/lib/avr/include/avr/power.h ****   </tr>
 391:/usr/lib/avr/include/avr/power.h **** 
 392:/usr/lib/avr/include/avr/power.h ****   <tr>
 393:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 394:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 395:/usr/lib/avr/include/avr/power.h ****   </tr>
 396:/usr/lib/avr/include/avr/power.h **** 
 397:/usr/lib/avr/include/avr/power.h ****   <tr>
 398:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 399:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 400:/usr/lib/avr/include/avr/power.h ****   </tr>
 401:/usr/lib/avr/include/avr/power.h **** 
 402:/usr/lib/avr/include/avr/power.h ****   <tr>
 403:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 404:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 405:/usr/lib/avr/include/avr/power.h ****   </tr>
 406:/usr/lib/avr/include/avr/power.h **** 
 407:/usr/lib/avr/include/avr/power.h ****   <tr>
 408:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 409:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 410:/usr/lib/avr/include/avr/power.h ****   </tr>
 411:/usr/lib/avr/include/avr/power.h **** 
 412:/usr/lib/avr/include/avr/power.h ****   <tr>
 413:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 414:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 415:/usr/lib/avr/include/avr/power.h ****   </tr>
 416:/usr/lib/avr/include/avr/power.h **** 
 417:/usr/lib/avr/include/avr/power.h ****   <tr>
 418:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 419:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 420:/usr/lib/avr/include/avr/power.h ****   </tr>
 421:/usr/lib/avr/include/avr/power.h **** 
 422:/usr/lib/avr/include/avr/power.h ****   <tr>
 423:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 424:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 425:/usr/lib/avr/include/avr/power.h ****   </tr>
 426:/usr/lib/avr/include/avr/power.h **** 
 427:/usr/lib/avr/include/avr/power.h ****   <tr>
 428:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 429:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 430:/usr/lib/avr/include/avr/power.h ****   </tr>
 431:/usr/lib/avr/include/avr/power.h **** 
 432:/usr/lib/avr/include/avr/power.h ****   <tr>
 433:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 434:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 435:/usr/lib/avr/include/avr/power.h ****   </tr>
 436:/usr/lib/avr/include/avr/power.h **** 
 437:/usr/lib/avr/include/avr/power.h ****   <tr>
 438:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 439:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 440:/usr/lib/avr/include/avr/power.h ****   </tr>
 441:/usr/lib/avr/include/avr/power.h **** 
 442:/usr/lib/avr/include/avr/power.h ****   <tr>
 443:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 444:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 445:/usr/lib/avr/include/avr/power.h ****   </tr>
 446:/usr/lib/avr/include/avr/power.h **** 
 447:/usr/lib/avr/include/avr/power.h ****   <tr>
 448:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 449:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 450:/usr/lib/avr/include/avr/power.h ****   </tr>
 451:/usr/lib/avr/include/avr/power.h **** 
 452:/usr/lib/avr/include/avr/power.h ****   <tr>
 453:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 454:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 455:/usr/lib/avr/include/avr/power.h ****   </tr>
 456:/usr/lib/avr/include/avr/power.h **** 
 457:/usr/lib/avr/include/avr/power.h ****   <tr>
 458:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 459:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 460:/usr/lib/avr/include/avr/power.h ****   </tr>
 461:/usr/lib/avr/include/avr/power.h **** 
 462:/usr/lib/avr/include/avr/power.h ****   <tr>
 463:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 464:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 465:/usr/lib/avr/include/avr/power.h ****   </tr>
 466:/usr/lib/avr/include/avr/power.h **** 
 467:/usr/lib/avr/include/avr/power.h ****   <tr>
 468:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 469:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 470:/usr/lib/avr/include/avr/power.h ****   </tr>
 471:/usr/lib/avr/include/avr/power.h **** 
 472:/usr/lib/avr/include/avr/power.h ****   <tr>
 473:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 474:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 475:/usr/lib/avr/include/avr/power.h ****   </tr>
 476:/usr/lib/avr/include/avr/power.h **** 
 477:/usr/lib/avr/include/avr/power.h ****   <tr>
 478:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 479:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 480:/usr/lib/avr/include/avr/power.h ****   </tr>
 481:/usr/lib/avr/include/avr/power.h **** 
 482:/usr/lib/avr/include/avr/power.h ****   <tr>
 483:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 484:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 485:/usr/lib/avr/include/avr/power.h ****   </tr>
 486:/usr/lib/avr/include/avr/power.h **** 
 487:/usr/lib/avr/include/avr/power.h ****   <tr>
 488:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 489:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 490:/usr/lib/avr/include/avr/power.h ****   </tr>
 491:/usr/lib/avr/include/avr/power.h **** 
 492:/usr/lib/avr/include/avr/power.h ****   <tr>
 493:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 494:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 495:/usr/lib/avr/include/avr/power.h ****   </tr>
 496:/usr/lib/avr/include/avr/power.h **** 
 497:/usr/lib/avr/include/avr/power.h ****   <tr>
 498:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 499:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 500:/usr/lib/avr/include/avr/power.h ****   </tr>
 501:/usr/lib/avr/include/avr/power.h **** 
 502:/usr/lib/avr/include/avr/power.h ****   <tr>
 503:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 504:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 505:/usr/lib/avr/include/avr/power.h ****   </tr>
 506:/usr/lib/avr/include/avr/power.h **** 
 507:/usr/lib/avr/include/avr/power.h ****   <tr>
 508:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 509:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 510:/usr/lib/avr/include/avr/power.h ****   </tr>
 511:/usr/lib/avr/include/avr/power.h **** 
 512:/usr/lib/avr/include/avr/power.h ****   <tr>
 513:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 514:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 515:/usr/lib/avr/include/avr/power.h ****   </tr>
 516:/usr/lib/avr/include/avr/power.h **** 
 517:/usr/lib/avr/include/avr/power.h ****   <tr>
 518:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 519:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 520:/usr/lib/avr/include/avr/power.h ****   </tr>
 521:/usr/lib/avr/include/avr/power.h **** 
 522:/usr/lib/avr/include/avr/power.h ****   <tr>
 523:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 524:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 525:/usr/lib/avr/include/avr/power.h ****   </tr>
 526:/usr/lib/avr/include/avr/power.h **** 
 527:/usr/lib/avr/include/avr/power.h ****   <tr>
 528:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 529:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 530:/usr/lib/avr/include/avr/power.h ****   </tr>
 531:/usr/lib/avr/include/avr/power.h **** 
 532:/usr/lib/avr/include/avr/power.h ****   <tr>
 533:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 534:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 535:/usr/lib/avr/include/avr/power.h ****   </tr>
 536:/usr/lib/avr/include/avr/power.h **** 
 537:/usr/lib/avr/include/avr/power.h ****   <tr>
 538:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 539:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 540:/usr/lib/avr/include/avr/power.h ****   </tr>
 541:/usr/lib/avr/include/avr/power.h **** </table>
 542:/usr/lib/avr/include/avr/power.h **** </center>
 543:/usr/lib/avr/include/avr/power.h **** </small>
 544:/usr/lib/avr/include/avr/power.h **** 
 545:/usr/lib/avr/include/avr/power.h **** @} */
 546:/usr/lib/avr/include/avr/power.h **** 
 547:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 548:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 549:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 550:/usr/lib/avr/include/avr/power.h **** #endif
 551:/usr/lib/avr/include/avr/power.h **** 
 552:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 553:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 554:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 555:/usr/lib/avr/include/avr/power.h **** #endif
 556:/usr/lib/avr/include/avr/power.h **** 
 557:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 558:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 559:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 560:/usr/lib/avr/include/avr/power.h **** #endif
 561:/usr/lib/avr/include/avr/power.h **** 
 562:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 563:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 564:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 565:/usr/lib/avr/include/avr/power.h **** #endif
 566:/usr/lib/avr/include/avr/power.h **** 
 567:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 568:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 569:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 570:/usr/lib/avr/include/avr/power.h **** #endif
 571:/usr/lib/avr/include/avr/power.h **** 
 572:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 573:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 574:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 575:/usr/lib/avr/include/avr/power.h **** #endif
 576:/usr/lib/avr/include/avr/power.h **** 
 577:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 578:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 579:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 580:/usr/lib/avr/include/avr/power.h **** #endif
 581:/usr/lib/avr/include/avr/power.h **** 
 582:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 583:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 584:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 585:/usr/lib/avr/include/avr/power.h **** #endif
 586:/usr/lib/avr/include/avr/power.h **** 
 587:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSCR)
 588:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 589:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 590:/usr/lib/avr/include/avr/power.h **** #endif
 591:/usr/lib/avr/include/avr/power.h **** 
 592:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 593:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 594:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 595:/usr/lib/avr/include/avr/power.h **** #endif
 596:/usr/lib/avr/include/avr/power.h **** 
 597:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 598:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 599:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 600:/usr/lib/avr/include/avr/power.h **** #endif
 601:/usr/lib/avr/include/avr/power.h **** 
 602:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 603:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 604:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 605:/usr/lib/avr/include/avr/power.h **** #endif
 606:/usr/lib/avr/include/avr/power.h **** 
 607:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 609:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 610:/usr/lib/avr/include/avr/power.h **** #endif
 611:/usr/lib/avr/include/avr/power.h **** 
 612:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 613:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 614:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 615:/usr/lib/avr/include/avr/power.h **** #endif
 616:/usr/lib/avr/include/avr/power.h **** 
 617:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 618:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 619:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 620:/usr/lib/avr/include/avr/power.h **** #endif
 621:/usr/lib/avr/include/avr/power.h **** 
 622:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 625:/usr/lib/avr/include/avr/power.h **** #endif
 626:/usr/lib/avr/include/avr/power.h **** 
 627:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 628:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 629:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 630:/usr/lib/avr/include/avr/power.h **** #endif
 631:/usr/lib/avr/include/avr/power.h **** 
 632:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 633:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 634:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 635:/usr/lib/avr/include/avr/power.h **** #endif
 636:/usr/lib/avr/include/avr/power.h **** 
 637:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 638:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 639:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 640:/usr/lib/avr/include/avr/power.h **** #endif
 641:/usr/lib/avr/include/avr/power.h **** 
 642:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCO)
 643:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 644:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 645:/usr/lib/avr/include/avr/power.h **** #endif
 646:/usr/lib/avr/include/avr/power.h **** 
 647:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 648:/usr/lib/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 649:/usr/lib/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 650:/usr/lib/avr/include/avr/power.h **** #endif
 651:/usr/lib/avr/include/avr/power.h **** 
 652:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 653:/usr/lib/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 654:/usr/lib/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 655:/usr/lib/avr/include/avr/power.h **** #endif
 656:/usr/lib/avr/include/avr/power.h **** 
 657:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 658:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 659:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 660:/usr/lib/avr/include/avr/power.h **** #endif
 661:/usr/lib/avr/include/avr/power.h **** 
 662:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 663:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))
 664:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))
 665:/usr/lib/avr/include/avr/power.h **** #endif
 666:/usr/lib/avr/include/avr/power.h **** 
 667:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFRS)
 668:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_enable()             (PRR0 &= (uint8_t)~(1 << PRLFRS))
 669:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_disable()            (PRR0 |= (uint8_t)(1 << PRLFRS))
 670:/usr/lib/avr/include/avr/power.h **** #endif
 671:/usr/lib/avr/include/avr/power.h **** 
 672:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 673:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 674:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 675:/usr/lib/avr/include/avr/power.h **** #endif
 676:/usr/lib/avr/include/avr/power.h **** 
 677:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 678:/usr/lib/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 679:/usr/lib/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 680:/usr/lib/avr/include/avr/power.h **** #endif
 681:/usr/lib/avr/include/avr/power.h **** 
 682:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 683:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 684:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 685:/usr/lib/avr/include/avr/power.h **** #endif
 686:/usr/lib/avr/include/avr/power.h **** 
 687:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 688:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 689:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 690:/usr/lib/avr/include/avr/power.h **** #endif
 691:/usr/lib/avr/include/avr/power.h **** 
 692:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 693:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 694:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 695:/usr/lib/avr/include/avr/power.h **** #endif
 696:/usr/lib/avr/include/avr/power.h **** 
 697:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 698:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 699:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 700:/usr/lib/avr/include/avr/power.h **** #endif
 701:/usr/lib/avr/include/avr/power.h **** 
 702:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 704:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 705:/usr/lib/avr/include/avr/power.h **** #endif
 706:/usr/lib/avr/include/avr/power.h **** 
 707:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 709:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 710:/usr/lib/avr/include/avr/power.h **** #endif
 711:/usr/lib/avr/include/avr/power.h **** 
 712:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 713:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 714:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 715:/usr/lib/avr/include/avr/power.h **** #endif
 716:/usr/lib/avr/include/avr/power.h **** 
 717:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 718:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 719:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 720:/usr/lib/avr/include/avr/power.h **** #endif
 721:/usr/lib/avr/include/avr/power.h **** 
 722:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 723:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 724:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 725:/usr/lib/avr/include/avr/power.h **** #endif
 726:/usr/lib/avr/include/avr/power.h **** 
 727:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 728:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 729:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 730:/usr/lib/avr/include/avr/power.h **** #endif
 731:/usr/lib/avr/include/avr/power.h **** 
 732:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 733:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 734:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 735:/usr/lib/avr/include/avr/power.h **** #endif
 736:/usr/lib/avr/include/avr/power.h **** 
 737:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI1)
 738:/usr/lib/avr/include/avr/power.h **** #define power_twi1_enable()             (PRR0 &= (uint8_t)~(1 << PRTWI1))
 739:/usr/lib/avr/include/avr/power.h **** #define power_twi1_disable()            (PRR0 |= (uint8_t)(1 << PRTWI1))
 740:/usr/lib/avr/include/avr/power.h **** #endif
 741:/usr/lib/avr/include/avr/power.h **** 
 742:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 743:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 744:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 745:/usr/lib/avr/include/avr/power.h **** #endif
 746:/usr/lib/avr/include/avr/power.h **** 
 747:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 748:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 749:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 750:/usr/lib/avr/include/avr/power.h **** #endif
 751:/usr/lib/avr/include/avr/power.h **** 
 752:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 753:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 754:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 755:/usr/lib/avr/include/avr/power.h **** #endif
 756:/usr/lib/avr/include/avr/power.h **** 
 757:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 758:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 759:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 760:/usr/lib/avr/include/avr/power.h **** #endif
 761:/usr/lib/avr/include/avr/power.h **** 
 762:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 763:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 764:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 765:/usr/lib/avr/include/avr/power.h **** #endif
 766:/usr/lib/avr/include/avr/power.h **** 
 767:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 768:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 769:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 770:/usr/lib/avr/include/avr/power.h **** #endif
 771:/usr/lib/avr/include/avr/power.h **** 
 772:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 773:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 774:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 775:/usr/lib/avr/include/avr/power.h **** #endif
 776:/usr/lib/avr/include/avr/power.h **** 
 777:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 778:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 779:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 780:/usr/lib/avr/include/avr/power.h **** #endif
 781:/usr/lib/avr/include/avr/power.h **** 
 782:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 783:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 784:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 785:/usr/lib/avr/include/avr/power.h **** #endif
 786:/usr/lib/avr/include/avr/power.h **** 
 787:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 788:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 789:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 790:/usr/lib/avr/include/avr/power.h **** #endif
 791:/usr/lib/avr/include/avr/power.h **** 
 792:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFPH)
 793:/usr/lib/avr/include/avr/power.h **** #define power_lfph_enable()             (PRR1 &= (uint8_t)~(1 << PRLFPH))
 794:/usr/lib/avr/include/avr/power.h **** #define power_lfph_disable()            (PRR1 |= (uint8_t)(1 << PRLFPH))
 795:/usr/lib/avr/include/avr/power.h **** #endif
 796:/usr/lib/avr/include/avr/power.h **** 
 797:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 798:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 799:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 800:/usr/lib/avr/include/avr/power.h **** #endif
 801:/usr/lib/avr/include/avr/power.h **** 
 802:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFTP)
 803:/usr/lib/avr/include/avr/power.h **** #define power_lftp_enable()             (PRR1 &= (uint8_t)~(1 << PRLFTP))
 804:/usr/lib/avr/include/avr/power.h **** #define power_lftp_disable()            (PRR1 |= (uint8_t)(1 << PRLFTP))
 805:/usr/lib/avr/include/avr/power.h **** #endif
 806:/usr/lib/avr/include/avr/power.h **** 
 807:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 808:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 809:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 810:/usr/lib/avr/include/avr/power.h **** #endif
 811:/usr/lib/avr/include/avr/power.h **** 
 812:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSPI)
 813:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR1 &= (uint8_t)~(1 << PRSPI))
 814:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR1 |= (uint8_t)(1 << PRSPI))
 815:/usr/lib/avr/include/avr/power.h **** #endif
 816:/usr/lib/avr/include/avr/power.h **** 
 817:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 818:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 819:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 820:/usr/lib/avr/include/avr/power.h **** #endif
 821:/usr/lib/avr/include/avr/power.h **** 
 822:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 824:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 825:/usr/lib/avr/include/avr/power.h **** #endif
 826:/usr/lib/avr/include/avr/power.h **** 
 827:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 828:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 829:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 830:/usr/lib/avr/include/avr/power.h **** #endif
 831:/usr/lib/avr/include/avr/power.h **** 
 832:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 833:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 834:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 835:/usr/lib/avr/include/avr/power.h **** #endif
 836:/usr/lib/avr/include/avr/power.h **** 
 837:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 838:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 839:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 840:/usr/lib/avr/include/avr/power.h **** #endif
 841:/usr/lib/avr/include/avr/power.h **** 
 842:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 843:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 844:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 845:/usr/lib/avr/include/avr/power.h **** #endif
 846:/usr/lib/avr/include/avr/power.h **** 
 847:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 848:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 849:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 850:/usr/lib/avr/include/avr/power.h **** #endif
 851:/usr/lib/avr/include/avr/power.h **** 
 852:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 853:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 854:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 855:/usr/lib/avr/include/avr/power.h **** #endif
 856:/usr/lib/avr/include/avr/power.h **** 
 857:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 858:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 859:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 860:/usr/lib/avr/include/avr/power.h **** #endif
 861:/usr/lib/avr/include/avr/power.h **** 
 862:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 863:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 864:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 865:/usr/lib/avr/include/avr/power.h **** #endif
 866:/usr/lib/avr/include/avr/power.h **** 
 867:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 868:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 869:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 870:/usr/lib/avr/include/avr/power.h **** #endif
 871:/usr/lib/avr/include/avr/power.h **** 
 872:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART3)
 873:/usr/lib/avr/include/avr/power.h **** #define power_usart3_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART3))
 874:/usr/lib/avr/include/avr/power.h **** #define power_usart3_disable()          (PRR1 |= (uint8_t)(1 << PRUSART3))
 875:/usr/lib/avr/include/avr/power.h **** #endif
 876:/usr/lib/avr/include/avr/power.h **** 
 877:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 878:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 879:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 880:/usr/lib/avr/include/avr/power.h **** #endif
 881:/usr/lib/avr/include/avr/power.h **** 
 882:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 883:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 884:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 885:/usr/lib/avr/include/avr/power.h **** #endif
 886:/usr/lib/avr/include/avr/power.h **** 
 887:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 888:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 889:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 890:/usr/lib/avr/include/avr/power.h **** #endif
 891:/usr/lib/avr/include/avr/power.h **** 
 892:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 893:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 894:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 895:/usr/lib/avr/include/avr/power.h **** #endif
 896:/usr/lib/avr/include/avr/power.h **** 
 897:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 898:/usr/lib/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 899:/usr/lib/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 900:/usr/lib/avr/include/avr/power.h **** #endif
 901:/usr/lib/avr/include/avr/power.h **** 
 902:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 903:/usr/lib/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 904:/usr/lib/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 905:/usr/lib/avr/include/avr/power.h **** #endif
 906:/usr/lib/avr/include/avr/power.h **** 
 907:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 908:/usr/lib/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 909:/usr/lib/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 910:/usr/lib/avr/include/avr/power.h **** #endif
 911:/usr/lib/avr/include/avr/power.h **** 
 912:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 913:/usr/lib/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 914:/usr/lib/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 915:/usr/lib/avr/include/avr/power.h **** #endif
 916:/usr/lib/avr/include/avr/power.h **** 
 917:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 918:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 919:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 920:/usr/lib/avr/include/avr/power.h **** #endif
 921:/usr/lib/avr/include/avr/power.h **** 
 922:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 923:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 924:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 925:/usr/lib/avr/include/avr/power.h **** #endif
 926:/usr/lib/avr/include/avr/power.h **** 
 927:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSPI2)
 928:/usr/lib/avr/include/avr/power.h **** #define power_spi2_enable()             (PRR2 &= (uint8_t)~(1 << PRSPI2))
 929:/usr/lib/avr/include/avr/power.h **** #define power_spi2_disable()            (PRR2 |= (uint8_t)(1 << PRSPI2))
 930:/usr/lib/avr/include/avr/power.h **** #endif
 931:/usr/lib/avr/include/avr/power.h **** 
 932:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 933:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 934:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 935:/usr/lib/avr/include/avr/power.h **** #endif
 936:/usr/lib/avr/include/avr/power.h **** 
 937:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 938:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 939:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 940:/usr/lib/avr/include/avr/power.h **** #endif
 941:/usr/lib/avr/include/avr/power.h **** 
 942:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTWI2)
 943:/usr/lib/avr/include/avr/power.h **** #define power_twi2_enable()             (PRR2 &= (uint8_t)~(1 << PRTWI2))
 944:/usr/lib/avr/include/avr/power.h **** #define power_twi2_disable()            (PRR2 |= (uint8_t)(1 << PRTWI2))
 945:/usr/lib/avr/include/avr/power.h **** #endif
 946:/usr/lib/avr/include/avr/power.h **** 
 947:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 948:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 949:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 950:/usr/lib/avr/include/avr/power.h **** #endif
 951:/usr/lib/avr/include/avr/power.h **** 
 952:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 953:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 954:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 955:/usr/lib/avr/include/avr/power.h **** #endif
 956:/usr/lib/avr/include/avr/power.h **** 
 957:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 958:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 959:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 960:/usr/lib/avr/include/avr/power.h **** #endif
 961:/usr/lib/avr/include/avr/power.h **** 
 962:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 963:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 964:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 965:/usr/lib/avr/include/avr/power.h **** #endif
 966:/usr/lib/avr/include/avr/power.h **** 
 967:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 968:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 969:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 970:/usr/lib/avr/include/avr/power.h **** #endif
 971:/usr/lib/avr/include/avr/power.h **** 
 972:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 973:/usr/lib/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 974:/usr/lib/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 975:/usr/lib/avr/include/avr/power.h **** #endif
 976:/usr/lib/avr/include/avr/power.h **** 
 977:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 978:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 979:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 980:/usr/lib/avr/include/avr/power.h **** #endif
 981:/usr/lib/avr/include/avr/power.h **** 
 982:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 983:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 984:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 985:/usr/lib/avr/include/avr/power.h **** #endif
 986:/usr/lib/avr/include/avr/power.h **** 
 987:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 988:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 989:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 990:/usr/lib/avr/include/avr/power.h **** #endif
 991:/usr/lib/avr/include/avr/power.h **** 
 992:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 993:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 994:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 995:/usr/lib/avr/include/avr/power.h **** #endif
 996:/usr/lib/avr/include/avr/power.h **** 
 997:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 998:/usr/lib/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 999:/usr/lib/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
1000:/usr/lib/avr/include/avr/power.h **** #endif
1001:/usr/lib/avr/include/avr/power.h **** 
1002:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
1003:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
1004:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
1005:/usr/lib/avr/include/avr/power.h **** #endif
1006:/usr/lib/avr/include/avr/power.h **** 
1007:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
1008:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
1009:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
1010:/usr/lib/avr/include/avr/power.h **** #endif
1011:/usr/lib/avr/include/avr/power.h **** 
1012:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
1013:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
1014:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
1015:/usr/lib/avr/include/avr/power.h **** #endif
1016:/usr/lib/avr/include/avr/power.h **** 
1017:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
1018:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
1019:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
1020:/usr/lib/avr/include/avr/power.h **** #endif
1021:/usr/lib/avr/include/avr/power.h **** 
1022:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
1023:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
1024:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
1025:/usr/lib/avr/include/avr/power.h **** #endif
1026:/usr/lib/avr/include/avr/power.h **** 
1027:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
1028:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
1029:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
1030:/usr/lib/avr/include/avr/power.h **** #endif
1031:/usr/lib/avr/include/avr/power.h **** 
1032:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
1033:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
1034:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
1035:/usr/lib/avr/include/avr/power.h **** #endif
1036:/usr/lib/avr/include/avr/power.h **** 
1037:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
1038:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
1039:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
1040:/usr/lib/avr/include/avr/power.h **** #endif
1041:/usr/lib/avr/include/avr/power.h **** 
1042:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1043:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1044:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1045:/usr/lib/avr/include/avr/power.h **** #endif
1046:/usr/lib/avr/include/avr/power.h **** 
1047:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1048:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1049:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1050:/usr/lib/avr/include/avr/power.h **** #endif
1051:/usr/lib/avr/include/avr/power.h **** 
1052:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1053:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1054:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1055:/usr/lib/avr/include/avr/power.h **** #endif
1056:/usr/lib/avr/include/avr/power.h **** 
1057:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1058:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1059:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1060:/usr/lib/avr/include/avr/power.h **** #endif
1061:/usr/lib/avr/include/avr/power.h **** 
1062:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1063:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1064:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1065:/usr/lib/avr/include/avr/power.h **** #endif
1066:/usr/lib/avr/include/avr/power.h **** 
1067:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1068:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1069:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1070:/usr/lib/avr/include/avr/power.h **** #endif
1071:/usr/lib/avr/include/avr/power.h **** 
1072:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1073:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1074:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1075:/usr/lib/avr/include/avr/power.h **** #endif
1076:/usr/lib/avr/include/avr/power.h **** 
1077:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1078:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1079:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1080:/usr/lib/avr/include/avr/power.h **** #endif
1081:/usr/lib/avr/include/avr/power.h **** 
1082:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1083:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1084:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1085:/usr/lib/avr/include/avr/power.h **** #endif
1086:/usr/lib/avr/include/avr/power.h **** 
1087:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1088:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1089:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1090:/usr/lib/avr/include/avr/power.h **** #endif
1091:/usr/lib/avr/include/avr/power.h **** 
1092:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1093:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1094:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1095:/usr/lib/avr/include/avr/power.h **** #endif
1096:/usr/lib/avr/include/avr/power.h **** 
1097:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1098:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1099:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1100:/usr/lib/avr/include/avr/power.h **** #endif
1101:/usr/lib/avr/include/avr/power.h **** 
1102:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1103:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1104:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1105:/usr/lib/avr/include/avr/power.h **** #endif
1106:/usr/lib/avr/include/avr/power.h **** 
1107:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1108:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1109:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1110:/usr/lib/avr/include/avr/power.h **** #endif
1111:/usr/lib/avr/include/avr/power.h **** 
1112:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1113:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1114:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1115:/usr/lib/avr/include/avr/power.h **** #endif
1116:/usr/lib/avr/include/avr/power.h **** 
1117:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1118:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1119:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1120:/usr/lib/avr/include/avr/power.h **** #endif
1121:/usr/lib/avr/include/avr/power.h **** 
1122:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1123:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1124:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1125:/usr/lib/avr/include/avr/power.h **** #endif
1126:/usr/lib/avr/include/avr/power.h **** 
1127:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1128:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1129:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1130:/usr/lib/avr/include/avr/power.h **** #endif
1131:/usr/lib/avr/include/avr/power.h **** 
1132:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1133:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1134:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1135:/usr/lib/avr/include/avr/power.h **** #endif
1136:/usr/lib/avr/include/avr/power.h **** 
1137:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1138:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1139:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1140:/usr/lib/avr/include/avr/power.h **** #endif
1141:/usr/lib/avr/include/avr/power.h **** 
1142:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1143:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1144:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1145:/usr/lib/avr/include/avr/power.h **** #endif
1146:/usr/lib/avr/include/avr/power.h **** 
1147:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1148:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1149:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1150:/usr/lib/avr/include/avr/power.h **** #endif
1151:/usr/lib/avr/include/avr/power.h **** 
1152:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1153:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1154:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1155:/usr/lib/avr/include/avr/power.h **** #endif
1156:/usr/lib/avr/include/avr/power.h **** 
1157:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1158:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1159:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1160:/usr/lib/avr/include/avr/power.h **** #endif
1161:/usr/lib/avr/include/avr/power.h **** 
1162:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1163:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1164:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1165:/usr/lib/avr/include/avr/power.h **** #endif
1166:/usr/lib/avr/include/avr/power.h **** 
1167:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1168:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1169:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1170:/usr/lib/avr/include/avr/power.h **** #endif
1171:/usr/lib/avr/include/avr/power.h **** 
1172:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1173:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1174:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1175:/usr/lib/avr/include/avr/power.h **** #endif
1176:/usr/lib/avr/include/avr/power.h **** 
1177:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1178:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1179:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1180:/usr/lib/avr/include/avr/power.h **** #endif
1181:/usr/lib/avr/include/avr/power.h **** 
1182:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1183:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1184:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1185:/usr/lib/avr/include/avr/power.h **** #endif
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** static __inline void
1188:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1189:/usr/lib/avr/include/avr/power.h **** __power_all_enable()
1190:/usr/lib/avr/include/avr/power.h **** {
1191:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1192:/usr/lib/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1193:/usr/lib/avr/include/avr/power.h **** #endif
1194:/usr/lib/avr/include/avr/power.h **** 
1195:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1196:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1197:/usr/lib/avr/include/avr/power.h **** #endif
1198:/usr/lib/avr/include/avr/power.h **** 
1199:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1200:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1201:/usr/lib/avr/include/avr/power.h **** #endif
1202:/usr/lib/avr/include/avr/power.h **** 
1203:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1204:/usr/lib/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1205:/usr/lib/avr/include/avr/power.h **** #endif
1206:/usr/lib/avr/include/avr/power.h **** 
1207:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1208:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1209:/usr/lib/avr/include/avr/power.h **** #endif
1210:/usr/lib/avr/include/avr/power.h **** 
1211:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1212:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1213:/usr/lib/avr/include/avr/power.h **** #endif
1214:/usr/lib/avr/include/avr/power.h **** 
1215:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1216:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1217:/usr/lib/avr/include/avr/power.h **** #endif
1218:/usr/lib/avr/include/avr/power.h **** 
1219:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1220:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1221:/usr/lib/avr/include/avr/power.h **** #endif
1222:/usr/lib/avr/include/avr/power.h **** 
1223:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1224:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1225:/usr/lib/avr/include/avr/power.h **** #endif
1226:/usr/lib/avr/include/avr/power.h **** 
1227:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1228:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1229:/usr/lib/avr/include/avr/power.h **** #endif
1230:/usr/lib/avr/include/avr/power.h **** 
1231:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1232:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1233:/usr/lib/avr/include/avr/power.h **** #endif
1234:/usr/lib/avr/include/avr/power.h **** }
1235:/usr/lib/avr/include/avr/power.h **** 
1236:/usr/lib/avr/include/avr/power.h **** static __inline void
1237:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1238:/usr/lib/avr/include/avr/power.h **** __power_all_disable()
1239:/usr/lib/avr/include/avr/power.h **** {
1240:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1241:/usr/lib/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1242:/usr/lib/avr/include/avr/power.h **** #endif
1243:/usr/lib/avr/include/avr/power.h **** 
1244:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1245:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1246:/usr/lib/avr/include/avr/power.h **** #endif
1247:/usr/lib/avr/include/avr/power.h **** 
1248:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1249:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1250:/usr/lib/avr/include/avr/power.h **** #endif
1251:/usr/lib/avr/include/avr/power.h **** 
1252:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1253:/usr/lib/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1254:/usr/lib/avr/include/avr/power.h **** #endif
1255:/usr/lib/avr/include/avr/power.h **** 
1256:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1257:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1258:/usr/lib/avr/include/avr/power.h **** #endif
1259:/usr/lib/avr/include/avr/power.h **** 
1260:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1261:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1262:/usr/lib/avr/include/avr/power.h **** #endif
1263:/usr/lib/avr/include/avr/power.h **** 
1264:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1265:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1266:/usr/lib/avr/include/avr/power.h **** #endif
1267:/usr/lib/avr/include/avr/power.h **** 
1268:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1269:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1270:/usr/lib/avr/include/avr/power.h **** #endif
1271:/usr/lib/avr/include/avr/power.h **** 
1272:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1273:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1274:/usr/lib/avr/include/avr/power.h **** #endif
1275:/usr/lib/avr/include/avr/power.h **** 
1276:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1277:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1278:/usr/lib/avr/include/avr/power.h **** #endif
1279:/usr/lib/avr/include/avr/power.h **** 
1280:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1281:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1282:/usr/lib/avr/include/avr/power.h **** #endif
1283:/usr/lib/avr/include/avr/power.h **** }
1284:/usr/lib/avr/include/avr/power.h **** 
1285:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1286:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_enable
1287:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1288:/usr/lib/avr/include/avr/power.h **** #endif
1289:/usr/lib/avr/include/avr/power.h **** 
1290:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_disable
1291:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1292:/usr/lib/avr/include/avr/power.h **** #endif
1293:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1294:/usr/lib/avr/include/avr/power.h **** 
1295:/usr/lib/avr/include/avr/power.h **** 
1296:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1297:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1298:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1299:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1300:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1301:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1302:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1303:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1304:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1305:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1310:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1311:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1312:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1313:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1314:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1315:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1316:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1317:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA6617C__) \
1318:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA664251__) \
1319:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1320:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1321:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1323:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1324:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1325:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1326:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1327:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1328:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1329:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1330:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1331:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1332:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1333:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1334:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1335:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1336:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1337:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1338:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PB__) \
1339:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1340:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1341:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1342:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1343:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16M1__) \
1344:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1345:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PB__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325P__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250P__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328PB__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
1372:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1373:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1374:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1375:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1376:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1377:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1378:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1379:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1380:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1381:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PB__) \
1382:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1383:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1384:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1385:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1386:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1387:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1388:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1389:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1390:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1391:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1392:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1393:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1394:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1395:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1396:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1397:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__) \
1398:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1399:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1400:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1401:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PB__) \
1402:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1403:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1404:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1405:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1406:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1407:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1408:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1409:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1410:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1411:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1412:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1413:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__) \
1414:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__) \
1415:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1416:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1417:/usr/lib/avr/include/avr/power.h **** 
1418:/usr/lib/avr/include/avr/power.h **** 
1419:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1420:/usr/lib/avr/include/avr/power.h **** 
1421:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1422:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1423:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low.
1424:/usr/lib/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1425:/usr/lib/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1426:/usr/lib/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1427:/usr/lib/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1428:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1429:/usr/lib/avr/include/avr/power.h **** 
1430:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1431:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1432:/usr/lib/avr/include/avr/power.h **** macros are not available.
1433:/usr/lib/avr/include/avr/power.h **** */
1434:/usr/lib/avr/include/avr/power.h **** 
1435:/usr/lib/avr/include/avr/power.h **** 
1436:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1437:/usr/lib/avr/include/avr/power.h **** \code 
1438:/usr/lib/avr/include/avr/power.h **** typedef enum
1439:/usr/lib/avr/include/avr/power.h **** {
1440:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1441:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1442:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1443:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1444:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1445:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1446:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1447:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1448:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1449:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1450:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1451:/usr/lib/avr/include/avr/power.h **** \endcode
1452:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1453:/usr/lib/avr/include/avr/power.h **** System Clock Prescale Register.
1454:/usr/lib/avr/include/avr/power.h **** 
1455:/usr/lib/avr/include/avr/power.h **** \code
1456:/usr/lib/avr/include/avr/power.h **** typedef enum
1457:/usr/lib/avr/include/avr/power.h **** {
1458:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 1,
1459:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 2,
1460:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 4,
1461:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 8,
1462:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 16,
1463:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 32,
1464:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 64,
1465:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 128
1466:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1467:/usr/lib/avr/include/avr/power.h **** \endcode
1468:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1469:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1470:/usr/lib/avr/include/avr/power.h **** 
1471:/usr/lib/avr/include/avr/power.h **** */
1472:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1473:/usr/lib/avr/include/avr/power.h **** typedef enum
1474:/usr/lib/avr/include/avr/power.h **** {
1475:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1476:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1477:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1478:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1479:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1480:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1481:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1482:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1483:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1484:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1485:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1486:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1487:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1488:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1489:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1490:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__)
1491:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1492:/usr/lib/avr/include/avr/power.h **** #endif
1493:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1494:/usr/lib/avr/include/avr/power.h **** 
1495:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1496:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1497:/usr/lib/avr/include/avr/power.h **** 
1498:/usr/lib/avr/include/avr/power.h **** /**
1499:/usr/lib/avr/include/avr/power.h ****    \ingroup avr_power
1500:/usr/lib/avr/include/avr/power.h ****    \fn clock_prescale_set(clock_div_t x)
1501:/usr/lib/avr/include/avr/power.h **** 
1502:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1503:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1504:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1505:/usr/lib/avr/include/avr/power.h **** 
1506:/usr/lib/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1507:/usr/lib/avr/include/avr/power.h **** 
1508:/usr/lib/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1509:/usr/lib/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1510:/usr/lib/avr/include/avr/power.h **** */
1511:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1512:/usr/lib/avr/include/avr/power.h **** {
1513:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1514:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 2050               		.loc 5 1514 0
 2051 0a0c 90E0      		ldi r25,0
 2052 0a0e 80E8      		ldi r24,lo8(-128)
 2053               	/* #APP */
 2054               	 ;  1514 "/usr/lib/avr/include/avr/power.h" 1
 2055 0a10 0FB6      		in __tmp_reg__,__SREG__
 2056 0a12 F894      		cli
 2057 0a14 8093 6100 		sts 97, r24
 2058 0a18 9093 6100 		sts 97, r25
 2059 0a1c 0FBE      		out __SREG__, __tmp_reg__
 2060               	 ;  0 "" 2
 2061               	.LVL86:
 2062               	/* #NOAPP */
 2063               	.LBE100:
 2064               	.LBE99:
 2065               	.LBB101:
 2066               	.LBB102:
 187:/usr/lib/avr/include/util/delay.h **** 
 2067               		.loc 3 187 0
 2068 0a1e 2FEF      		ldi r18,lo8(319999)
 2069 0a20 81EE      		ldi r24,hi8(319999)
 2070 0a22 94E0      		ldi r25,hlo8(319999)
 2071 0a24 2150      	1:	subi r18,1
 2072 0a26 8040      		sbci r24,0
 2073 0a28 9040      		sbci r25,0
 2074 0a2a 01F4      		brne 1b
 2075 0a2c 00C0      		rjmp .
 2076 0a2e 0000      		nop
 2077               	.LVL87:
 2078               	.LBE102:
 2079               	.LBE101:
 817:main.c        **** 	clock_prescale_set(clock_div_1);
 818:main.c        **** 	 _delay_ms(100);
 819:main.c        **** 	I2C_init(I2C_ADDR);
 2080               		.loc 4 819 0
 2081 0a30 8AE2      		ldi r24,lo8(42)
 2082 0a32 0E94 0000 		call I2C_init
 2083               	.LVL88:
 820:main.c        **** 	PCICR |= _BV(PCIE0);		 // enable pin change interrupt for PB0 (rpm)
 2084               		.loc 4 820 0
 2085 0a36 E8E6      		ldi r30,lo8(104)
 2086 0a38 F0E0      		ldi r31,0
 2087 0a3a 8081      		ld r24,Z
 2088 0a3c 8160      		ori r24,lo8(1)
 2089 0a3e 8083      		st Z,r24
 821:main.c        **** 	PCMSK0 |= (1 << PCINT4);
 2090               		.loc 4 821 0
 2091 0a40 EBE6      		ldi r30,lo8(107)
 2092 0a42 F0E0      		ldi r31,0
 2093 0a44 8081      		ld r24,Z
 2094 0a46 8061      		ori r24,lo8(16)
 2095 0a48 8083      		st Z,r24
 822:main.c        **** 	sei();
 2096               		.loc 4 822 0
 2097               	/* #APP */
 2098               	 ;  822 "main.c" 1
 2099 0a4a 7894      		sei
 2100               	 ;  0 "" 2
 823:main.c        **** 
 824:main.c        **** 	led[0].r = 255;
 2101               		.loc 4 824 0
 2102               	/* #NOAPP */
 2103 0a4c C0E0      		ldi r28,lo8(led)
 2104 0a4e D0E0      		ldi r29,hi8(led)
 2105 0a50 8FEF      		ldi r24,lo8(-1)
 2106 0a52 8983      		std Y+1,r24
 825:main.c        **** 	led[0].g = 255;
 2107               		.loc 4 825 0
 2108 0a54 8883      		st Y,r24
 826:main.c        **** 	led[0].b = 255;
 2109               		.loc 4 826 0
 2110 0a56 8A83      		std Y+2,r24
 827:main.c        **** 
 828:main.c        **** 	led[1].r = 255;
 2111               		.loc 4 828 0
 2112 0a58 8C83      		std Y+4,r24
 829:main.c        **** 	led[1].g = 255;
 2113               		.loc 4 829 0
 2114 0a5a 8B83      		std Y+3,r24
 830:main.c        **** 	led[1].b = 255;
 2115               		.loc 4 830 0
 2116 0a5c 8D83      		std Y+5,r24
 831:main.c        **** 
 832:main.c        **** 	ws2812_setleds(led,2);
 2117               		.loc 4 832 0
 2118 0a5e 62E0      		ldi r22,lo8(2)
 2119 0a60 70E0      		ldi r23,0
 2120 0a62 CE01      		movw r24,r28
 2121 0a64 0E94 0000 		call ws2812_setleds
 2122               	.LVL89:
 833:main.c        **** 
 834:main.c        **** 	setup_lcd();
 2123               		.loc 4 834 0
 2124 0a68 0E94 0000 		call setup_lcd
 2125               	.LVL90:
 835:main.c        **** 
 836:main.c        **** 	init_backlight();
 2126               		.loc 4 836 0
 2127 0a6c 0E94 0000 		call init_backlight
 2128               	.LVL91:
 837:main.c        **** 
 838:main.c        **** 	led[0].r = 0;
 2129               		.loc 4 838 0
 2130 0a70 1982      		std Y+1,__zero_reg__
 839:main.c        **** 	led[0].g = 0;
 2131               		.loc 4 839 0
 2132 0a72 1882      		st Y,__zero_reg__
 840:main.c        **** 	led[0].b = 0;
 2133               		.loc 4 840 0
 2134 0a74 1A82      		std Y+2,__zero_reg__
 841:main.c        **** 
 842:main.c        **** 	led[1].r = 0;
 2135               		.loc 4 842 0
 2136 0a76 1C82      		std Y+4,__zero_reg__
 843:main.c        **** 	led[1].g = 0;
 2137               		.loc 4 843 0
 2138 0a78 1B82      		std Y+3,__zero_reg__
 844:main.c        **** 	led[1].b = 0;
 2139               		.loc 4 844 0
 2140 0a7a 1D82      		std Y+5,__zero_reg__
 845:main.c        **** 
 846:main.c        **** 	ws2812_setleds(led,2);
 2141               		.loc 4 846 0
 2142 0a7c 62E0      		ldi r22,lo8(2)
 2143 0a7e 70E0      		ldi r23,0
 2144 0a80 CE01      		movw r24,r28
 2145 0a82 0E94 0000 		call ws2812_setleds
 2146               	.LVL92:
 847:main.c        **** 
 848:main.c        **** 	OCR0A = 210;
 2147               		.loc 4 848 0
 2148 0a86 82ED      		ldi r24,lo8(-46)
 2149 0a88 87BD      		out 0x27,r24
 2150               	.LVL93:
 2151               	.LBB103:
 2152               	.LBB104:
 2153               		.file 6 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2154               		.loc 6 473 0
 2155 0a8a 99E2      		ldi r25,lo8(41)
 2156 0a8c 88E1      		ldi r24,lo8(24)
 2157               	/* #APP */
 2158               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 2159 0a8e 0FB6      		in __tmp_reg__,__SREG__
 2160 0a90 F894      		cli
 2161 0a92 A895      		wdr
 2162 0a94 8093 6000 		sts 96, r24
 2163 0a98 0FBE      		out __SREG__,__tmp_reg__
 2164 0a9a 9093 6000 		sts 96, r25
 2165               	 	
 2166               	 ;  0 "" 2
 2167               	.LVL94:
 2168               	/* epilogue start */
 2169               	/* #NOAPP */
 2170               	.LBE104:
 2171               	.LBE103:
 849:main.c        **** 	wdt_enable(WDTO_8S);
 850:main.c        **** 
 851:main.c        **** }
 2172               		.loc 4 851 0
 2173 0a9e DF91      		pop r29
 2174 0aa0 CF91      		pop r28
 2175 0aa2 0895      		ret
 2176               		.cfi_endproc
 2177               	.LFE36:
 2179               	.global	__floatunsisf
 2180               	.global	__mulsf3
 2181               	.global	__fixunssfsi
 2182               		.section	.text.startup,"ax",@progbits
 2183               	.global	main
 2185               	main:
 2186               	.LFB37:
 852:main.c        **** 
 853:main.c        **** 
 854:main.c        **** int main(void)
 855:main.c        **** {
 2187               		.loc 4 855 0
 2188               		.cfi_startproc
 2189               	/* prologue: function */
 2190               	/* frame size = 0 */
 2191               	/* stack size = 0 */
 2192               	.L__stack_usage = 0
 2193               	.LVL95:
 856:main.c        **** 	uint8_t adcselect = 0;
 857:main.c        **** 	setup();
 2194               		.loc 4 857 0
 2195 0000 0E94 0000 		call setup
 2196               	.LVL96:
 856:main.c        **** 	uint8_t adcselect = 0;
 2197               		.loc 4 856 0
 2198 0004 10E0      		ldi r17,0
 858:main.c        **** 
 859:main.c        **** 	while(1)
 860:main.c        **** 	{
 861:main.c        **** 
 862:main.c        **** 		if (jumptobootloader > 0)
 863:main.c        **** 		{
 864:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 2199               		.loc 4 864 0
 2200 0006 01ED      		ldi r16,lo8(-47)
 865:main.c        **** 			cli();
 866:main.c        **** 			wdt_disable();
 867:main.c        **** 			UDCON = 1;
 2201               		.loc 4 867 0
 2202 0008 EE24      		clr r14
 2203 000a E394      		inc r14
 868:main.c        **** 			USBCON = (1<<FRZCLK);  // disable USB
 2204               		.loc 4 868 0
 2205 000c 30E2      		ldi r19,lo8(32)
 2206 000e D32E      		mov r13,r19
 869:main.c        **** 			UCSR1B = 0;
 870:main.c        **** 			_delay_ms(50);
 871:main.c        ****     			EIMSK = 0; PCICR = 0; SPCR = 0; ACSR = 0; EECR = 0; ADCSRA = 0;
 872:main.c        ****     			TIMSK0 = 0; TIMSK1 = 0; TIMSK3 = 0; TIMSK4 = 0; UCSR1B = 0; TWCR = 0;
 873:main.c        ****     			DDRB = 0; DDRC = 0; DDRD = 0; DDRE = 0; DDRF = 0; TWCR = 0;
 874:main.c        ****     			PORTB = 0; PORTC = 0; PORTD = 0; PORTE = 0; PORTF = 0;
 875:main.c        ****     			asm volatile("jmp 0x7000");
 876:main.c        **** 
 877:main.c        **** 
 878:main.c        **** 		}
 879:main.c        **** 
 880:main.c        **** 		if (watchdog == 0x01)
 881:main.c        **** 		{
 882:main.c        **** 
 883:main.c        **** 			if (SCL_LINE)
 884:main.c        **** 			{
 885:main.c        **** 				watchi2c++;
 886:main.c        **** 			}
 887:main.c        **** 			else
 888:main.c        **** 			{
 889:main.c        **** 				watchi2c = 0;led[0].r=0; led[0].g=0;led[0].b=0; ws2812_setleds(led,1);
 890:main.c        **** 			}
 891:main.c        **** 
 892:main.c        **** 			if (watchi2c > 10000) {led[0].r=255; led[0].g=255;led[0].b=0; ws2812_setleds(led,1);}
 2207               		.loc 4 892 0
 2208 0010 FF24      		clr r15
 2209 0012 FA94      		dec r15
 893:main.c        **** 		}
 894:main.c        **** 
 895:main.c        **** 		if (!SDA_LINE) {i2cerror++;}
 896:main.c        **** 
 897:main.c        **** 		if (i2cerror > 200)
 898:main.c        **** 		{
 899:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 900:main.c        **** 			I2C_init(I2C_ADDR);
 901:main.c        **** 			i2cerror = 0;
 902:main.c        **** 			sei();
 903:main.c        **** 		}
 904:main.c        **** 
 905:main.c        **** 		wdt_reset();
 906:main.c        **** 		if (isrtimer > 31250)	 // routine for calculate fan speed - timer is 64khz
 907:main.c        **** 		{						 // 2 signals each turn
 908:main.c        **** 			rpm = fanspin * 30;
 2210               		.loc 4 908 0
 2211 0014 4EE1      		ldi r20,lo8(30)
 2212 0016 C42E      		mov r12,r20
 909:main.c        **** 			fanspin = 0;
 910:main.c        **** 			isrtimer = 0;
 911:main.c        **** 			if (fanlevel == 254) //fan minimal auto
 912:main.c        **** 			{
 913:main.c        **** 				if (rpm > 1950) {OCR0A++;}
 914:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 915:main.c        **** 			}
 916:main.c        **** 		}
 917:main.c        **** 		if (displaychange) {init_backlight(); displaychange = 0;}
 918:main.c        **** 
 919:main.c        **** 		if (changeled)
 920:main.c        **** 		{
 921:main.c        **** 			ws2812_setleds(led,led_position+1);
 922:main.c        **** 			changeled = 0;
 923:main.c        **** 		}
 924:main.c        **** 
 925:main.c        **** 		if (newbllevel != bllevel  && 0 <= newbllevel && newbllevel < 32)
 926:main.c        **** 		{
 927:main.c        **** 
 928:main.c        **** 			if (newbllevel < bllevel)
 929:main.c        **** 			{
 930:main.c        **** 				bllevel--;
 931:main.c        **** 			}
 932:main.c        **** 			else
 933:main.c        **** 			{
 934:main.c        **** 				bllevel++;
 935:main.c        **** 			}
 936:main.c        **** 
 937:main.c        **** 			write_backlight(0b01011000);
 938:main.c        **** 			write_backlight(0b00011111 & bllevel);
 939:main.c        **** 		}
 940:main.c        **** 
 941:main.c        **** 		if (adcselect < 10)
 942:main.c        **** 		{
 943:main.c        **** 			adcselect++;
 944:main.c        **** 		}
 945:main.c        **** 		else
 946:main.c        **** 		{
 947:main.c        **** 			adcselect = 0;
 948:main.c        **** 		}
 949:main.c        **** 
 950:main.c        **** 		switch(adcselect)
 951:main.c        **** 		{
 952:main.c        **** 			case 0: a0 = read_analog(7);  break;
 953:main.c        **** 			case 1: a1 = read_analog(6);  break;
 954:main.c        **** 			case 2: a2 = read_analog(5);  break;
 955:main.c        **** 			case 4: a3 = read_analog(4);  break;
 956:main.c        **** 			case 5: a4 = read_analog(1);  break;
 957:main.c        **** 			case 7: a5 = read_analog(0);  break;
 958:main.c        **** 			case 8: vcc = readVcc();  break;
 959:main.c        **** 			case 10: temp = GetTemp();   break;
 960:main.c        **** 
 961:main.c        **** 			default:			 //read A7 more frequently
 962:main.c        **** 			{
 963:main.c        **** 				a7 = read_analog(9);
 964:main.c        **** 				if (a7 > a7max) a7max = a7;
 965:main.c        **** 				if (a7 < a7min) a7min = a7;
 966:main.c        **** 				a7count++;
 967:main.c        **** 				if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max = 0; a
 2213               		.loc 4 967 0
 2214 0018 C0E0      		ldi r28,0
 2215 001a D4E0      		ldi r29,lo8(4)
 2216               	.LVL97:
 2217               	.L315:
 862:main.c        **** 		{
 2218               		.loc 4 862 0
 2219 001c 8091 0000 		lds r24,jumptobootloader
 2220 0020 8823      		tst r24
 2221 0022 01F4      		brne .+2
 2222 0024 00C0      		rjmp .L316
 864:main.c        **** 			cli();
 2223               		.loc 4 864 0
 2224 0026 0093 BC00 		sts 188,r16
 865:main.c        **** 			wdt_disable();
 2225               		.loc 4 865 0
 2226               	/* #APP */
 2227               	 ;  865 "main.c" 1
 2228 002a F894      		cli
 2229               	 ;  0 "" 2
 2230               	/* #NOAPP */
 2231               	.LBB105:
 2232               	.LBB106:
 474:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 486:/usr/lib/avr/include/avr/wdt.h **** 		);
 487:/usr/lib/avr/include/avr/wdt.h **** 	}
 488:/usr/lib/avr/include/avr/wdt.h **** }
 489:/usr/lib/avr/include/avr/wdt.h **** 
 490:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 491:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/usr/lib/avr/include/avr/wdt.h **** {
 494:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/usr/lib/avr/include/avr/wdt.h **** 	{
 496:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 510:/usr/lib/avr/include/avr/wdt.h **** 		);
 511:/usr/lib/avr/include/avr/wdt.h **** 	}
 512:/usr/lib/avr/include/avr/wdt.h **** 	else
 513:/usr/lib/avr/include/avr/wdt.h **** 	{
 514:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2233               		.loc 6 515 0
 2234               	/* #APP */
 2235               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
 2236 002c 0FB6      		in __tmp_reg__,__SREG__
 2237 002e F894      		cli
 2238 0030 A895      		wdr
 2239 0032 8091 6000 		lds r24,96
 2240 0036 8861      		ori r24,24
 2241 0038 8093 6000 		sts 96,r24
 2242 003c 1092 6000 		sts 96,__zero_reg__
 2243 0040 0FBE      		out __SREG__,__tmp_reg__
 2244               		
 2245               	 ;  0 "" 2
 2246               	/* #NOAPP */
 2247               	.LBE106:
 2248               	.LBE105:
 867:main.c        **** 			USBCON = (1<<FRZCLK);  // disable USB
 2249               		.loc 4 867 0
 2250 0042 E092 E000 		sts 224,r14
 868:main.c        **** 			UCSR1B = 0;
 2251               		.loc 4 868 0
 2252 0046 D092 D800 		sts 216,r13
 869:main.c        **** 			_delay_ms(50);
 2253               		.loc 4 869 0
 2254 004a 1092 C900 		sts 201,__zero_reg__
 2255               	.LVL98:
 2256               	.LBB107:
 2257               	.LBB108:
 187:/usr/lib/avr/include/util/delay.h **** 
 2258               		.loc 3 187 0
 2259 004e 2FEF      		ldi r18,lo8(159999)
 2260 0050 80E7      		ldi r24,hi8(159999)
 2261 0052 92E0      		ldi r25,hlo8(159999)
 2262 0054 2150      	1:	subi r18,1
 2263 0056 8040      		sbci r24,0
 2264 0058 9040      		sbci r25,0
 2265 005a 01F4      		brne 1b
 2266 005c 00C0      		rjmp .
 2267 005e 0000      		nop
 2268               	.LVL99:
 2269               	.LBE108:
 2270               	.LBE107:
 871:main.c        ****     			TIMSK0 = 0; TIMSK1 = 0; TIMSK3 = 0; TIMSK4 = 0; UCSR1B = 0; TWCR = 0;
 2271               		.loc 4 871 0
 2272 0060 1DBA      		out 0x1d,__zero_reg__
 2273 0062 1092 6800 		sts 104,__zero_reg__
 2274 0066 1CBC      		out 0x2c,__zero_reg__
 2275 0068 10BE      		out 0x30,__zero_reg__
 2276 006a 1FBA      		out 0x1f,__zero_reg__
 2277 006c 1092 7A00 		sts 122,__zero_reg__
 872:main.c        ****     			DDRB = 0; DDRC = 0; DDRD = 0; DDRE = 0; DDRF = 0; TWCR = 0;
 2278               		.loc 4 872 0
 2279 0070 1092 6E00 		sts 110,__zero_reg__
 2280 0074 1092 6F00 		sts 111,__zero_reg__
 2281 0078 1092 7100 		sts 113,__zero_reg__
 2282 007c 1092 7200 		sts 114,__zero_reg__
 2283 0080 1092 C900 		sts 201,__zero_reg__
 2284 0084 1092 BC00 		sts 188,__zero_reg__
 873:main.c        ****     			PORTB = 0; PORTC = 0; PORTD = 0; PORTE = 0; PORTF = 0;
 2285               		.loc 4 873 0
 2286 0088 14B8      		out 0x4,__zero_reg__
 2287 008a 17B8      		out 0x7,__zero_reg__
 2288 008c 1AB8      		out 0xa,__zero_reg__
 2289 008e 1DB8      		out 0xd,__zero_reg__
 2290 0090 10BA      		out 0x10,__zero_reg__
 2291 0092 1092 BC00 		sts 188,__zero_reg__
 874:main.c        ****     			asm volatile("jmp 0x7000");
 2292               		.loc 4 874 0
 2293 0096 15B8      		out 0x5,__zero_reg__
 2294 0098 18B8      		out 0x8,__zero_reg__
 2295 009a 1BB8      		out 0xb,__zero_reg__
 2296 009c 1EB8      		out 0xe,__zero_reg__
 2297 009e 11BA      		out 0x11,__zero_reg__
 875:main.c        **** 
 2298               		.loc 4 875 0
 2299               	/* #APP */
 2300               	 ;  875 "main.c" 1
 2301 00a0 0C94 0038 		jmp 0x7000
 2302               	 ;  0 "" 2
 2303               	/* #NOAPP */
 2304               	.L316:
 880:main.c        **** 		{
 2305               		.loc 4 880 0
 2306 00a4 8091 0000 		lds r24,watchdog
 2307 00a8 8130      		cpi r24,lo8(1)
 2308 00aa 01F4      		brne .L318
 883:main.c        **** 			{
 2309               		.loc 4 883 0
 2310 00ac 489B      		sbis 0x9,0
 2311 00ae 00C0      		rjmp .L319
 885:main.c        **** 			}
 2312               		.loc 4 885 0
 2313 00b0 8091 0000 		lds r24,watchi2c
 2314 00b4 9091 0000 		lds r25,watchi2c+1
 2315 00b8 0196      		adiw r24,1
 2316 00ba 9093 0000 		sts watchi2c+1,r25
 2317 00be 8093 0000 		sts watchi2c,r24
 2318 00c2 00C0      		rjmp .L320
 2319               	.L319:
 889:main.c        **** 			}
 2320               		.loc 4 889 0
 2321 00c4 1092 0000 		sts watchi2c+1,__zero_reg__
 2322 00c8 1092 0000 		sts watchi2c,__zero_reg__
 2323 00cc 1092 0000 		sts led+1,__zero_reg__
 2324 00d0 1092 0000 		sts led,__zero_reg__
 2325 00d4 1092 0000 		sts led+2,__zero_reg__
 2326 00d8 61E0      		ldi r22,lo8(1)
 2327 00da 70E0      		ldi r23,0
 2328 00dc 80E0      		ldi r24,lo8(led)
 2329 00de 90E0      		ldi r25,hi8(led)
 2330 00e0 0E94 0000 		call ws2812_setleds
 2331               	.LVL100:
 2332               	.L320:
 892:main.c        **** 		}
 2333               		.loc 4 892 0
 2334 00e4 8091 0000 		lds r24,watchi2c
 2335 00e8 9091 0000 		lds r25,watchi2c+1
 2336 00ec 8131      		cpi r24,17
 2337 00ee 9742      		sbci r25,39
 2338 00f0 00F0      		brlo .L318
 892:main.c        **** 		}
 2339               		.loc 4 892 0 is_stmt 0 discriminator 1
 2340 00f2 F092 0000 		sts led+1,r15
 2341 00f6 F092 0000 		sts led,r15
 2342 00fa 1092 0000 		sts led+2,__zero_reg__
 2343 00fe 61E0      		ldi r22,lo8(1)
 2344 0100 70E0      		ldi r23,0
 2345 0102 80E0      		ldi r24,lo8(led)
 2346 0104 90E0      		ldi r25,hi8(led)
 2347 0106 0E94 0000 		call ws2812_setleds
 2348               	.LVL101:
 2349               	.L318:
 895:main.c        **** 
 2350               		.loc 4 895 0 is_stmt 1
 2351 010a 4999      		sbic 0x9,1
 2352 010c 00C0      		rjmp .L322
 895:main.c        **** 
 2353               		.loc 4 895 0 is_stmt 0 discriminator 1
 2354 010e 8091 0000 		lds r24,i2cerror
 2355 0112 8F5F      		subi r24,lo8(-(1))
 2356 0114 8093 0000 		sts i2cerror,r24
 2357               	.L322:
 897:main.c        **** 		{
 2358               		.loc 4 897 0 is_stmt 1
 2359 0118 8091 0000 		lds r24,i2cerror
 2360 011c 893C      		cpi r24,lo8(-55)
 2361 011e 00F0      		brlo .L323
 899:main.c        **** 			I2C_init(I2C_ADDR);
 2362               		.loc 4 899 0
 2363 0120 0093 BC00 		sts 188,r16
 900:main.c        **** 			i2cerror = 0;
 2364               		.loc 4 900 0
 2365 0124 8AE2      		ldi r24,lo8(42)
 2366 0126 0E94 0000 		call I2C_init
 2367               	.LVL102:
 901:main.c        **** 			sei();
 2368               		.loc 4 901 0
 2369 012a 1092 0000 		sts i2cerror,__zero_reg__
 902:main.c        **** 		}
 2370               		.loc 4 902 0
 2371               	/* #APP */
 2372               	 ;  902 "main.c" 1
 2373 012e 7894      		sei
 2374               	 ;  0 "" 2
 2375               	/* #NOAPP */
 2376               	.L323:
 905:main.c        **** 		if (isrtimer > 31250)	 // routine for calculate fan speed - timer is 64khz
 2377               		.loc 4 905 0
 2378               	/* #APP */
 2379               	 ;  905 "main.c" 1
 2380 0130 A895      		wdr
 2381               	 ;  0 "" 2
 906:main.c        **** 		{						 // 2 signals each turn
 2382               		.loc 4 906 0
 2383               	/* #NOAPP */
 2384 0132 8091 0000 		lds r24,isrtimer
 2385 0136 9091 0000 		lds r25,isrtimer+1
 2386 013a 8331      		cpi r24,19
 2387 013c 9A47      		sbci r25,122
 2388 013e 00F0      		brlo .L325
 908:main.c        **** 			fanspin = 0;
 2389               		.loc 4 908 0
 2390 0140 2091 0000 		lds r18,fanspin
 2391 0144 3091 0000 		lds r19,fanspin+1
 2392 0148 C29E      		mul r12,r18
 2393 014a C001      		movw r24,r0
 2394 014c C39E      		mul r12,r19
 2395 014e 900D      		add r25,r0
 2396 0150 1124      		clr __zero_reg__
 2397 0152 9093 0000 		sts rpm+1,r25
 2398 0156 8093 0000 		sts rpm,r24
 909:main.c        **** 			isrtimer = 0;
 2399               		.loc 4 909 0
 2400 015a 1092 0000 		sts fanspin+1,__zero_reg__
 2401 015e 1092 0000 		sts fanspin,__zero_reg__
 910:main.c        **** 			if (fanlevel == 254) //fan minimal auto
 2402               		.loc 4 910 0
 2403 0162 1092 0000 		sts isrtimer+1,__zero_reg__
 2404 0166 1092 0000 		sts isrtimer,__zero_reg__
 911:main.c        **** 			{
 2405               		.loc 4 911 0
 2406 016a 2091 0000 		lds r18,fanlevel
 2407 016e 2E3F      		cpi r18,lo8(-2)
 2408 0170 01F4      		brne .L325
 913:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 2409               		.loc 4 913 0
 2410 0172 8F39      		cpi r24,-97
 2411 0174 9740      		sbci r25,7
 2412 0176 00F0      		brlo .L327
 913:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 2413               		.loc 4 913 0 is_stmt 0 discriminator 1
 2414 0178 87B5      		in r24,0x27
 2415 017a 8F5F      		subi r24,lo8(-(1))
 2416 017c 87BD      		out 0x27,r24
 2417               	.L327:
 914:main.c        **** 			}
 2418               		.loc 4 914 0 is_stmt 1
 2419 017e 8091 0000 		lds r24,rpm
 2420 0182 9091 0000 		lds r25,rpm+1
 2421 0186 8830      		cpi r24,8
 2422 0188 9740      		sbci r25,7
 2423 018a 00F4      		brsh .L325
 914:main.c        **** 			}
 2424               		.loc 4 914 0 is_stmt 0 discriminator 1
 2425 018c 87B5      		in r24,0x27
 2426 018e 8150      		subi r24,lo8(-(-1))
 2427 0190 87BD      		out 0x27,r24
 2428               	.L325:
 917:main.c        **** 
 2429               		.loc 4 917 0 is_stmt 1
 2430 0192 8091 0000 		lds r24,displaychange
 2431 0196 8823      		tst r24
 2432 0198 01F0      		breq .L328
 917:main.c        **** 
 2433               		.loc 4 917 0 is_stmt 0 discriminator 1
 2434 019a 0E94 0000 		call init_backlight
 2435               	.LVL103:
 2436 019e 1092 0000 		sts displaychange,__zero_reg__
 2437               	.L328:
 919:main.c        **** 		{
 2438               		.loc 4 919 0 is_stmt 1
 2439 01a2 8091 0000 		lds r24,changeled
 2440 01a6 8823      		tst r24
 2441 01a8 01F0      		breq .L329
 921:main.c        **** 			changeled = 0;
 2442               		.loc 4 921 0
 2443 01aa 6091 0000 		lds r22,led_position
 2444 01ae 70E0      		ldi r23,0
 2445 01b0 6F5F      		subi r22,-1
 2446 01b2 7F4F      		sbci r23,-1
 2447 01b4 80E0      		ldi r24,lo8(led)
 2448 01b6 90E0      		ldi r25,hi8(led)
 2449 01b8 0E94 0000 		call ws2812_setleds
 2450               	.LVL104:
 922:main.c        **** 		}
 2451               		.loc 4 922 0
 2452 01bc 1092 0000 		sts changeled,__zero_reg__
 2453               	.L329:
 925:main.c        **** 		{
 2454               		.loc 4 925 0
 2455 01c0 9091 0000 		lds r25,newbllevel
 2456 01c4 8091 0000 		lds r24,bllevel
 2457 01c8 9817      		cp r25,r24
 2458 01ca 01F0      		breq .L330
 925:main.c        **** 		{
 2459               		.loc 4 925 0 is_stmt 0 discriminator 1
 2460 01cc 9032      		cpi r25,lo8(32)
 2461 01ce 00F4      		brsh .L330
 928:main.c        **** 			{
 2462               		.loc 4 928 0 is_stmt 1
 2463 01d0 9817      		cp r25,r24
 2464 01d2 00F4      		brsh .L331
 930:main.c        **** 			}
 2465               		.loc 4 930 0
 2466 01d4 8150      		subi r24,lo8(-(-1))
 2467 01d6 00C0      		rjmp .L355
 2468               	.L331:
 934:main.c        **** 			}
 2469               		.loc 4 934 0
 2470 01d8 8F5F      		subi r24,lo8(-(1))
 2471               	.L355:
 2472 01da 8093 0000 		sts bllevel,r24
 937:main.c        **** 			write_backlight(0b00011111 & bllevel);
 2473               		.loc 4 937 0
 2474 01de 88E5      		ldi r24,lo8(88)
 2475 01e0 0E94 0000 		call write_backlight
 2476               	.LVL105:
 938:main.c        **** 		}
 2477               		.loc 4 938 0
 2478 01e4 8091 0000 		lds r24,bllevel
 2479 01e8 8F71      		andi r24,lo8(31)
 2480 01ea 0E94 0000 		call write_backlight
 2481               	.LVL106:
 2482               	.L330:
 941:main.c        **** 		{
 2483               		.loc 4 941 0
 2484 01ee 1A30      		cpi r17,lo8(10)
 2485 01f0 00F4      		brsh .L333
 943:main.c        **** 		}
 2486               		.loc 4 943 0
 2487 01f2 1F5F      		subi r17,lo8(-(1))
 2488               	.LVL107:
 950:main.c        **** 		{
 2489               		.loc 4 950 0
 2490 01f4 812F      		mov r24,r17
 2491 01f6 90E0      		ldi r25,0
 2492 01f8 FC01      		movw r30,r24
 2493 01fa 3197      		sbiw r30,1
 2494 01fc EA30      		cpi r30,10
 2495 01fe F105      		cpc r31,__zero_reg__
 2496 0200 00F0      		brlo .+2
 2497 0202 00C0      		rjmp .L334
 2498 0204 E050      		subi r30,lo8(-(gs(.L336)))
 2499 0206 F040      		sbci r31,hi8(-(gs(.L336)))
 2500 0208 0C94 0000 		jmp __tablejump2__
 2501               		.section	.progmem.gcc_sw_table,"a",@progbits
 2502               		.p2align	1
 2503               	.L336:
 2504 0030 0000      		.word gs(.L335)
 2505 0032 0000      		.word gs(.L337)
 2506 0034 0000      		.word gs(.L334)
 2507 0036 0000      		.word gs(.L338)
 2508 0038 0000      		.word gs(.L339)
 2509 003a 0000      		.word gs(.L334)
 2510 003c 0000      		.word gs(.L340)
 2511 003e 0000      		.word gs(.L341)
 2512 0040 0000      		.word gs(.L334)
 2513 0042 0000      		.word gs(.L342)
 2514               		.section	.text.startup
 2515               	.L333:
 2516               	.LVL108:
 952:main.c        **** 			case 1: a1 = read_analog(6);  break;
 2517               		.loc 4 952 0
 2518 020c 87E0      		ldi r24,lo8(7)
 2519 020e 0E94 0000 		call read_analog
 2520               	.LVL109:
 2521 0212 9093 0000 		sts a0+1,r25
 2522 0216 8093 0000 		sts a0,r24
 2523 021a 10E0      		ldi r17,0
 2524 021c 00C0      		rjmp .L315
 2525               	.LVL110:
 2526               	.L335:
 953:main.c        **** 			case 2: a2 = read_analog(5);  break;
 2527               		.loc 4 953 0
 2528 021e 86E0      		ldi r24,lo8(6)
 2529 0220 0E94 0000 		call read_analog
 2530               	.LVL111:
 2531 0224 9093 0000 		sts a1+1,r25
 2532 0228 8093 0000 		sts a1,r24
 2533 022c 00C0      		rjmp .L315
 2534               	.L337:
 954:main.c        **** 			case 4: a3 = read_analog(4);  break;
 2535               		.loc 4 954 0
 2536 022e 85E0      		ldi r24,lo8(5)
 2537 0230 0E94 0000 		call read_analog
 2538               	.LVL112:
 2539 0234 9093 0000 		sts a2+1,r25
 2540 0238 8093 0000 		sts a2,r24
 2541 023c 00C0      		rjmp .L315
 2542               	.L338:
 955:main.c        **** 			case 5: a4 = read_analog(1);  break;
 2543               		.loc 4 955 0
 2544 023e 84E0      		ldi r24,lo8(4)
 2545 0240 0E94 0000 		call read_analog
 2546               	.LVL113:
 2547 0244 9093 0000 		sts a3+1,r25
 2548 0248 8093 0000 		sts a3,r24
 2549 024c 00C0      		rjmp .L315
 2550               	.L339:
 956:main.c        **** 			case 7: a5 = read_analog(0);  break;
 2551               		.loc 4 956 0
 2552 024e 81E0      		ldi r24,lo8(1)
 2553 0250 0E94 0000 		call read_analog
 2554               	.LVL114:
 2555 0254 9093 0000 		sts a4+1,r25
 2556 0258 8093 0000 		sts a4,r24
 2557 025c 00C0      		rjmp .L315
 2558               	.L340:
 957:main.c        **** 			case 8: vcc = readVcc();  break;
 2559               		.loc 4 957 0
 2560 025e 80E0      		ldi r24,0
 2561 0260 0E94 0000 		call read_analog
 2562               	.LVL115:
 2563 0264 9093 0000 		sts a5+1,r25
 2564 0268 8093 0000 		sts a5,r24
 2565 026c 00C0      		rjmp .L315
 2566               	.L341:
 958:main.c        **** 			case 10: temp = GetTemp();   break;
 2567               		.loc 4 958 0
 2568 026e 0E94 0000 		call readVcc
 2569               	.LVL116:
 2570 0272 9093 0000 		sts vcc+1,r25
 2571 0276 8093 0000 		sts vcc,r24
 2572 027a 00C0      		rjmp .L315
 2573               	.L342:
 959:main.c        **** 
 2574               		.loc 4 959 0
 2575 027c 0E94 0000 		call GetTemp
 2576               	.LVL117:
 2577 0280 9093 0000 		sts temp+1,r25
 2578 0284 8093 0000 		sts temp,r24
 2579 0288 00C0      		rjmp .L315
 2580               	.L334:
 963:main.c        **** 				if (a7 > a7max) a7max = a7;
 2581               		.loc 4 963 0
 2582 028a 89E0      		ldi r24,lo8(9)
 2583 028c 0E94 0000 		call read_analog
 2584               	.LVL118:
 2585 0290 9093 0000 		sts a7+1,r25
 2586 0294 8093 0000 		sts a7,r24
 964:main.c        **** 				if (a7 < a7min) a7min = a7;
 2587               		.loc 4 964 0
 2588 0298 2091 0000 		lds r18,a7max
 2589 029c 3091 0000 		lds r19,a7max+1
 2590 02a0 2817      		cp r18,r24
 2591 02a2 3907      		cpc r19,r25
 2592 02a4 00F4      		brsh .L344
 964:main.c        **** 				if (a7 < a7min) a7min = a7;
 2593               		.loc 4 964 0 is_stmt 0 discriminator 1
 2594 02a6 9093 0000 		sts a7max+1,r25
 2595 02aa 8093 0000 		sts a7max,r24
 2596               	.L344:
 965:main.c        **** 				a7count++;
 2597               		.loc 4 965 0 is_stmt 1
 2598 02ae 2091 0000 		lds r18,a7min
 2599 02b2 3091 0000 		lds r19,a7min+1
 2600 02b6 8217      		cp r24,r18
 2601 02b8 9307      		cpc r25,r19
 2602 02ba 00F4      		brsh .L345
 965:main.c        **** 				a7count++;
 2603               		.loc 4 965 0 is_stmt 0 discriminator 1
 2604 02bc 9093 0000 		sts a7min+1,r25
 2605 02c0 8093 0000 		sts a7min,r24
 2606               	.L345:
 966:main.c        **** 				if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max = 0; a
 2607               		.loc 4 966 0 is_stmt 1
 2608 02c4 8091 0000 		lds r24,a7count
 2609 02c8 8F5F      		subi r24,lo8(-(1))
 2610 02ca 8093 0000 		sts a7count,r24
 2611               		.loc 4 967 0
 2612 02ce 8D33      		cpi r24,lo8(61)
 2613 02d0 00F4      		brsh .+2
 2614 02d2 00C0      		rjmp .L315
 2615               		.loc 4 967 0 is_stmt 0 discriminator 1
 2616 02d4 6091 0000 		lds r22,a7max
 2617 02d8 7091 0000 		lds r23,a7max+1
 2618 02dc 8091 0000 		lds r24,a7min
 2619 02e0 9091 0000 		lds r25,a7min+1
 2620 02e4 860F      		add r24,r22
 2621 02e6 971F      		adc r25,r23
 2622 02e8 9695      		lsr r25
 2623 02ea 8795      		ror r24
 2624 02ec 681B      		sub r22,r24
 2625 02ee 790B      		sbc r23,r25
 2626 02f0 80E0      		ldi r24,0
 2627 02f2 90E0      		ldi r25,0
 2628 02f4 0E94 0000 		call __floatunsisf
 2629               	.LVL119:
 2630 02f8 24EF      		ldi r18,lo8(-12)
 2631 02fa 3DEF      		ldi r19,lo8(-3)
 2632 02fc 44E3      		ldi r20,lo8(52)
 2633 02fe 5FE3      		ldi r21,lo8(63)
 2634 0300 0E94 0000 		call __mulsf3
 2635               	.LVL120:
 2636 0304 0E94 0000 		call __fixunssfsi
 2637               	.LVL121:
 2638 0308 7093 0000 		sts a7avg+1,r23
 2639 030c 6093 0000 		sts a7avg,r22
 2640 0310 D093 0000 		sts a7min+1,r29
 2641 0314 C093 0000 		sts a7min,r28
 2642 0318 1092 0000 		sts a7max+1,__zero_reg__
 2643 031c 1092 0000 		sts a7max,__zero_reg__
 2644 0320 1092 0000 		sts a7count,__zero_reg__
 2645 0324 00C0      		rjmp .L315
 2646               		.cfi_endproc
 2647               	.LFE37:
 2649               	.global	data_lcd_shpi397
 2650               		.data
 2653               	data_lcd_shpi397:
 2654 0000 FF00      		.word	255
 2655 0002 FF01      		.word	511
 2656 0004 9801      		.word	408
 2657 0006 0601      		.word	262
 2658 0008 0401      		.word	260
 2659 000a 0101      		.word	257
 2660 000c 0800      		.word	8
 2661 000e 1001      		.word	272
 2662 0010 2100      		.word	33
 2663 0012 0D01      		.word	269
 2664 0014 3000      		.word	48
 2665 0016 0201      		.word	258
 2666 0018 3100      		.word	49
 2667 001a 0001      		.word	256
 2668 001c 4000      		.word	64
 2669 001e 1001      		.word	272
 2670 0020 4100      		.word	65
 2671 0022 5501      		.word	341
 2672 0024 4200      		.word	66
 2673 0026 0201      		.word	258
 2674 0028 4300      		.word	67
 2675 002a 8401      		.word	388
 2676 002c 4400      		.word	68
 2677 002e 8401      		.word	388
 2678 0030 5000      		.word	80
 2679 0032 7801      		.word	376
 2680 0034 5100      		.word	81
 2681 0036 7801      		.word	376
 2682 0038 5200      		.word	82
 2683 003a 0001      		.word	256
 2684 003c 5300      		.word	83
 2685 003e 7701      		.word	375
 2686 0040 5700      		.word	87
 2687 0042 6001      		.word	352
 2688 0044 6000      		.word	96
 2689 0046 0701      		.word	263
 2690 0048 6100      		.word	97
 2691 004a 0001      		.word	256
 2692 004c 6200      		.word	98
 2693 004e 0801      		.word	264
 2694 0050 6300      		.word	99
 2695 0052 0001      		.word	256
 2696 0054 A000      		.word	160
 2697 0056 0001      		.word	256
 2698 0058 A100      		.word	161
 2699 005a 0701      		.word	263
 2700 005c A200      		.word	162
 2701 005e 0C01      		.word	268
 2702 0060 A300      		.word	163
 2703 0062 0B01      		.word	267
 2704 0064 A400      		.word	164
 2705 0066 0301      		.word	259
 2706 0068 A500      		.word	165
 2707 006a 0701      		.word	263
 2708 006c A600      		.word	166
 2709 006e 0601      		.word	262
 2710 0070 A700      		.word	167
 2711 0072 0401      		.word	260
 2712 0074 A800      		.word	168
 2713 0076 0801      		.word	264
 2714 0078 A900      		.word	169
 2715 007a 0C01      		.word	268
 2716 007c AA00      		.word	170
 2717 007e 1301      		.word	275
 2718 0080 AB00      		.word	171
 2719 0082 0601      		.word	262
 2720 0084 AC00      		.word	172
 2721 0086 0D01      		.word	269
 2722 0088 AD00      		.word	173
 2723 008a 1901      		.word	281
 2724 008c AE00      		.word	174
 2725 008e 1001      		.word	272
 2726 0090 AF00      		.word	175
 2727 0092 0001      		.word	256
 2728 0094 C000      		.word	192
 2729 0096 0001      		.word	256
 2730 0098 C100      		.word	193
 2731 009a 0701      		.word	263
 2732 009c C200      		.word	194
 2733 009e 0C01      		.word	268
 2734 00a0 C300      		.word	195
 2735 00a2 0B01      		.word	267
 2736 00a4 C400      		.word	196
 2737 00a6 0301      		.word	259
 2738 00a8 C500      		.word	197
 2739 00aa 0701      		.word	263
 2740 00ac C600      		.word	198
 2741 00ae 0701      		.word	263
 2742 00b0 C700      		.word	199
 2743 00b2 0401      		.word	260
 2744 00b4 C800      		.word	200
 2745 00b6 0801      		.word	264
 2746 00b8 C900      		.word	201
 2747 00ba 0C01      		.word	268
 2748 00bc CA00      		.word	202
 2749 00be 1301      		.word	275
 2750 00c0 CB00      		.word	203
 2751 00c2 0601      		.word	262
 2752 00c4 CC00      		.word	204
 2753 00c6 0D01      		.word	269
 2754 00c8 CD00      		.word	205
 2755 00ca 1801      		.word	280
 2756 00cc CE00      		.word	206
 2757 00ce 1001      		.word	272
 2758 00d0 CF00      		.word	207
 2759 00d2 0001      		.word	256
 2760 00d4 FF00      		.word	255
 2761 00d6 FF01      		.word	511
 2762 00d8 9801      		.word	408
 2763 00da 0601      		.word	262
 2764 00dc 0401      		.word	260
 2765 00de 0601      		.word	262
 2766 00e0 0000      		.word	0
 2767 00e2 2001      		.word	288
 2768 00e4 0100      		.word	1
 2769 00e6 0A01      		.word	266
 2770 00e8 0200      		.word	2
 2771 00ea 0001      		.word	256
 2772 00ec 0300      		.word	3
 2773 00ee 0001      		.word	256
 2774 00f0 0400      		.word	4
 2775 00f2 0101      		.word	257
 2776 00f4 0500      		.word	5
 2777 00f6 0101      		.word	257
 2778 00f8 0600      		.word	6
 2779 00fa 9801      		.word	408
 2780 00fc 0700      		.word	7
 2781 00fe 0601      		.word	262
 2782 0100 0800      		.word	8
 2783 0102 0101      		.word	257
 2784 0104 0900      		.word	9
 2785 0106 8001      		.word	384
 2786 0108 0A00      		.word	10
 2787 010a 0001      		.word	256
 2788 010c 0B00      		.word	11
 2789 010e 0001      		.word	256
 2790 0110 0C00      		.word	12
 2791 0112 0101      		.word	257
 2792 0114 0D00      		.word	13
 2793 0116 0101      		.word	257
 2794 0118 0E00      		.word	14
 2795 011a 0001      		.word	256
 2796 011c 0F00      		.word	15
 2797 011e 0001      		.word	256
 2798 0120 1000      		.word	16
 2799 0122 F001      		.word	496
 2800 0124 1100      		.word	17
 2801 0126 F401      		.word	500
 2802 0128 1200      		.word	18
 2803 012a 0101      		.word	257
 2804 012c 1300      		.word	19
 2805 012e 0001      		.word	256
 2806 0130 1400      		.word	20
 2807 0132 0001      		.word	256
 2808 0134 1500      		.word	21
 2809 0136 C001      		.word	448
 2810 0138 1600      		.word	22
 2811 013a 0801      		.word	264
 2812 013c 1700      		.word	23
 2813 013e 0001      		.word	256
 2814 0140 1800      		.word	24
 2815 0142 0001      		.word	256
 2816 0144 1900      		.word	25
 2817 0146 0001      		.word	256
 2818 0148 1A00      		.word	26
 2819 014a 0001      		.word	256
 2820 014c 1B00      		.word	27
 2821 014e 0001      		.word	256
 2822 0150 1C00      		.word	28
 2823 0152 0001      		.word	256
 2824 0154 1D00      		.word	29
 2825 0156 0001      		.word	256
 2826 0158 2000      		.word	32
 2827 015a 0101      		.word	257
 2828 015c 2100      		.word	33
 2829 015e 2301      		.word	291
 2830 0160 2200      		.word	34
 2831 0162 4501      		.word	325
 2832 0164 2300      		.word	35
 2833 0166 6701      		.word	359
 2834 0168 2400      		.word	36
 2835 016a 0101      		.word	257
 2836 016c 2500      		.word	37
 2837 016e 2301      		.word	291
 2838 0170 2600      		.word	38
 2839 0172 4501      		.word	325
 2840 0174 2700      		.word	39
 2841 0176 6701      		.word	359
 2842 0178 3000      		.word	48
 2843 017a 1101      		.word	273
 2844 017c 3100      		.word	49
 2845 017e 1101      		.word	273
 2846 0180 3200      		.word	50
 2847 0182 0001      		.word	256
 2848 0184 3300      		.word	51
 2849 0186 EE01      		.word	494
 2850 0188 3400      		.word	52
 2851 018a FF01      		.word	511
 2852 018c 3500      		.word	53
 2853 018e BB01      		.word	443
 2854 0190 3600      		.word	54
 2855 0192 AA01      		.word	426
 2856 0194 3700      		.word	55
 2857 0196 DD01      		.word	477
 2858 0198 3800      		.word	56
 2859 019a CC01      		.word	460
 2860 019c 3900      		.word	57
 2861 019e 6601      		.word	358
 2862 01a0 3A00      		.word	58
 2863 01a2 7701      		.word	375
 2864 01a4 3B00      		.word	59
 2865 01a6 2201      		.word	290
 2866 01a8 3C00      		.word	60
 2867 01aa 2201      		.word	290
 2868 01ac 3D00      		.word	61
 2869 01ae 2201      		.word	290
 2870 01b0 3E00      		.word	62
 2871 01b2 2201      		.word	290
 2872 01b4 3F00      		.word	63
 2873 01b6 2201      		.word	290
 2874 01b8 4000      		.word	64
 2875 01ba 2201      		.word	290
 2876 01bc 5200      		.word	82
 2877 01be 1001      		.word	272
 2878 01c0 5300      		.word	83
 2879 01c2 1001      		.word	272
 2880 01c4 5400      		.word	84
 2881 01c6 1301      		.word	275
 2882 01c8 FF00      		.word	255
 2883 01ca FF01      		.word	511
 2884 01cc 9801      		.word	408
 2885 01ce 0601      		.word	262
 2886 01d0 0401      		.word	260
 2887 01d2 0701      		.word	263
 2888 01d4 1800      		.word	24
 2889 01d6 1D01      		.word	285
 2890 01d8 1700      		.word	23
 2891 01da 2201      		.word	290
 2892 01dc 0200      		.word	2
 2893 01de 7701      		.word	375
 2894 01e0 2600      		.word	38
 2895 01e2 B201      		.word	434
 2896 01e4 E100      		.word	225
 2897 01e6 7901      		.word	377
 2898 01e8 FF00      		.word	255
 2899 01ea FF01      		.word	511
 2900 01ec 9801      		.word	408
 2901 01ee 0601      		.word	262
 2902 01f0 0401      		.word	260
 2903 01f2 0001      		.word	256
 2904 01f4 3A00      		.word	58
 2905 01f6 6001      		.word	352
 2906 01f8 3500      		.word	53
 2907 01fa 0001      		.word	256
 2908 01fc 1100      		.word	17
 2909 01fe 0001      		.word	256
 2910 0200 FFFF      		.word	-1
 2911 0202 2900      		.word	41
 2912 0204 0001      		.word	256
 2913               	.global	watchi2c
 2914               		.section .bss
 2917               	watchi2c:
 2918 0000 0000      		.zero	2
 2919               	.global	i2cbuffer
 2922               	i2cbuffer:
 2923 0002 0000      		.zero	2
 2924               		.comm	isrtimer,2,1
 2925               		.comm	fanspin,2,1
 2926               		.comm	rpm,2,1
 2927               		.comm	temp,2,1
 2928               		.comm	vcc,2,1
 2929               		.comm	a7min,2,1
 2930               		.comm	a7max,2,1
 2931               		.comm	a7avg,2,1
 2932               		.comm	a7,2,1
 2933               		.comm	a5,2,1
 2934               		.comm	a4,2,1
 2935               		.comm	a3,2,1
 2936               		.comm	a2,2,1
 2937               		.comm	a1,2,1
 2938               		.comm	a0,2,1
 2939               	.global	fanlevel
 2940               		.data
 2943               	fanlevel:
 2944 0206 FE        		.byte	-2
 2945               	.global	i2cerror
 2946               		.section .bss
 2949               	i2cerror:
 2950 0004 00        		.zero	1
 2951               		.comm	crc,1,1
 2952               		.comm	changeled,1,1
 2953               	.global	newbllevel
 2954               		.data
 2957               	newbllevel:
 2958 0207 1F        		.byte	31
 2959               	.global	bllevel
 2962               	bllevel:
 2963 0208 1F        		.byte	31
 2964               		.comm	count,1,1
 2965               	.global	a7count
 2966               		.section .bss
 2969               	a7count:
 2970 0005 00        		.zero	1
 2971               		.comm	buffer_address,1,1
 2972               		.comm	twdrbuffer,1,1
 2973               	.global	commandbyte
 2974               		.data
 2977               	commandbyte:
 2978 0209 FF        		.byte	-1
 2979               	.global	crc_active
 2982               	crc_active:
 2983 020a FF        		.byte	-1
 2984               	.global	led_position
 2985               		.section .bss
 2988               	led_position:
 2989 0006 00        		.zero	1
 2990               	.global	display
 2991               		.data
 2994               	display:
 2995 020b FF        		.byte	-1
 2996               	.global	watchdog
 2997               		.section .bss
 3000               	watchdog:
 3001 0007 00        		.zero	1
 3002               	.global	jumptobootloader
 3005               	jumptobootloader:
 3006 0008 00        		.zero	1
 3007               	.global	displaychange
 3010               	displaychange:
 3011 0009 00        		.zero	1
 3012               		.comm	led,765,1
 3013               		.text
 3014               	.Letext0:
 3015               		.file 7 "/usr/lib/avr/include/stdint.h"
 3016               		.file 8 "light_ws2812.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccRcznQe.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccRcznQe.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccRcznQe.s:4      *ABS*:0000003f __SREG__
     /tmp/ccRcznQe.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccRcznQe.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccRcznQe.s:11     .text:00000000 _crc8_ccitt_update
     /tmp/ccRcznQe.s:43     .text:00000012 ws2812_sendarray_mask
     /tmp/ccRcznQe.s:93     .text:00000038 loop59
     /tmp/ccRcznQe.s:130    .text:00000068 ws2812_setleds_pin
     /tmp/ccRcznQe.s:167    .text:00000084 ws2812_setleds
     /tmp/ccRcznQe.s:185    .text:0000008a ws2812_sendarray
     /tmp/ccRcznQe.s:203    .text:00000090 write_backlight
     /tmp/ccRcznQe.s:337    .text:0000010a init_backlight
     /tmp/ccRcznQe.s:2962   .data:00000208 bllevel
     /tmp/ccRcznQe.s:2957   .data:00000207 newbllevel
     /tmp/ccRcznQe.s:414    .text:0000014a write_lcd
     /tmp/ccRcznQe.s:509    .text:0000019e setup_lcd
     /tmp/ccRcznQe.s:2653   .data:00000000 data_lcd_shpi397
     /tmp/ccRcznQe.s:590    .text:000001e6 read_analog
     /tmp/ccRcznQe.s:674    .text:00000254 readVcc
     /tmp/ccRcznQe.s:746    .text:000002c2 GetTemp
     /tmp/ccRcznQe.s:811    .text:00000320 freeRam
     /tmp/ccRcznQe.s:859    .text:0000034e I2C_init
                            *COM*:00000001 buffer_address
     /tmp/ccRcznQe.s:890    .text:00000364 __vector_9
                            *COM*:00000002 fanspin
     /tmp/ccRcznQe.s:947    .text:00000398 __vector_23
                            *COM*:00000002 isrtimer
     /tmp/ccRcznQe.s:994    .text:000003c6 __vector_36
     /tmp/ccRcznQe.s:2977   .data:00000209 commandbyte
     /tmp/ccRcznQe.s:2982   .data:0000020a crc_active
                            *COM*:00000001 crc
     /tmp/ccRcznQe.s:2949   .bss:00000004 i2cerror
                            *COM*:00000002 a0
                            *COM*:00000002 a1
                            *COM*:00000002 a2
                            *COM*:00000002 a3
                            *COM*:00000002 a4
                            *COM*:00000002 a5
                            *COM*:00000002 a7
                            *COM*:00000002 rpm
                            *COM*:00000002 vcc
                            *COM*:00000002 temp
                            *COM*:00000002 a7avg
     /tmp/ccRcznQe.s:2922   .bss:00000002 i2cbuffer
                            *COM*:00000001 twdrbuffer
     /tmp/ccRcznQe.s:3010   .bss:00000009 displaychange
     /tmp/ccRcznQe.s:2994   .data:0000020b display
     /tmp/ccRcznQe.s:2943   .data:00000206 fanlevel
     /tmp/ccRcznQe.s:2988   .bss:00000006 led_position
                            *COM*:000002fd led
                            *COM*:00000001 changeled
     /tmp/ccRcznQe.s:3005   .bss:00000008 jumptobootloader
     /tmp/ccRcznQe.s:3000   .bss:00000007 watchdog
     /tmp/ccRcznQe.s:1994   .text:000009d6 setup
     /tmp/ccRcznQe.s:2185   .text.startup:00000000 main
     /tmp/ccRcznQe.s:2917   .bss:00000000 watchi2c
                            *COM*:00000002 a7max
                            *COM*:00000002 a7min
     /tmp/ccRcznQe.s:2969   .bss:00000005 a7count
                            *COM*:00000001 count

UNDEFINED SYMBOLS
__divmodsi4
__brkval
__heap_start
__tablejump2__
__floatunsisf
__mulsf3
__fixunssfsi
__do_copy_data
__do_clear_bss
